head:
  title: BetterDocs
  metatags:
    description: माणिक उदाहरण और संदर्भ के साथ मौलिक प्रोग्रामिंग। इसमें थ्रेड, एसओएलआईडी
      सिद्धांत, डिजाइन पैटर्न, डेटा संरचनाएं, एल्गोरिदम शामिल हैं।
    keywords: बेहतर डॉक्स, रूबी, फंडामेंटल, रूबी प्रोग्रामिंग फंडामेंटल्स। रूबी गोचर्स,
      फंक्शनल प्रोग्रामिंग, मेटाप्रोग्रामिंग, थ्रेड्स, उदाहरणों के साथ रूबी ठोस सिद्धांत,
      उदाहरणों के साथ रूबी डिजाइन पैटर्न, उदाहरणों के साथ रूबी एल्गोरिदम, उदाहरणों
      के साथ रूबी डेटा संरचनाएं।
content:
  menu:
    open: मेनू खोलें
    close: मेनू बंद करें

sidebar:
  - title: एल्गोरिदम
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: डेटा संरचनाएं
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: डिजाइन पैटर्न्स
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: कार्यात्मक प्रोग्रामिंग
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: साक्षात्कार के प्रश्न
    url: interview_questions
  - title: मेटा प्रोग्रामिंग
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: ठोस सिद्धांत
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: रूबी मिस्टर बनें
    url: ruby_meister
  - title: धागे
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:
  wiki: विकि पढ़ें
  credits: क्रेडिट
  page404:
    title: पृष्ठ नहीं मिला :(
    description: अनुरोध किया गया पेज़ नहीं मिल सका।
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: एल्गोरिदम
    complexity:
      best: श्रेष्ठ
      average: औसत
      worst: सबसे खराब
    sorting:
      title: छंटाई
      description: एक सॉर्टिंग एल्गोरिथ्म एक एल्गोरिथ्म है जो एक सूची के तत्वों को एक
        निश्चित क्रम में रखता है। सबसे अधिक उपयोग किए जाने वाले आदेश संख्यात्मक आदेश
        और लेक्सोग्राफिक आदेश हैं। अन्य एल्गोरिदम (जैसे खोज और मर्ज एल्गोरिदम) के उपयोग
        को अनुकूलित करने के लिए कुशल छँटाई महत्वपूर्ण है जो कि इनपुट डेटा को क्रमबद्ध
        सूचियों में रखने की आवश्यकता होती है; यह अक्सर कैनोनिकलाइजिंग डेटा और मानव-पठनीय
        उत्पादन के लिए भी उपयोगी है।
      bubble_sort:
        title: बबल शॅाट
        description: बबल सॉर्ट में सम्मिलन सॉर्ट के समान कई गुण हैं, लेकिन ओवरहेड थोड़ा
          अधिक है। लगभग सॉर्ट किए गए डेटा के मामले में, बुलबुला सॉर्ट <span class="code-inline
          time">O(n)</span> लेता है, लेकिन डेटा के माध्यम से कम से कम 2 पास की आवश्यकता
          होती है (जबकि सम्मिलन सॉर्ट के लिए कुछ और की आवश्यकता होती है जैसे 1 पास)।
      insertion_sort:
        title: सम्मिलन सॉर्ट
        description: यद्यपि यह <span class="code-inline">O(n<sup>2</sup>)</span>
          सबसे खराब समय के साथ प्राथमिक सॉर्टिंग एल्गोरिदम में से एक है, सम्मिलन सॉर्ट
          पसंद का एल्गोरिथ्म या तो जब डेटा लगभग सॉर्ट किया जाता है (क्योंकि यह अनुकूली
          है) या जब समस्या का आकार छोटा होता है (क्योंकि यह है कम ओवरहेड है)। इन कारणों
          के लिए, और क्योंकि यह भी स्थिर है, सम्मिलन प्रकार का उपयोग अक्सर उच्च ओवरहाइड
          डिवाइड और-विजयी सॉर्टिंग एल्गोरिदम जैसे मर्ज सॉर्ट या त्वरित सॉर्ट के लिए
          पुनरावर्ती बेस केस (जब समस्या का आकार छोटा होता है) के रूप में किया जाता है।
      selection_sort:
        title: चयन छांटना
        description: यहां प्रस्तुत तुलना से, कोई यह निष्कर्ष निकाल सकता है कि चयन प्रकार
          का उपयोग कभी नहीं किया जाना चाहिए। यह किसी भी तरह से डेटा के अनुकूल नहीं है
          (ध्यान दें कि लॉकस्टेप में ऊपर के चार एनिमेशन चलते हैं), इसलिए इसका रनटाइम
          हमेशा द्विघात होता है। हालांकि, चयन प्रकार में स्वैप की संख्या को कम करने
          की संपत्ति है। उन अनुप्रयोगों में जहां स्वैपिंग आइटम की लागत अधिक है, चयन
          प्रकार बहुत अच्छी तरह से पसंद का एल्गोरिदम हो सकता है।
      shell_sort:
        title: खोल छाँट
        description: शेल प्रकार का सबसे खराब समय जटिलता जटिलता क्रम पर निर्भर करता है।
          वेतन वृद्धि के लिए 1 4 13 40 121 ..., जो कि यहां उपयोग किया जाता है, समय की
          जटिलता <span class="code-inline">O(n<sup><sup>3</sup>/<sub>2</sub></sup>)</span> । अन्य वेतन वृद्धि के लिए,
          समय जटिलता <span class="code-inline">O(n<sup><sup>4</sup>/<sub>3</sub></sup>)</span> और यहां तक कि
          <span class="code-inline">O(n·lg<sub>2</sub>(n))
          के रूप में जाना जाता है</span> । समय जटिलता पर न तो तंग ऊपरी सीमाएं और न ही
          सबसे अच्छा वेतन वृद्धि अनुक्रम ज्ञात है। क्योंकि शैल प्रकार सम्मिलन प्रकार
          पर आधारित है, शैल प्रकार प्रविष्टि प्रकार के अनुकूली गुणों को विरासत में मिला
          है। अनुकूलन उतना नाटकीय नहीं है क्योंकि शेल की तरह प्रत्येक वृद्धि के लिए
          डेटा के माध्यम से एक पास की आवश्यकता होती है, लेकिन यह महत्वपूर्ण है। ऊपर
          दिखाए गए वेतन वृद्धि अनुक्रम के लिए, <span class="code-inline">log<sub>3</sub>
          (n)</span> वेतन वृद्धि हैं, इसलिए लगभग सॉर्ट किए गए डेटा की समय जटिलता <span
          class="code-inline">O(n·log(<sub>3</sub>(n))</span> । इसके कम ओवरहेड,
          अपेक्षाकृत सरल कार्यान्वयन, अनुकूली गुण, और उप-द्विघात समय जटिलता के कारण,
          शेल सॉर्ट कुछ अनुप्रयोगों के लिए <span class="code-inline">O(n·lg(n))</span>
          सॉर्टिंग एल्गोरिदम का एक व्यवहार्य विकल्प हो सकता है जब डेटा सॉर्ट किया जाना
          है बहुत बड़ा नहीं है।
      heap_sort:
        title: ढेर बनाएं और छांटें
        description: हेप्सोर्ट लागू करने के लिए सरल है, एक <span class=\"code-inline\">O(n·lg(n))</span>
          इन-प्लेस सॉर्ट करता है, लेकिन स्थिर नहीं है। पहला
          लूप, <span class="code-inline">Θ(n)</span> &quot;हीप्लीज़&quot; चरण, सरणी
          को ढेर क्रम में रखता है। दूसरा लूप, <span class="code-inline">O(n·lg(n))</span>
          &quot;सॉर्ट डाउन&quot; चरण, बार-बार अधिकतम और पुनर्स्थापना ढेर क्रम को निकालता
          है। सिंक फ़ंक्शन स्पष्टता के लिए पुनरावर्ती लिखा जाता है। इस प्रकार, जैसा
          कि दिखाया गया है, पुनरावर्ती कॉल स्टैक के लिए कोड को <span class="code-inline">Θlg(n))</span>
          स्थान की आवश्यकता होती है। हालांकि, सिंक () में पूंछ की पुनरावृत्ति
          आसानी से पुनरावृत्ति में परिवर्तित हो जाती है, जो <span class="code-inline">O(1)</span>
          स्थान को बाध्य करती है। दोनों चरण थोड़ा अनुकूली होते हैं, हालांकि
          किसी विशेष रूप से उपयोगी तरीके से नहीं। लगभग छांटे गए मामले में, हाइपिफाय
          चरण मूल आदेश को नष्ट कर देता है। उलट मामले में, ढेर के चरण के रूप में उपवास
          के बाद से हीप क्रम में शुरू होता है, लेकिन फिर नीचे चरण चरण विशिष्ट है। कुछ
          विशिष्ट कुंजियों के मामले में, कुछ स्पीडअप है लेकिन शेल सॉर्ट या 3-वे क्विकॉर्ट
          में उतना नहीं है।
      merge_sort:
        title: मर्ज़ सॉर्ट
        description: 'मर्ज सॉर्ट बहुत अनुमानित है। यह प्रति तत्व <span class="code-inline">0.5lg
          (n)</span> और <span class="code-inline">lg(n)</span> तुलना के बीच बनाता है,
          और <span class="code-inline">lg(n)</span> और <span class="code-inline">1.5lg(n)</span>
          के बीच प्रति तत्व स्वैप होता है। पहले से ही सॉर्ट किए गए डेटा के
          लिए मिनीमा हासिल किया जाता है; अधिकतम रैंडम डेटा के लिए, औसतन प्राप्त किया
          जाता है। यदि concern <span class="code-inline">(n)</span> अतिरिक्त स्थान का
          उपयोग करना कोई चिंता का विषय नहीं है, तो मर्ज सॉर्ट एक उत्कृष्ट विकल्प है:
          इसे लागू करना सरल है, और यह एकमात्र स्थिर <span class="code-inline">O(n·lg(n))</span>
          सॉर्टिंग एल्गोरिदम है। ध्यान दें कि लिंक की गई सूचियों को
          क्रमबद्ध करते समय, मर्ज सॉर्ट के लिए केवल <span class="code-inline">Θ(lg(n)</span>
          अतिरिक्त स्थान (पुनरावर्तन के लिए) की आवश्यकता होती है। मर्ज सॉर्ट
          विभिन्न स्थितियों के लिए पसंद का एल्गोरिथ्म है: जब लिंक की गई सूचियों को क्रमबद्ध
          करते समय स्थिरता की आवश्यकता होती है, और जब यादृच्छिक होती है पहुंच अनुक्रमिक
          पहुंच (उदाहरण के लिए, टेप पर बाहरी छंटाई) की तुलना में बहुत अधिक महंगी है।
          एल्गोरिथ्म के अंतिम चरण के लिए रैखिक समय-स्थान मर्ज एल्गोरिदम मौजूद हैं, लेकिन
          वे दोनों महंगे और जटिल हैं। अनुप्रयोगों के लिए जटिलता उचित है। जब such <span
          class="code-inline">Θ(n)</span> अतिरिक्त स्थान उपलब्ध न हो तो बाहरी छँटाई।'
      quick_sort:
        title: जल्दी से सुलझाएं
        description: जब ध्यान से लागू किया जाता है, तो क्विकॉर्ट मजबूत है और कम ओवरहेड
          है। जब एक स्थिर सॉर्ट की आवश्यकता नहीं होती है, तो क्विकॉर्ट एक उत्कृष्ट सामान्य-उद्देश्य
          सॉर्ट है - हालांकि 3-तरफा विभाजन संस्करण हमेशा इसके बजाय उपयोग किया जाना चाहिए।
          ऊपर दिखाया गया 2-तरफा विभाजन कोड इष्टतम प्रदर्शन के बजाय स्पष्टता के लिए लिखा
          गया है; यह गरीब इलाके को प्रदर्शित करता है, और, गंभीर रूप से, <span class="code-inline">O(<sup>2</sup>)</span>
          समय का प्रदर्शन करता है जब कुछ अद्वितीय चाबियाँ
          होती हैं। क्विकॉर्ट में एक अधिक कुशल और मजबूत 2-वे पार्टीशन विधि दी गई है
          जो रॉबर्ट सेडविक और जॉन बेंटले द्वारा ऑप्टिमल है। मजबूत विभाजन संतुलित पुनर्संरचना
          पैदा करता है जब धुरी के बराबर कई मान होते हैं, सभी आदानों के लिए <span class="code-inline">O
          (n·lg(n))</span> समय और <span class="code-inline">O(lg(n))</span> स्थान
          की संभाव्य गारंटी देता है। दोनों उप-प्रकारों के साथ पुनरावर्ती प्रदर्शन किया
          जाता है, त्वरित प्रकार के लिए <span class="code-inline">O(n)</span> आवश्यकता
          होती है, जब पुनरावृत्ति संतुलित नहीं होती है, तो सबसे खराब स्थिति में पुनरावृत्ति
          के ढेर के लिए अतिरिक्त स्थान। यह अत्यधिक होने की संभावना नहीं है, लेकिन इसे
          पहले छोटे उप-सरणी को पुनरावर्ती रूप से सॉर्ट करके रोका जा सकता है; दूसरा उप-सरणी
          सॉर्ट एक पूंछ पुनरावर्ती कॉल है, जिसे इसके बजाय पुनरावृत्ति के साथ किया जा
          सकता है। इस अनुकूलन के साथ, एल्गोरिथ्म सबसे खराब स्थिति में <span class="code-inline">O(lg(n))</span>
          अतिरिक्त स्थान का उपयोग करता है।
      other: अन्य छँटाई एल्गोरिदम
      additional: अतिरिक्त पढ़ने
    searching:
      title: खोज कर
      binary_search:
        title: द्विआधारी खोज
        description: कंप्यूटर विज्ञान में, द्विआधारी खोज, जिसे अर्ध-अंतराल खोज या लॉगरिदमिक
          खोज के रूप में भी जाना जाता है, एक खोज एल्गोरिथ्म है जो एक क्रमबद्ध सरणी के
          भीतर एक लक्ष्य मान की स्थिति पाता है। यह सरणी के मध्य तत्व के लिए लक्ष्य मूल्य
          की तुलना करता है; यदि वे असमान हैं, तो जो लक्ष्य झूठ नहीं बोल सकता है, वह
          आधा समाप्त हो जाता है और शेष आधा होने तक खोज जारी रहती है।
      knuth_moriss_pratt_search:
        title: नूथ-मॉरिस-प्रैट खोज
        description: 'कंप्यूटर विज्ञान में, नूत-मॉरिस-प्रैट स्ट्रिंग सर्चिंग एल्गोरिथ्म
          (या केएमपी एल्गोरिदम) एक &quot;शब्द&quot; डब्ल्यू के मुख्य &quot;टेक्स्ट स्ट्रिंग&quot;
          एस के अवलोकन के लिए खोज करता है ताकि अवलोकन हो सके कि जब कोई मिसमैच होता है,
          तो शब्द ही पर्याप्त रूप से खोज करता है यह निर्धारित करने के लिए जानकारी कि
          अगला मैच कहां शुरू हो सकता है, इस प्रकार पहले से मिलान किए गए पात्रों की पुन:
          परीक्षा को दरकिनार कर सकता है।'
      other:
        title: अन्य खोज एल्गोरिदम
        dijkstra: दीजकस्ट्रा का एल्गोरिदम
        kruskal: क्रुसल का एल्गोरिदम
        longest: सबसे लंबे समय तक बढ़ रहा है
        telephone_number: शब्दों को टेलीफोन नंबर
    credits: 'कोड और लेख संसाधनों से लिए गए थे:'
  data_structures:
    title: डेटा संरचनाएं
    description: कंप्यूटर विज्ञान में, बड़े ओ नोटेशन का उपयोग एल्गोरिदम को वर्गीकृत
      करने के लिए किया जाता है कि वे इनपुट आकार में परिवर्तन का जवाब कैसे देते हैं,
      जैसे कि एल्गोरिथ्म का प्रसंस्करण समय कैसे बदलता है क्योंकि समस्या का आकार बहुत
      बड़ा हो जाता है। विश्लेषणात्मक संख्या सिद्धांत में इसका उपयोग &quot;त्रुटि&quot;
      करने के लिए किया जाता है, जबकि एक बड़े परिमित तर्क में इसके मूल्य के अंकगणितीय
      फलन के असममित आकार को प्रतिस्थापित करते हुए। एक प्रसिद्ध उदाहरण प्राइम नंबर प्रमेय
      में शेष शब्द का अनुमान लगाने की समस्या है।
    axioms:
      title: डेटा संरचनाओं के मूल स्वयंसिद्ध
      description: सामान्य भाषा के रनटाइम के रनिंग टाइम का प्रदर्शन स्वयंसिद्धों के
        एक सेट द्वारा दिया जाता है जिसे हम अब स्थगित कर देंगे।
      fetch_store:
        title: समय और स्टोर करें
        description1: स्मृति से किसी ऑब्जेक्ट के लिए एक संदर्भ लाने के लिए आवश्यक समय
          एक स्थिर, <span class="code-inline">T_fetch</span> है, और स्मृति में किसी
          ऑब्जेक्ट के संदर्भ को संग्रहीत करने के लिए आवश्यक समय एक स्थिर, <span class="code-inline">T_store</span> है.
        description2: Axiom के अनुसार, असाइनमेंट स्टेटमेंट में <span class="code-inline">T_fetch
          + T_store</span> का समय चल रहा है। यही है, चर x से वस्तु संदर्भ प्राप्त करने
          के लिए लिया गया समय <span class="code-inline">T_fetch</span> है और चर y में
          ऑब्जेक्ट का संदर्भ संग्रहीत करने के लिए लिया गया समय <span class="code-inline">T_store</span> है ।
        description3: इसके अलावा रनिंग टाइम <span class="code-inline">T_fetch + T_store</span> है । यह देखने के लिए कि ऐसा क्यों होना चाहिए, विचार करें कि स्थिर <span
          class="code-inline">1</span> का मान एक के साथ एक Fixnum ऑब्जेक्ट है। इसलिए,
          हम 1 नाम वाली वस्तु के संदर्भ को प्राप्त करने की लागत की अपेक्षा कर सकते हैं,
          जो कि किसी अन्य वस्तु के संदर्भ को लाने के समान है।
      elementary_operations:
        title: प्राथमिक अंकगणितीय संचालन समय
        description1: प्रारंभिक अंकगणितीय संक्रियाओं को करने के लिए आवश्यक समय, जैसे
          कि जोड़, घटाव, गुणा, भाग और तुलना, ये दोनों स्थिरांक हैं। ये समय क्रमशः<span class="code-inline">
          T_ +, T_-, T_ /, T_ *, T_<;</span> द्वारा दर्शाया जाता है।
        description2: हम एक कथन का समय निर्धारित कर सकते हैं जैसे <span class="code-inline">2
          * T_fetch + T_ + + T_store</span> । ऐसा इसलिए है क्योंकि हमें चर y और 1 से
          दो ऑब्जेक्ट संदर्भ प्राप्त करने की आवश्यकता है; एक नई वस्तु देने के अलावा
          जो मूल्य का योग हो; और, चर y में नई ऑब्जेक्ट के लिए एक संदर्भ स्टोर करें।
        description3: हम मान लेंगे कि विकल्प को मूल कथन के समान ही चलने का समय चाहिए।
      call_method:
        title: कॉलिंग विधि समय
        description1: किसी विधि को कॉल करने के लिए आवश्यक समय एक स्थिर, <span class="code-inline">T_call</span>
          है, और एक विधि से लौटने के लिए आवश्यक समय एक स्थिर है, <span class="code-inline">T_return</span>
          ओवरहेड बनाने के लिए औचित्य पैरामीटर के साथ जुड़ा हुआ है जो किसी ऑब्जेक्ट संदर्भ
          को संग्रहीत करने के समय के समान है। एक तर्क का पारित होना वैचारिक रूप से विधि
          के औपचारिक पैरामीटर के वास्तविक पैरामीटर मान के असाइनमेंट के समान है।
        description2: Axiom के अनुसार, कथन का रनिंग टाइम <span class="code-inline">T_fetch
          + 2 * T_store + T_call + T_f(x)</span> होगा , जहाँ <span class="code-inline">T_f
          (x)</span> इनपुट x के लिए विधि f का रनिंग टाइम है। दो स्टोरों में से पहला
          पैरामीटर x से विधि f के गुजरने के कारण है; दूसरा असाइनमेंट से वेरिएबल y तक
          आता है।
      calculating:
        title: गणना समय
        description1: सरणी सदस्यता ऑपरेशन द्वारा निहित पता गणना के लिए आवश्यक समय, उदाहरण
          के लिए, <span class="code-inline">a[i]</span> एक स्थिर, <span class="code-inline">T_[]</span>
          है । इस समय में सबस्क्रिप्ट अभिव्यक्ति की गणना करने का समय शामिल
          नहीं है, और न ही इसमें एरे तत्व को एक्सेस करने का समय शामिल है।
        description2: 'यह <span class="code-inline">3 * T_fetch</span> है । तीन ऑपरेंड
          भ्रूण की आवश्यकता होती है: सरणी ऑब्जेक्ट ए के संदर्भ में सबसे पहले लाने के
          लिए ए; सूचकांक वस्तु i का संदर्भ लाने के लिए दूसरा; और, सरणी तत्व <span class="code-inline">a[i]
          </span>के संदर्भ में लाने वाला तीसरा।'
      object:
        title: वस्तु निर्माण का समय
        description1: किसी कक्षा की एक नई वस्तु बनाने के लिए आवश्यक समय एक स्थिर, <span
          class="code-inline">T_new</span> है । इस समय में ऑब्जेक्ट को इनिशियलाइज़ करने
          के लिए लिया गया कोई भी समय शामिल नहीं है। Axioms को लागू करके हम यह निर्धारित
          कर सकते हैं कि कथन का समय चल रहा है।
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> , जहाँ <span class="code-inline">T_fixnum_init</span>
          क्लास Fixnum की प्रारंभिक विधि का चलन है।
      example:
        title: उदाहरण
        description: इस खंड में हम निम्नलिखित सरल अंकगणितीय श्रृंखला के सारांश की गणना
          करने के लिए एक कार्यक्रम के रनिंग समय का विश्लेषण, Axioms लागू करते हैं।
    implementations:
      title: कार्यान्वयन
      stack:
        title: ढेर
        description: ढेर कतार का सहोदर है। यह वास्तविक जीवन के ढेर (जैसे कागज) की नकल
          करता है। यह फिल्म (पहली-इन-आखिरी-आउट) है, ताकि जब आइटम को स्टैक से पुनर्प्राप्त
          किया जाता है, तो उन्हें उस क्रम के पीछे लौटा दिया जाता है जिसमें उन्हें जोड़ा
          गया था। फिर से, रूबी एरेस एक आदर्श कंटेनर प्रदान करता है। क्यू के साथ, यह
          एक लिंक की गई सूची का उपयोग करके भी लागू किया जा सकता है।
        as_array: सरणी के रूप में ढेर
        as_linked_list: लिंक की गई सूची के रूप में ढेर
      queue:
        title: पंक्ति
        description: एक कतार एक साधारण कंटेनर-आधारित संरचना है जो वास्तविक जीवन की कतार
          की नकल करती है (जैसे कि बैंक में लाइन में प्रतीक्षा करना)। यह एफआईएफओ (पहले-में-पहले)
          है, जिसका अर्थ है कि जब आप कतार से आइटम प्राप्त करते हैं, तो वे उस क्रम में
          वापस आ जाते हैं जिसमें उन्होंने प्रवेश किया था। रूबी एरेस ऐसे तरीके प्रदान
          करता है जो कतार के कार्यान्वयन को तुच्छ रूप से आसान बनाते हैं, लेकिन उन्हें
          उचित रूप से नामित किया गया है और एक सुविधा वर्ग में निहित है यह देखने लायक
          है कि उन्हें लागू किया गया है, और क्योंकि अन्य संरचनाएं इस से विरासत में मिलेंगी।
          एक वैकल्पिक कार्यान्वयन एक लिंक की गई सूची का उपयोग करके किया जा सकता है।
        as_array: सरणी के रूप में कतार
        as_linked_list: लिंक की गई सूची के रूप में कतार
      deque:
        title: और
        description: एक Deque एक कतार है जो दोनों सिरों पर वस्तुओं को जोड़ने और हटाने
          की अनुमति देता है।
        as_array: और एक सरणी के रूप में
        as_linked_list: लिंक की गई सूची के रूप में हटाएं
      singly_linked_list:
        title: सिंगली लिंक्ड लिस्ट
        description: एकल लिंक की गई सूचियों में नोड होते हैं जिनमें एक डेटा फ़ील्ड के
          साथ-साथ एक &#39;अगला&#39; फ़ील्ड होता है, जो नोड्स की लाइन में अगले नोड को
          इंगित करता है। ऑपरेशन जो एकल लिंक की गई सूचियों पर किए जा सकते हैं उनमें सम्मिलन,
          विलोपन और ट्रैवर्सल शामिल हैं।
      doubly_linked_list:
        title: डबल लिंक की गई सूची
        description: एक डबल-लिंक्ड सूची में, प्रत्येक सूची तत्व में दो संदर्भ होते हैं
          - एक इसके उत्तराधिकारी के लिए और एक इसके पूर्ववर्ती के लिए।
      ordered_list:
        title: आदेशित सूचि
        description: एक आदेश सूची एक सूची है जिसमें वस्तुओं का क्रम महत्वपूर्ण है। हालाँकि,
          ऑर्डर की गई सूचियों में आइटम आवश्यक रूप से सॉर्ट नहीं किए गए हैं। नतीजतन,
          वस्तुओं के क्रम को बदलना संभव है और अभी भी एक मान्य आदेश सूची है।
        as_array: सरणी के रूप में सूचीबद्ध सूची
      hash_table:
        title: हैश टेबल
        description: हैश टेबल एक खोज योग्य कंटेनर है। जैसे, यह कंटेनर में ऑब्जेक्ट डालने,
          कंटेनर में ऑब्जेक्ट खोजने और कंटेनर से ऑब्जेक्ट हटाने के लिए तरीके प्रदान
          करता है।
      binary_tree:
        title: बाइनरी ट्री
        description: एक द्विआधारी वृक्ष एक पेड़ है जिसमें प्रत्येक नोड में अधिकतम दो
          बच्चे हो सकते हैं। बच्चों को बाएं और दाएं नामित किया गया है।
      binary_search_tree:
        title: बाइनरी सर्च ट्री &lt;
        description: 'कंप्यूटर विज्ञान में, बाइनरी सर्च ट्री (BST), जिसे कभी-कभी ऑर्डर
          किए गए या सॉर्ट किए गए बाइनरी ट्री कहा जाता है, एक विशेष प्रकार के कंटेनर
          हैं: डेटा संरचनाएं जो &quot;आइटम&quot; (जैसे संख्या, नाम आदि) को मेमोरी में
          स्टोर करती हैं। वे वस्तुओं के तेज़ लुकअप, जोड़ और निष्कासन की अनुमति देते
          हैं, और उनका उपयोग या तो आइटमों के डायनामिक सेटों को लागू करने के लिए किया
          जा सकता है, या लुकअप तालिकाओं को इसकी कुंजी द्वारा आइटम खोजने की अनुमति मिलती
          है (जैसे, नाम से किसी व्यक्ति का फोन नंबर खोजना)'
      b_tree:
        title: बी-वृक्ष
        description: कंप्यूटर विज्ञान में, बी-ट्री एक सेल्फ-बैलेंसिंग ट्री डेटा संरचना
          है जो डेटा को क्रमबद्ध रखता है और लघुगणक समय में खोज, अनुक्रमिक पहुंच, सम्मिलन
          और विलोपन की अनुमति देता है। बी-ट्री एक द्विआधारी खोज पेड़ का एक सामान्यीकरण
          है जिसमें एक नोड में दो से अधिक बच्चे हो सकते हैं (स्व-संतुलन बाइनरी खोज पेड़ों
          के विपरीत, बी-पेड़ उन प्रणालियों के लिए अनुकूलित है जो डेटा के बड़े ब्लॉक
          को पढ़ते और लिखते हैं। पेड़ बाहरी मेमोरी के लिए डेटा संरचना का एक अच्छा उदाहरण
          है। इसका इस्तेमाल आमतौर पर डेटाबेस और फाइल सिस्टम में किया जाता है।
      binary_heap:
        title: बाइनरी हीप
        description: एक बाइनरी हीप एक ढेर-ऑर्डर पूरा बाइनरी ट्री है जो एक सरणी का उपयोग
          करके कार्यान्वित किया जाता है। एक ढेर में सबसे छोटी कुंजी जड़ में पाई जाती
          है और चूंकि जड़ हमेशा सरणी की पहली स्थिति में पाई जाती है, इसलिए सबसे छोटी
          कुंजी को ढूंढना एक द्विआधारी ढेर में एक तुच्छ ऑपरेशन है।
      credits: 'कोड और लेख संसाधनों से लिए गए थे:'
      source: इस पृष्ठ में ब्रूनो आर प्रीस द्वारा रूबी कोड &quot;रूबी में ऑब्जेक्ट-ओरिएंटेड
        डिज़ाइन पैटर्न के साथ डेटा संरचना और एल्गोरिदम&quot; पुस्तक है। कॉपीराइट (c)
        2004 ब्रूनो आर। प्रीस द्वारा, P.Eng। सर्वाधिकार सुरक्षित।
  design_patterns:
    title: डिजाइन पैटर्न्स
    creational:
      title: रचनात्मक पैटर्न
      description: सॉफ्टवेयर इंजीनियरिंग में, क्रिएशनल डिज़ाइन पैटर्न डिज़ाइन पैटर्न
        होते हैं जो ऑब्जेक्ट निर्माण तंत्र से निपटते हैं, स्थिति के अनुकूल तरीके से
        ऑब्जेक्ट बनाने की कोशिश करते हैं। ऑब्जेक्ट निर्माण का मूल रूप डिजाइन की समस्याओं
        या डिजाइन में जोड़ा जटिलता के परिणामस्वरूप हो सकता है। रचनात्मक डिजाइन पैटर्न
        इस समस्या को किसी तरह इस वस्तु निर्माण को नियंत्रित करके हल करते हैं। रचनात्मक
        डिजाइन पैटर्न दो प्रमुख विचारों से बना है। एक ज्ञान है कि सिस्टम किस ठोस वर्गों
        का उपयोग करता है, के बारे में ज्ञान है। एक और छिपा है कि कैसे इन ठोस वर्गों
        के उदाहरणों को बनाया और संयोजित किया जाता है।
      abstract_factory:
        title: सार कारखाने पैटर्न
        description: अमूर्त कारखाना पैटर्न व्यक्तिगत कारखानों के एक समूह को एनकैप्सुलेट
          करने का एक तरीका प्रदान करता है, जिसमें उनके ठोस वर्गों को निर्दिष्ट किए बिना
          एक सामान्य विषय होता है। सामान्य उपयोग में, क्लाइंट सॉफ़्टवेयर अमूर्त कारखाने
          का एक ठोस कार्यान्वयन बनाता है और फिर फ़ैक्टरी के जेनेरिक इंटरफ़ेस का उपयोग
          करके उन ठोस वस्तुओं को बनाता है जो थीम का हिस्सा हैं। क्लाइंट को यह नहीं पता
          (या देखभाल) कि कौन सी ठोस वस्तुएं इन आंतरिक कारखानों में से प्रत्येक से प्राप्त
          होती हैं, क्योंकि यह उनके उत्पादों के केवल सामान्य इंटरफेस का उपयोग करता है।
          यह पैटर्न ऑब्जेक्ट के एक सेट के कार्यान्वयन के विवरण को उनके सामान्य उपयोग
          से अलग करता है और ऑब्जेक्ट रचना पर निर्भर करता है, क्योंकि ऑब्जेक्ट का निर्माण
          फ़ैक्टरी इंटरफ़ेस में बताए गए तरीकों से लागू होता है।
      builder:
        title: बिल्डर पैटर्न
        description: बिल्डर पैटर्न ऑब्जेक्ट निर्माण सॉफ्टवेयर डिज़ाइन पैटर्न है। अमूर्त
          कारखाने पैटर्न और कारखाने विधि पैटर्न के विपरीत जिसका उद्देश्य बहुरूपता को
          सक्षम करना है, बिल्डर पैटर्न का इरादा दूरबीन निर्माण विरोधी पैटर्न [उद्धरण
          वांछित] का समाधान खोजना है। टेलिस्कोपिंग कंस्ट्रक्टर एंटी-पैटर्न तब होता है
          जब ऑब्जेक्ट कंस्ट्रक्टर पैरामीटर संयोजन की वृद्धि से कंस्ट्रक्टरों की एक घातीय
          सूची होती है। कई कंस्ट्रक्टरों का उपयोग करने के बजाय, बिल्डर पैटर्न एक अन्य
          ऑब्जेक्ट का उपयोग करता है, एक बिल्डर, जो प्रत्येक इनिशियलाइज़ेशन पैरामीटर
          को चरण दर चरण प्राप्त करता है और फिर परिणामी निर्माण वस्तु को एक बार में वापस
          करता है।
      factory:
        title: फैक्टरी पैटर्न
        description: क्लास-आधारित प्रोग्रामिंग में, फ़ैक्टरी विधि पैटर्न एक रचनात्मक
          पैटर्न है जो ऑब्जेक्ट के सटीक वर्ग को निर्दिष्ट किए बिना ऑब्जेक्ट बनाने की
          समस्या से निपटने के लिए फ़ैक्टरी विधियों का उपयोग करता है। यह एक फैक्ट्री
          पद्धति को कॉल करके वस्तुओं को बनाने के द्वारा किया जाता है - या तो एक इंटरफ़ेस
          में निर्दिष्ट किया गया है और बच्चे की कक्षाओं द्वारा लागू किया गया है, या
          एक बेस क्लास में लागू किया गया है और व्युत्पन्न कक्षाओं द्वारा वैकल्पिक रूप
          से ओवरराइड किया गया है - बजाय एक निर्माता को कॉल करके।
      prototype:
        title: प्रोटोटाइप पैटर्न
        description: प्रोटोटाइप पैटर्न कारखाने की तर्ज पर एक रचनात्मक पैटर्न है। प्रोटोटाइप
          के साथ चाल यह है कि आप मास्टर ऑब्जेक्ट को कॉपी करके नई ऑब्जेक्ट बनाते हैं।
          उस मास्टर ऑब्जेक्ट और बाद में आपके द्वारा बनाई गई सभी वस्तुओं को परिवर्तन
          की एक प्रति के साथ जीवन में बदल जाएगा।
      singleton:
        title: सिंगलटन पैटर्न
        description: सुनिश्चित करें कि एक वर्ग के पास केवल एक ही उदाहरण है, और उसे वैश्विक
          पहुंच प्रदान करें। यह तब उपयोगी होता है जब सिस्टम में क्रियाओं के समन्वय के
          लिए ठीक एक वस्तु की आवश्यकता होती है। अवधारणा को कभी-कभी उन प्रणालियों के
          लिए सामान्यीकृत किया जाता है जो केवल एक ही वस्तु के मौजूद होने पर अधिक कुशलता
          से काम करते हैं, या जो तात्कालिकता को कुछ निश्चित वस्तुओं तक सीमित कर देते
          हैं।
      not_covered:
        title: 'कवर किए गए पैटर्न नहीं:'
        lazy: आलसी आरंभीकरण
        multiton: multiton
        pool: ऑब्जेक्ट पूल
        resource: संसाधन अधिग्रहण प्रारंभिक है
    structural:
      title: संरचनात्मक पैटर्न
      description: सॉफ्टवेयर इंजीनियरिंग में, संरचनात्मक डिजाइन पैटर्न डिजाइन पैटर्न
        होते हैं जो संस्थाओं के बीच संबंधों को महसूस करने के लिए एक सरल तरीके की पहचान
        करके डिजाइन को आसान बनाते हैं।
      adapter:
        title: एडाप्टर पैटर्न
        description: सॉफ्टवेयर इंजीनियरिंग में, एडेप्टर पैटर्न एक सॉफ्टवेयर डिजाइन पैटर्न
          है जो मौजूदा वर्ग के इंटरफ़ेस को दूसरे इंटरफ़ेस के रूप में उपयोग करने की अनुमति
          देता है। इसका उपयोग अक्सर अपने स्रोत कोड को संशोधित किए बिना दूसरों के साथ
          मौजूदा कक्षाओं के काम करने के लिए किया जाता है।
      composite:
        title: समग्र पैटर्न
        description: मिश्रित डिजाइन पैटर्न एक संरचनात्मक पैटर्न है जिसका उपयोग उन वस्तुओं
          का प्रतिनिधित्व करने के लिए किया जाता है जिनमें एक श्रेणीबद्ध वृक्ष संरचना
          होती है। यह दोनों व्यक्तिगत पत्ती नोड्स और कई नोड्स से बना शाखाओं के समान
          उपचार के लिए अनुमति देता है।
      decorator:
        title: डेकोरेटर पैटर्न
        description: ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग में, डेकोरेटर पैटर्न (जिसे रैपर
          के रूप में भी जाना जाता है, एडेप्टर पैटर्न के साथ साझा किया गया एक वैकल्पिक
          नामकरण) एक डिज़ाइन पैटर्न है जो व्यवहार को किसी अन्य वस्तु के व्यवहार को प्रभावित
          किए बिना, व्यक्तिगत रूप से या गतिशील रूप से किसी वस्तु में जोड़ने की अनुमति
          देता है एक ही वर्ग से वस्तुएं। डेकोरेटर पैटर्न अक्सर एकल जिम्मेदारी सिद्धांत
          का पालन करने के लिए उपयोगी होता है, क्योंकि यह कार्यक्षमता के अनूठे क्षेत्रों
          के साथ कक्षाओं के बीच विभाजित करने की अनुमति देता है।
      facade:
        title: मुखौटा पैटर्न
        description: जब किसी सिस्टम बहुत जटिल या समझने में मुश्किल होता है तो फेशियल
          डिज़ाइन पैटर्न का उपयोग अक्सर किया जाता है क्योंकि सिस्टम में बड़ी संख्या
          में अन्योन्याश्रित वर्ग होते हैं या इसका स्रोत कोड अनुपलब्ध होता है। यह पैटर्न
          बड़ी प्रणाली की जटिलताओं को छुपाता है और क्लाइंट को एक सरल इंटरफ़ेस प्रदान
          करता है। इसमें आमतौर पर एक एकल आवरण वर्ग शामिल होता है जिसमें ग्राहक द्वारा
          आवश्यक सदस्यों का एक समूह होता है। ये सदस्य मुखौटा क्लाइंट की ओर से सिस्टम
          का उपयोग करते हैं और कार्यान्वयन विवरण छिपाते हैं।
      flyweight:
        title: फ्लाईवेट पैटर्न
        description: कंप्यूटर प्रोग्रामिंग में, फ्लाईवेट एक सॉफ्टवेयर डिजाइन पैटर्न
          है। एक फ्लाईवेट एक ऐसी वस्तु है जो अन्य समान वस्तुओं के साथ जितना संभव हो
          उतना डेटा साझा करके मेमोरी उपयोग को कम करता है; यह बड़ी संख्या में वस्तुओं
          का उपयोग करने का एक तरीका है जब एक सरल दोहराया प्रतिनिधित्व स्मृति की अस्वीकार्य
          राशि का उपयोग करेगा। अक्सर ऑब्जेक्ट राज्य के कुछ हिस्सों को साझा किया जा सकता
          है, और बाहरी डेटा संरचनाओं में उन्हें पकड़ना और अस्थायी रूप से फ्लाईवेट ऑब्जेक्ट्स
          को पास करने के लिए उनका उपयोग किया जाना आम बात है।
      proxy:
        title: प्रॉक्सी पैटर्न
        description: 'एक प्रॉक्सी, अपने सबसे सामान्य रूप में, एक क्लास वर्किंग है जो
          एक इंटरफ़ेस के रूप में कुछ और है। प्रॉक्सी किसी भी चीज़ को इंटरफ़ेस कर सकता
          है: एक नेटवर्क कनेक्शन, मेमोरी में एक बड़ी वस्तु, एक फ़ाइल, या कुछ अन्य संसाधन
          जो डुप्लिकेट करना महंगा या असंभव है। संक्षेप में, एक प्रॉक्सी एक आवरण या एजेंट
          वस्तु है जिसे क्लाइंट द्वारा पर्दे के पीछे वास्तविक सेवारत वस्तु तक पहुंचने
          के लिए बुलाया जा रहा है। प्रॉक्सी का उपयोग केवल वास्तविक वस्तु के लिए अग्रेषित
          किया जा सकता है, या अतिरिक्त तर्क प्रदान कर सकता है। प्रॉक्सी में अतिरिक्त
          कार्यक्षमता प्रदान की जा सकती है, उदाहरण के लिए कैशिंग जब वास्तविक वस्तु पर
          संचालन संसाधन गहन होते हैं, या वास्तविक वस्तु पर संचालन से पहले पूर्व शर्त
          की जांच की जाती है। क्लाइंट के लिए, प्रॉक्सी ऑब्जेक्ट का उपयोग वास्तविक ऑब्जेक्ट
          का उपयोग करने के समान है, क्योंकि दोनों एक ही इंटरफ़ेस को लागू करते हैं।'
      protection_proxy:
        title: संरक्षण प्रॉक्सी
        description: संरक्षण प्रॉक्सी। क्या आप एमएनसी पर काम कर रहे हैं? यदि ऐसा है,
          तो हम प्रॉक्सी सर्वर से अच्छी तरह वाकिफ हो सकते हैं जो हमें कुछ ई-मेल, सोशल
          नेटवर्किंग, डेटा स्टोरेज आदि जैसी वेबसाइटों तक पहुंच को प्रतिबंधित करके इंटरनेट
          प्रदान करता है। प्रबंधन को लगता है कि, कुछ सामग्री को ब्लॉक करना बेहतर है
          केवल काम से संबंधित वेब पेज प्रदान करें। प्रॉक्सी सर्वर वह काम करता है। यह
          एक प्रकार का प्रॉक्सी डिज़ाइन पैटर्न है
      virtual_proxy:
        title: आभासी प्रॉक्सी
        description: आभासी प्रॉक्सी। एक जटिल या भारी वस्तु के स्थान पर, एक कंकाल प्रतिनिधित्व
          का उपयोग करें। जब एक अंतर्निहित छवि आकार में विशाल होती है, तो बस वर्चुअल
          प्रॉक्सी ऑब्जेक्ट का उपयोग करके इसका प्रतिनिधित्व करें और ऑन-डिमांड असली ऑब्जेक्ट
          को लोड करें। आप जानते हैं कि वास्तविक वस्तु तात्कालिकता के मामले में महंगी
          है और इसलिए वास्तविक आवश्यकता के बिना हम वास्तविक वस्तु का उपयोग नहीं करने
          जा रहे हैं। जब तक आवश्यकता नहीं होगी तब तक हम वर्चुअल प्रॉक्सी का उपयोग करेंगे।
      remote_proxy:
        title: रिमोट प्रॉक्सी
        description: रिमोट प्रॉक्सी। वितरित वस्तु संचार में, एक स्थानीय वस्तु एक दूरस्थ
          वस्तु का प्रतिनिधित्व करती है (वह जो एक अलग पते की जगह से संबंधित है)। स्थानीय
          वस्तु दूरस्थ वस्तु के लिए एक प्रॉक्सी है, और स्थानीय वस्तु पर विधि आह्वान
          के परिणामस्वरूप दूरस्थ वस्तु पर दूरस्थ विधि के आह्वान का परिणाम होता है। एटीएम
          कार्यान्वयन के बारे में सोचें, यह दूरस्थ सर्वर में मौजूद बैंक जानकारी के लिए
          प्रॉक्सी ऑब्जेक्ट रखेगा।
      not_covered:
        title: 'कवर किए गए पैटर्न नहीं:'
        callback: एनोटेट कॉलबैक
        bridge: पुल
        data_bus: डेटा बस
        role: भूमिका वस्तु
    behavioral:
      title: स्वभावजन्य तरीका
      description: सॉफ्टवेयर इंजीनियरिंग में, व्यवहार डिजाइन पैटर्न डिजाइन पैटर्न होते
        हैं जो वस्तुओं के बीच आम संचार पैटर्न की पहचान करते हैं और इन पैटर्न का एहसास
        करते हैं। ऐसा करने से ये पैटर्न इस संचार को पूरा करने में लचीलापन बढ़ाते हैं।
      chain_of_responsobility:
        title: जिम्मेदारी पैटर्न की श्रृंखला
        description: ऑब्जेक्ट-ओरिएंटेड डिज़ाइन में, चेन-ऑफ़-जिम्मेदारी पैटर्न एक डिज़ाइन
          पैटर्न है जिसमें कमांड ऑब्जेक्ट्स का स्रोत और प्रोसेसिंग ऑब्जेक्ट्स की एक
          श्रृंखला होती है। प्रत्येक प्रोसेसिंग ऑब्जेक्ट में लॉजिक होता है जो कमांड
          ऑब्जेक्ट्स के प्रकार को परिभाषित करता है जिसे वह संभाल सकता है; बाकी श्रृंखला
          में अगली प्रसंस्करण वस्तु के लिए पारित कर रहे हैं। इस श्रृंखला के अंत में
          नई प्रसंस्करण वस्तुओं को जोड़ने के लिए एक तंत्र भी मौजूद है।
      command:
        title: कमांड पैटर्न
        description: कमांड पैटर्न एक व्यवहार डिजाइन पैटर्न है जिसका उपयोग भविष्य के
          समय में कॉल करने के लिए आवश्यक सूचनाओं को संग्रहीत करने के लिए किया जाता है।
          आदेश केवल एक वस्तु में लिपटे कार्यों का एक समूह है। माणिक्य के साथ, हम एक
          अलग वस्तु बनाने की आवश्यकता के बिना एक ही काम करने के लिए Procs का उपयोग कर
          सकते हैं। यह एक अच्छा विकल्प है जब कार्रवाई सरल है और राज्य की जानकारी को
          सहेजने की आवश्यकता नहीं है, अन्यथा, एक कमांड क्लास बेहतर विकल्प है।
      interpreter:
        title: दुभाषिया पैटर्न
        description: कंप्यूटर प्रोग्रामिंग में, दुभाषिया पैटर्न एक डिज़ाइन पैटर्न है
          जो निर्दिष्ट करता है कि किसी भाषा में वाक्यों का मूल्यांकन कैसे किया जाए।
          मूल विचार एक विशिष्ट कंप्यूटर भाषा में प्रत्येक प्रतीक (टर्मिनल या नॉनटर्मिनल)
          के लिए एक वर्ग है। भाषा में एक वाक्य का वाक्यविन्यास वृक्ष समग्र पैटर्न का
          एक उदाहरण है और इसका उपयोग ग्राहक के लिए वाक्य का मूल्यांकन (व्याख्या) करने
          के लिए किया जाता है।
      iterator:
        title: इटरेटर पैटर्न
        description: इटरेटर डिजाइन पैटर्न कंटेनर के भीतर तत्वों को अनुक्रमिक पहुंच प्रदान
          करता है बिना यह उजागर किए कि कंटेनर वास्तव में तत्वों का प्रतिनिधित्व कैसे
          करता है। पुनरावृत्त को एक चल सूचक के रूप में माना जा सकता है जो एक कंटेनर
          के भीतर समझाया तत्वों तक पहुंच की अनुमति देता है।
      external_iterator:
        title: बाहरी इटरेटर पैटर्न
        description: 'बाहरी पुनरावृत्ति: पुनरावृति तर्क एक अलग वर्ग में निहित है। जब
          तक वे अनुक्रमण की अनुमति देते हैं तब तक कई ऑब्जेक्ट प्रकारों को संभालने के
          लिए पुनरावृति वर्ग को सामान्यीकृत किया जा सकता है। वास्तविक पुनरावृत्ति करने
          के लिए अतिरिक्त वर्ग की आवश्यकता होती है, लेकिन वे अधिक लचीलेपन की अनुमति
          देते हैं क्योंकि आप पुनरावृत्ति को नियंत्रित कर सकते हैं, कौन से तत्व अधिक
          क्रम में और किस क्रम में पुनरावृत्त होते हैं।'
      internal_iterator:
        title: आंतरिक पुनरावृत्ति पैटर्न
        description: 'आंतरिक पुनरावृत्ति: सभी पुनरावृत्ति तर्क कुल वस्तु के अंदर होता
          है। अपने तर्क को एग्रीगेट में पास करने के लिए एक कोड ब्लॉक का उपयोग करें जो
          तब प्रत्येक तत्व के लिए ब्लॉक को कॉल करता है।'
      mediator:
        title: मध्यस्थ पैटर्न
        description: आमतौर पर एक कार्यक्रम बड़ी संख्या में वर्गों से बना होता है। तो
          इन वर्गों के बीच तर्क और संगणना वितरित की जाती है। हालाँकि, जैसे कि एक कार्यक्रम
          में अधिक कक्षाएं विकसित की जाती हैं, विशेष रूप से रखरखाव और / या रिफैक्टिंग
          के दौरान, इन वर्गों के बीच संचार की समस्या अधिक जटिल हो सकती है। यह कार्यक्रम
          को पढ़ने और बनाए रखने के लिए कठिन बनाता है। इसके अलावा, कार्यक्रम को बदलना
          मुश्किल हो सकता है, क्योंकि कोई भी परिवर्तन कई अन्य वर्गों में कोड को प्रभावित
          कर सकता है। मध्यस्थ पैटर्न के साथ, वस्तुओं के बीच संचार एक मध्यस्थ वस्तु के
          साथ समझाया जाता है। ऑब्जेक्ट अब एक दूसरे के साथ सीधे संवाद नहीं करते हैं,
          बल्कि मध्यस्थ के माध्यम से संवाद करते हैं। यह वस्तुओं को संप्रेषित करने के
          बीच निर्भरता को कम करता है, जिससे युग्मन कम होता है।
      momento:
        title: पल पल
        description: 'मोमेंटो पैटर्न को तीन ऑब्जेक्ट्स के साथ लागू किया जाता है: प्रवर्तक,
          एक केयरटेकर और एक मोमेंटो। प्रवर्तक कुछ ऐसी वस्तु है जिसकी आंतरिक स्थिति होती
          है। कार्यवाहक प्रवर्तक के लिए कुछ करने जा रहा है, लेकिन परिवर्तन को पूर्ववत
          करने में सक्षम होना चाहता है। कार्यवाहक पहले प्रवर्तक से एक संवेग वस्तु के
          लिए पूछता है। फिर यह जो भी ऑपरेशन (या संचालन का अनुक्रम) करता है वह करने जा
          रहा था। ऑपरेशन से पहले राज्य में वापस आने के लिए, यह प्रवर्तक को गति वस्तु
          लौटाता है। मोमेंटो ऑब्जेक्ट अपने आप में एक अपारदर्शी वस्तु है (एक जिसे केयरटेकर
          नहीं कर सकता है, या नहीं बदलना चाहिए)। इस पैटर्न का उपयोग करते समय, देखभाल
          की जानी चाहिए यदि प्रवर्तक अन्य वस्तुओं या संसाधनों को बदल सकता है - एक ही
          वस्तु पर गति पैटर्न संचालित होता है।'
      observer:
        title: ऑब्जर्वर पैटर्न
        description: ऑब्जर्वर पैटर्न एक सॉफ्टवेयर डिज़ाइन पैटर्न है जिसमें एक ऑब्जेक्ट,
          जिसे विषय कहा जाता है, अपने आश्रितों की एक सूची रखता है, जिसे पर्यवेक्षक कहा
          जाता है, और उन्हें किसी भी राज्य परिवर्तनों के लिए स्वचालित रूप से सूचित करता
          है, आमतौर पर उनके तरीकों में से एक को कॉल करके। यह मुख्य रूप से वितरित इवेंट
          हैंडलिंग सिस्टम को लागू करने के लिए उपयोग किया जाता है। ऑब्जर्वर पैटर्न भी
          परिचित मॉडल-व्यू-कंट्रोलर (एमवीसी) वास्तुशिल्प पैटर्न का एक महत्वपूर्ण हिस्सा
          है। पर्यवेक्षक पैटर्न कई प्रोग्रामिंग पुस्तकालयों और प्रणालियों में लागू किया
          जाता है, जिसमें लगभग सभी जीयूआई टूलकिट शामिल हैं।
      state:
        title: राज्य का पैटर्न
        description: राज्य पैटर्न एक व्यवहार सॉफ्टवेयर डिजाइन पैटर्न है जो ऑब्जेक्ट-ओरिएंटेड
          तरीके से राज्य मशीन को लागू करता है। राज्य पैटर्न के साथ, प्रत्येक व्यक्ति
          राज्य को राज्य पैटर्न इंटरफ़ेस के व्युत्पन्न वर्ग के रूप में लागू करने और
          पैटर्न के सुपरक्लास द्वारा परिभाषित तरीकों को लागू करके राज्य संक्रमण को लागू
          करने के द्वारा एक राज्य मशीन को लागू किया जाता है।
      strategy:
        title: रणनीति पैटर्न
        description: रणनीति एल्गोरिदम को उन ग्राहकों से स्वतंत्र रूप से भिन्न होने देती
          है जो इसका उपयोग करते हैं। रणनीति गामा एट अल द्वारा प्रभावशाली पुस्तक डिजाइन
          पैटर्न में शामिल पैटर्न में से एक है। सॉफ्टवेयर डिजाइन का वर्णन करने के लिए
          पैटर्न का उपयोग करने की अवधारणा को लोकप्रिय बनाया। उदाहरण के लिए, एक वर्ग
          जो आने वाले डेटा पर सत्यापन करता है, डेटा के प्रकार, डेटा के स्रोत, उपयोगकर्ता
          की पसंद या अन्य भेदभाव कारकों के आधार पर एक सत्यापन एल्गोरिथ्म का चयन करने
          के लिए एक रणनीति पैटर्न का उपयोग कर सकता है। इन कारकों को रन-टाइम तक प्रत्येक
          मामले के लिए नहीं जाना जाता है, और प्रदर्शन करने के लिए मौलिक रूप से भिन्न
          सत्यापन की आवश्यकता हो सकती है। सत्यापन की वस्तु, जो अलग-अलग वैध वस्तु से
          अलग होती है, का उपयोग सिस्टम के विभिन्न क्षेत्रों में (या यहाँ तक कि अलग-अलग
          प्रणालियों) कोड सत्यापन के बिना अन्य मान्य वस्तुओं द्वारा किया जा सकता है।
      template:
        title: खाका विधि पैटर्न
        description: ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग में, पहले एक वर्ग बनाया जाता है
          जो एक एल्गोरिथ्म डिजाइन के मूल चरण प्रदान करता है। इन चरणों को अमूर्त तरीकों
          का उपयोग करके लागू किया जाता है। बाद में, उपवर्ग वास्तविक कार्यों को लागू
          करने के लिए अमूर्त तरीकों को बदलते हैं। इस प्रकार सामान्य एल्गोरिथ्म एक स्थान
          पर सहेजा जाता है, लेकिन उपवर्गों द्वारा ठोस कदम बदले जा सकते हैं।
      visitor:
        title: आगंतुक पैटर्न
        description: ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग और सॉफ्टवेयर इंजीनियरिंग में, विज़िटर
          डिज़ाइन पैटर्न एक एल्गोरिथ्म को ऑब्जेक्ट संरचना से अलग करने का एक तरीका है,
          जिस पर वह संचालित होता है। इस पृथक्करण का एक व्यावहारिक परिणाम उन संरचनाओं
          को संशोधित किए बिना मौजूदा ऑब्जेक्ट संरचनाओं में नए संचालन को जोड़ने की क्षमता
          है। यह खुले / बंद सिद्धांत का पालन करने का एक तरीका है। संक्षेप में, आगंतुक
          वर्गों के परिवार में खुद को संशोधित किए बिना नए आभासी कार्यों को जोड़ने की
          अनुमति देता है; इसके बजाय, एक आगंतुक वर्ग बनाता है जो आभासी फ़ंक्शन के सभी
          उपयुक्त विशेषज्ञता को लागू करता है। आगंतुक इनपुट के रूप में उदाहरण संदर्भ
          लेता है, और दोहरे प्रेषण के माध्यम से लक्ष्य को लागू करता है।
      not_covered:
        title: 'कवर किए गए पैटर्न नहीं:'
        hierarchical: पदानुक्रमित आगंतुक
      credits: 'कोड और लेख संसाधनों से लिए गए थे:'
  functional_programming:
    title: कार्यात्मक प्रोग्रामिंग
    description: 'एक कार्यात्मक शैली में भाषा का उपयोग करने का मतलब है कि आपके पास नीचे
      सूचीबद्ध कुछ प्रमुख विशेषताओं तक पहुंच है:'
    axioms:
      immutable: 'अपरिवर्तनीय मूल्य: &quot;चर&quot; सेट होने के बाद, इसे बदला नहीं जा
        सकता। रूबी में, इसका मतलब है कि आपको प्रभावी रूप से स्थिरांक जैसे चर का इलाज
        करना होगा।'
      side_effects: 'कोई साइड-इफेक्ट नहीं: जब किसी दिए गए मान को पारित किया जाता है,
        तो एक फ़ंक्शन को हमेशा उसी परिणाम को वापस करना चाहिए। यह अपरिवर्तनीय मूल्यों
        के साथ हाथ में जाता है; एक फ़ंक्शन कभी भी एक मूल्य नहीं ले सकता है और इसे बदल
        सकता है, क्योंकि यह एक साइड-इफेक्ट का कारण होगा जो परिणाम वापस करने के लिए स्पर्शरेखा
        है।'
      pure_functions: 'उच्च-क्रम के कार्य: ये ऐसे कार्य हैं जो कार्यों को तर्क के रूप
        में अनुमति देते हैं, या रिटर्न मान के रूप में कार्यों का उपयोग करते हैं। यह,
        यकीनन, किसी भी कार्यात्मक भाषा की सबसे महत्वपूर्ण विशेषताओं में से एक है।'
      applying: 'करीकरण: उच्च-क्रम के कार्यों द्वारा सक्षम, करीकरण एक फ़ंक्शन को रूपांतरित
        कर रहा है जो एक तर्क में कई तर्कों को लेता है जो एक तर्क लेता है। यह आंशिक रूप
        से फ़ंक्शन अनुप्रयोग के साथ हाथ में जाता है, जो एक बहु-तर्क फ़ंक्शन को एक फ़ंक्शन
        में बदल रहा है जो कम तर्क लेता है, फिर उसने मूल रूप से किया।'
      recursion: 'पुनरावृत्ति: स्वयं के भीतर से एक फ़ंक्शन को कॉल करके लूपिंग। जब आपके
        पास उत्परिवर्तित डेटा तक पहुंच नहीं होती है, तो पुनरावर्तन का उपयोग डेटा निर्माण
        और श्रृंखला निर्माण के लिए किया जाता है। ऐसा इसलिए है क्योंकि लूपिंग एक कार्यात्मक
        अवधारणा नहीं है, क्योंकि इसमें एक निश्चित समय में लूप की स्थिति को संग्रहीत
        करने के लिए चर को पास करने की आवश्यकता होती है।'
      lazy: 'आलसी-मूल्यांकन, या देरी से मूल्यांकन: मूल्यों के प्रसंस्करण में देरी जब
        तक यह वास्तव में जरूरत है। यदि, एक उदाहरण के रूप में, आपके पास कुछ कोड हैं जो
        आलसी-मूल्यांकन सक्षम के साथ फाइबोनैचि संख्याओं की सूची उत्पन्न करते हैं, तो
        यह वास्तव में संसाधित नहीं होगा और गणना की जाएगी, जब तक कि परिणाम में एक मान
        किसी अन्य फ़ंक्शन, जैसे पुट्स द्वारा आवश्यक न हो।'
    pure_functions:
      title: शुद्ध कार्य
      description: आप देख सकते हैं कि यह फ़ंक्शन केवल अपने तर्कों का उपयोग करके परिणाम
        की गणना करता है।
    closures:
      title: बंद
      description: लैम्ब्डा भी एक बंद लागू करता है और इसलिए वस्तुओं के बीच अपने संदर्भ
        को रखने में सक्षम हैं।
    applying:
      title: आंशिक आवेदन करना और ले जाना
      description: आइए पहले समझते हैं कि ये दो अलग-अलग प्रकार के कार्य क्या हैं। आंशिक
        फ़ंक्शन एप्लिकेशन कुछ फ़ंक्शन को कुछ तर्कों के साथ बुला रहा है, ताकि एक फ़ंक्शन
        वापस मिल सके जो कि कई कम तर्क लेगा। करी एक फ़ंक्शन ले रहा है जो n तर्क लेता
        है, और इसे n कार्यों में विभाजित करता है जो एक तर्क लेता है।
      proc: आपको यह स्पष्ट रूप से बताने के लिए कि इन दोनों चीजों में से प्रत्येक एक
        फ़ंक्शन क्या करेगा, आइए एक उदाहरण लेते हैं प्रोक।
      partial: इस फ़ंक्शन का आंशिक अनुप्रयोग वापस आ जाएगा, यदि हम पहले दो तर्कों में
        पारित हो गए, तो निम्न नेस्टेड प्रोक्स।
      curry: <span class="code-inline">.curry</span> ने एक लौकिक
        खरीद लौटा दी। यदि वैकल्पिक तर्क तर्क दिया जाता है, तो यह तर्कों की संख्या
        निर्धारित करता है। एक क्यूरेड प्रॉपर्टी को कुछ तर्क मिलते हैं। यदि पर्याप्त
        संख्या में तर्कों की आपूर्ति की जाती है, तो यह आपूर्ति की गई दलीलों को मूल खरीद
        तक पहुंचाता है और परिणाम देता है। अन्यथा, एक और करीबी खरीद लौटाता है जो बाकी
        तर्कों को लेता है।
  gotchas:
    title: Gotchas
    description1: रेल शुरुआती पर अधिकांश रूबी रूपरेखा से उत्साहित हो जाते हैं और भाषा
      के किसी भी ज्ञान के बिना अनुप्रयोगों को क्राफ्ट करना शुरू कर देते हैं। और यही
      RoR का जादू है।
    description2: कुछ बिंदु पर चीजें गंभीर होने लगती हैं। कुछ को रूबी पर रूबी के गंदे
      रहस्यों का पता लगाने में समय और प्रयास लगता है, जबकि अन्य लोग चमकते हैं और भाषा
      के लगभग शून्य ज्ञान के साथ वरिष्ठ डेवलपर्स बन जाते हैं।
    description3: वैसे भी, जल्दी या बाद में, शुरुआती या अनुभवी प्रोग्रामर, हम सभी तथाकथित
      रूबी गोचैक्स में भागते हैं - उन छोटी भाषा सूक्ष्मताएं जो कट्टर डिबगिंग के घंटों
      के लिए हमारी साइट से छिपती हैं।
    description4: यहां लोकप्रिय रूबी गोचरों और जिज्ञासाओं की एक सूची है, जिनके बारे
      में डेवलपर्स को जानकारी होनी चाहिए। प्रत्येक मामले के लिए, भ्रामक और / या त्रुटि-प्रवण
      कोड का एक उदाहरण है।
    description5: वे अच्छी प्रथाओं के साथ आते हैं, जो आपको सरल (लेकिन खोजने में मुश्किल)
      गलतियाँ करने और आपके (और आपके कोड अनुचर के जीवन) को सरल बनाने से रोकेंगे।
    surprising:
      title: रूबी आश्चर्यचकित हो सकती है
      description: हालांकि &quot;प्रोग्रामर खुशी को अधिकतम करने के लिए इंजीनियर&quot;,
        &quot;कम से कम आश्चर्य के सिद्धांत&quot; के साथ, रूबी अभी भी गोचर है। यह प्रस्तुति
        नौसिखिया तुच्छ गॉच से, अधिक उन्नत और भ्रामक गोच से आगे बढ़ेगी।
    quotes:
      title: इस पर मुझे उद्धृत न करें, लेकिन ...
      description: स्ट्रिंग इंटरपोलेशन (विशेष वर्णों सहित <span class="code-inline">\
        n</span>) <span class="code-inline">&#39;सिंगल&#39;</span> उद्धरणों के साथ
        विफल रहता है - इसके लिए <span class="code-inline">&quot;डबल&quot;</span> उद्धरणों
        की आवश्यकता होती है। जैसे स्ट्रिंग इंटरपोलेशन वाली अधिकांश भाषाओं में। इससे
        बचने के लिए जब भी व्यावहारिक हो युगल का उपयोग करें।
    twue:
      title: यह ट्विस्ट है! यह ट्विस्ट है!
      description: 'केवल दो चीजें झूठी हैं: <span class="code-inline">false</span> और
        <span class="code-inline">nil</span> । बाकी सब सच है, यहां तक कि <span class="code-inline">0</span>
        (सी में झूठ), <span class="code-inline">&quot;&quot;</span> (जेएस में झूठ),
        <span class="code-inline">[]</span> , आदि सी, जेएस, आदि से लोगों को ऊपर उठाते
        हैं, जहां इनमें से कुछ झूठे हैं।'
    symbols_and_strings:
      title: प्रतीकात्मक रूप से उसे पुतले में लटकाएं या उसे स्ट्रिंग करें।
      description: '<span class="code-inline">Symbol != String</span> । प्रिंट होने
        पर भी वही। याद रखें कि किसका उपयोग करना है। आदर्श रूप से, या तो ले लो, और एक
        विधि की अपेक्षा का उपयोग करें: &quot;जो आप स्वीकार करते हैं उसमें उदार रहें
        और जो आप भेजते हैं उसमें रूढ़िवादी हैं।&quot; पोस्टेल का नियम।'
    string_or_nothing:
      title: स्ट्रिंग ... या कुछ भी नहीं!
    constants:
      title: लगातार नहीं
      description: प्रारंभिक अपरकेस का मतलब है रूबी में स्थिर। निरंतर बदलने का प्रयास
        करें। Ooooh आप एक चेतावनी मिलता है! BFD। यहां तक कि फ्रीजिंग भी फिक्सनम्स के
        लिए काम नहीं करता है। यह सरणियों (प्रकार) और अधिकांश अन्य वस्तुओं के लिए काम
        करता है ... उन्होंने कहा कि पूर्वाभास।
    equals:
      title: कुछ दूसरों की तुलना में अधिक समान हैं
      description: <span class="code-inline">==</span> सामान्य समान मूल्य है, <span
        class="code-inline">.eql?</span> मूल्य और वर्ग (1 Fixnum है, 1.0 फ्लोट है),
        <span class="code-inline">.equal?</span> एक ही वस्तु है। यह वास्तव में बहुत
        अधिक बाल है।
    operations:
      title: "&gt; ===! = ==!"
      description: <span class="code-inline">===</span> &quot;केस समानता&quot; है, जैसा
        कि स्टेटमेंट स्टेटमेंट में होता है। एक बेहतर नाम <span class="code-inline">.describes</span>
        हो सकता है ?, या अधिभार ।
        । फिर, यह वास्तव में बहुत बालों वाला है; क्लास ऑब्जेक्ट पर डॉक्स देखें। उन लोगों
        को भाषाओं से >जोड़ा जाता है जहां <span class="code-inline">===</span>
        या तो वस्तु पहचान या समान मूल्य और वर्ग है।
    priority:
      title: and != &&, or != ||
      description: '<span class="code-inline">&&</span> में <span class="code-inline">=</span>
        से अधिक पूर्वता है, इसलिए <span class="code-inline">x = true && false</span>  का
        अर्थ <span class="code-inline">x = (true && false)</span> है और इसकी पूर्ववर्ती
        स्थिति कम है, इसलिए <span class="code-inline">x = true and false</span> अर्थ <span
        class="code-inline">(x = true) and false</span> । रूबी स्टाइल गाइड: यूज़ <span
        class="code-inline">&&, ||</span> बूलियन अभिव्यक्ति के लिए, <span class="code-inline">and, or</span>
        नियंत्रण प्रवाह के लिए।'
    sensitive:
      title: इतना संवेदनशील मत बनो!
      description: व्हाट्सएप असंवेदनशील? हर बार नहीं! पार्सर सोचते हैं कि यह एक अभिव्यक्ति
        है, जैसा कि एक arg, लेकिन <span class="code-inline">(1, 2)</span> एक वैध रूबी
        अभिव्यक्ति नहीं है! (1 तर्क के साथ सभी काम ठीक है)।
      usage: 'कई आर्ग के साथ: <br/> - कोई बात नहीं, कोई बात नहीं। <br/> - माता-पिता
        w / o स्थान, ठीक है। <br/> - परेंस और स्पेस, NO!'
      methods: '<span class="code-inline">method / num</span> एक एकीकृत रेगेक्स या
        स्ट्रिंग है! रूबी को लगता है कि आप विधि का तर्क दे रहे हैं। सामान्य सिद्धांत:
        BALANCED व्हाट्सएप का उपयोग करें; दोनों तरफ से या न ही।'
      arguments: '<span class="code-inline">one -2</span> बनाता है रूबी को लगता है कि
        आप एक विधि <span class="code-inline">-2</span> को एक तर्क दे रहे हैं। <span
        class="code-inline">+2</span> या <span class="code-inline">* 2</span> के लिए
        भी। दोबारा: BALANCED व्हाट्सएप का उपयोग करें, दोनों तरफ या न ही।'
      stubby: "&quot;स्टैबी&quot; लैम्ब्डास (1.9+) पेरेंटेस को बिना माता-पिता के ठीक
        होने से पहले वैकल्पिक स्थान देता है। माता-पिता के बाद अंतरिक्ष, ठीक है। फिर,
        माता-पिता से पहले अंतरिक्ष, नहीं! अद्यतन: 2.0 में तय!"
    onto:
      title: Yer @ पर!
      description: 'नग्न मान एक अस्थायी स्थानीय चर बन जाता है! समाधान: <span class="code-inline">@!</span>
        याद रखें (या &quot;आत्म।&quot;। या <span
        class="code-inline">attr_writer, attr_accessor</span>) उपयोग करते
        (भी जो की जरूरत है &quot;आत्म।&quot;) जावा / सी ++, नहीं
        इतना अजगर से लोगों हो जाता है। &quot;आप उस चर का उपयोग करते रहते हैं। मुझे नहीं
        लगता कि इसका मतलब यह है कि आप क्या सोचते हैं।&quot; इनिगो मोंटोया नहीं।'
    variables:
      title: बाहर देखो, यह @@ है!
      description: देखो खाली भरने क्या? हमने इसे जाँचने से पहले पेरेंट के <span class="code-inline">@@
        मान</span> को नहीं बदला, न ही चाइल्ड को बिल्कुल! या हमने किया? <span class="code-inline">@@
        चर</span> उपवर्गों के साथ साझा किए जाते हैं - न केवल वे मौजूद हैं, बल्कि स्वयं
        चर भी हैं! बच्चे के <span class="code-inline">@@ मूल्य को</span> घोषित करने
        से माता-पिता में बदलाव आया है, और माता-पिता के बदले हुए बच्चे के लिए।
    initialize:
      title: Init (ialize) के साथ या इसके बिना
      description: माता-पिता की इनिशियलाइज़ स्वचालित रूप से तभी चलती है, जब बच्चे के
        पास कोई न हो। और, माता-पिता को चलाने के लिए बुलाया जाना चाहिए।
    superman:
      title: सुपरमैन बनाम द अदृश्य मैन
      description: 'कोई आर्ग की सूची के साथ <span class="code-inline">super</span> भेजा
        जाने वाला फोन करने वाले स्पष्ट आर्ग के साथ <span class="code-inline">super</span>
        मिला उन आर्ग भेजता कोई आर्ग भेजने के लिए, का उपयोग खाली कोष्ठक: <span class="code-inline">super()।</span>'
    regexp:
      title: यह कब समाप्त होगा? (या शुरू?)
      description: 'मानक regexps में: <span class="code-inlne">^</span> प्रारंभ है और
        <span class="code-inline">$</span> पूरे स्ट्रिंग का अंत है। रूबी के रेगीक्स
        मल्टीलाइन में डिफ़ॉल्ट हैं, इसलिए: <span class="code-inline">^</span> शुरू है
        और <span class="code-inline">$</span> किसी भी लाइन का अंत है! <span class="code-inline">\
        A</span> प्रारंभ है और <span class="code-inline">\ Z</span> पूरे स्ट्रिंग का
        अंत है। (या किसी भी newline को शामिल करने के लिए z / ... जो एक और getcha है!)'
    any:
      title: हो रही है।
      description: '<span class="code-inline">any?</span> &quot;किसी भी तत्व का
        मतलब नहीं है?&quot;! ब्लॉक के साथ: &quot;क्या कोई ब्लॉक को सच बनाता है?&quot;।
        बिना: &quot;कोई भी सच्चाई है?&quot; निहित अवरोध है: <span class="code-inline">{ |element| element }</span>।'
    undef:
      title: "(अन) डेप लेपर्ड"
      description: पुनरावृत्तियों को पारित ब्लॉकों में घोषित चर (जैसे, समय या प्रत्येक)
        प्रत्येक पुनरावृत्ति के शीर्ष पर अपरिभाषित हैं! Iterators बार-बार ब्लॉक को कॉल
        करते हैं, इसलिए प्रत्येक कॉल के बाद vars फिर से दायरे से बाहर हो जाते हैं। अंतर्निहित
        लूपिंग निर्माण (जैसे, जबकि या के लिए) ठीक हैं। (या ब्लॉक से पहले वेरिएशन घोषित
        करें।)
    freeze:
      title: फ्रीज (अर) रे
      description: एक सरणी (या एक हैश) को फ्रीज़ करने से यह जमा होता है, न कि इसमें
        शामिल वस्तुओं से। स्ट्रिंग्स को जगह में संशोधित किया जा सकता है। इस तरह, आप
        किसी दिए गए स्लॉट को फ्रोजन ऐरे ऑफ़ स्ट्रिंग्स में संशोधित कर सकते हैं।
    one_is_one:
      title: 1 है 1… और कभी ऐसा होगा!
      description: 'फ़िक्नम को नए मूल्य में बदलने का अर्थ है एक नई वस्तु। वे जगह में
        संशोधित नहीं किया जा सकता है! तो, Fixnums के एक जमे हुए ऐरे को संशोधित नहीं
        कर सकता। (Fixnums और Integers के पास कोशिश करने के लिए कोई धमाके करने के तरीके
        नहीं हैं)। BTW: एक Fixnum का <span class="code-inline">object_id</span> <span
        class="code-inline">value * 2 + 1</span> है'
    bang:
      title: "(to? ||?!) =="
      description: 'बैंग खतरनाक के रूप में विधि को चिह्नित करता है। क्यूं कर? अक्सर,
        रिसीवर को संशोधित कर सकता है, बनाम गैर-मॉडिंग गैर-बैंग संस्करण। नॉन-बैंग संस्करण
        के रूप में उन्हें पुन: प्रस्तुत करने पर भरोसा मत करो! अगर कोई बदलाव की ज़रूरत
        नहीं है, तो कई रिटर्न एनआईएल!'
    array:
      title: नई गोत्रों की एक सरणी
      description: ऑब्जेक्ट के रूप में दिया गया डिफ़ॉल्ट मान प्रत्येक स्लॉट के लिए समान
        ऑब्जेक्ट है! सभी के लिए एक म्यूट डिफ़ॉल्ट डिफ़ॉल्ट। ब्लॉक के रूप में दिया गया
        प्रारंभिक मूल्य प्रत्येक स्लॉट के लिए अलग से मूल्यांकन किया जाता है। प्रत्येक
        के लिए नए संस्करण बनाने के लिए इसका उपयोग करें।
    hash:
      title: इसका हश्र करना
      description: 'अधिकतर अर्रे के रूप में एक ही समस्या (और समाधान)। अधिक जानकारी:
        खाली स्लॉट के लिए किसी भी उपयोग पर एक नई वस्तु बनाता है! नई वस्तुओं की अत्यधिक
        संख्या पैदा कर सकता है; खंडहर &quot;वास्तविक&quot; सामग्री या गिनती (नील-जाँच,
        आकार, आदि) की जाँच करना।'
    rescue:
      title: रेस्क्यू मी, थ्रो ए लाइन, आई विल ट्राई टू कैच इट!
      description: रूबी में, थ्रो और कैच अपवादों के लिए नहीं हैं! वे गहरे प्रवाह से
        बाहर निकलने के लिए उन्नत प्रवाह नियंत्रण हैं। रूबी अपवादों को बढ़ाने और बचाव
        के लिए उपयोग करती है।
    to_str:
      title: to_s VS_str
      description: '<span class="code-inline">to_s</span> हर वस्तु पर परिभाषित किया
        गया है और हमेशा कुछ वापस करेगा। <span class="code-inline">to_str</span> केवल
        उन वस्तुओं पर परिभाषित किया गया है जो स्ट्रिंग-जैसे हैं। उदाहरण के लिए, <span
        class="code-inline">Symbol</span> में <span class="code-inline">to_str</span> है
        लेकिन <span class="code-inline">Array</span> नहीं है। इस प्रकार, आप <span class="code-inline">obj.respond_to?(:to_str)</span>
         का उपयोग <span class="code-inline">obj.is_a?(String)</span> तरह कुछ के बजाय कर सकते हैं, यदि आप
        बतख टाइपिंग का लाभ लेना चाहते हैं, तो इस बात की <span class="code-inline">परवाह</span>
        किए बिना कि जिस वर्ग के साथ आप काम कर रहे हैं, वह <span class="code-inline">String</span> उपवर्ग है या नहीं।'
    missing:
      title: Method_missing और response_to_missing को समन्वित करने की आवश्यकता है?
      description: 'जब मेथड <span class="code-inline">method_missing</span> , तो <span
        class="code-inline">respond_to_missing?</span> को ओवरराइड करना याद रखें भी। जब आप किसी मेथड कॉल पर किसी वस्तु को वापस करने
        के लिए method_missing का उपयोग करते हैं, तो हमेशा सुनिश्चित करें कि आप response_to_missing
        को फिर से परिभाषित करें। यदि आप ऐसा नहीं करते हैं, तो पहली नज़र में कुछ भी नहीं
        टूटेगा, लेकिन आप अंततः परेशानी में पड़ जाएंगे। इस वर्ग पर विचार करें:'
      respond_to: 'बहुत सारे कोड (रत्न या आपके अपने) response_to पर निर्भर करते हैं?
        (एक अच्छे कारण के लिए)। क्या आपको response_to_missing पैच करने की आवश्यकता है?
        भी:'
    exception:
      title: एक StandardError से बचाव, एक अपवाद नहीं
      description: 'बचाव से बचाव न करें, बचाव से पहले मानकरक्षा करें। स्पष्ट रूप से
        बचाव से पहले अपवाद, यहां तक कि सामान्य रूप से पुनर्प्राप्त करने योग्य त्रुटियों
        जैसे कि सिंटैक्सएयर, लोडएयर, और इंटरप्ट को भी नहीं बचाएगा। यदि आप अपवाद प्रकार
        के क्वालीफायर को छोड़ देते हैं, तो रूबी केवल StandardError को पकड़ेगी, जो कि
        शायद आप चाहते हैं:'
    private:
      title: निजी डेटा वास्तव में नहीं है, और सभी w / वर्ग विधियों में नहीं है
      description: रूबी में कक्षा के तरीकों को निजी बनाने का एक तरीका है, आप बस कुछ
        हुप्स के माध्यम से कूदना चाहते हैं। इर, मेरा मतलब है कि उपयोग करें <span class="code-inline">class << self</span> वाक्यविन्यास।
        यह विषमता क्लास के तरीकों को प्रभावी ढंग से बनाने के लिए एक उदाहरण सिंगलटन को
        कक्षा में धकेलती है।
    braces:
      title: ब्रेसेस बनाम डू-एंड
      description: सामान्य सम्मेलन का उपयोग <span class="code-inline">do .. end</span>
        बहु-पंक्ति ब्लॉकों के लिए अंत और सिंगल लाइन
        ब्लॉकों के लिए घुंघराले ब्रेसिज़, लेकिन दोनों के बीच एक अंतर भी है जिसे सचित्र
        किया जा सकता है। इसका मतलब यह है कि <span class="code-inline">{}</span>  केपास
        करने की तुलना में अधिक पूर्वता <span class="code-inline">do .. end</span>
        , इस बात को ध्यान में रखें कि आप क्या उपयोग करना चाहते हैं।
    module:
      title: 'क्लास फू :: बार, मॉड्यूल फू के बाहर परिभाषित, फू के अंदर नहीं दिखेगा'
      description: आप <span class="code-inline">module Something</span> की प्रत्येक उपस्थिति
        के बारे में सोच सकते हैं <span class="code-inline">class Something</span> , <span class="code-inline">def something</span>
        या एक नए दायरे में &quot;गेटवे&quot; के रूप में कुछ
        को परिभाषित करें। जब रूबी एक ऐसे नाम की परिभाषा खोज रही है जिसे पहले संदर्भित
        किया गया है, तो वह वर्तमान क्षेत्र (विधि, वर्ग या मॉड्यूल) में दिखता है, और
        यदि यह नहीं पाया जाता है कि यह &quot;गेटवे&quot; वाले प्रत्येक के माध्यम से
        वापस कहां जाएगा और खोज वहाँ गुंजाइश है।
    credits: 'कोड और लेख संसाधनों से लिए गए थे:'
  meta_programming:
    title: Metaprogramming
    description: 'मेटाप्रोग्रामिंग कंप्यूटर प्रोग्रामों का लेखन है जो अन्य प्रोग्रामों
      (या स्वयं) को अपने डेटा के रूप में लिखते हैं या उनमें हेरफेर करते हैं, या जो संकलन
      समय पर काम करते हैं जो अन्यथा रनटाइम पर किया जाएगा। कई मामलों में, यह प्रोग्रामर
      को उतने ही समय में अधिक काम करने की अनुमति देता है, जितना कि वे सभी कोड को मैन्युअल
      रूप से लिखने के लिए ले जाते हैं, या यह प्रोग्राम को पुन: प्राप्ति के बिना नई स्थितियों
      को कुशलतापूर्वक संभालने के लिए अधिक लचीलापन देता है। मेटाप्रोग्रामिंग कोड लिख
      रहा है जो आपके जीवन को आसान बनाने के लिए रनटाइम के दौरान कोड लिखता है।'
    dynamic_dispatch:
      title: गतिशील डिस्पैच
      description: हमें <span class="code-inline">subject.public_send(message, *arguments)</span> भेजने की अनुमति देता
        है।
    dynamic_method:
      title: गतिशील विधि
      description: 'हमें विधिवत तरीके से विधियाँ_मिथोड
        बनाने की अनुमति देता है <span class="code-inline">define_method :method_name { block that becomes method body }</span>'
    ghost_methods:
      title: भूत की विधियाँ
      description: '&quot;घोस्ट मेथड्स&quot; को पकड़ना और उन्हें किसी अन्य विधि पर अग्रेषित
        करना, जबकि कॉल के आसपास तर्क जोड़ना संभव है। <span class="code-inline">method_missing</span>
        का इस्तेमाल करता है'
    dynamic_proxies:
      title: डायनेमिक प्रॉक्सी
      description: 'उदाहरण के लिए, आप आने वाले संदेश (जैसे <span class="code-inline">get_name</span>
        , <span class="code-inline">get_age</span>) को पार्स करने के लिए और (जैसे <span
        class="code-inline">get(:data_type)</span> जहाँ <span class="code-inline">:data_type</span>
        <span class="code-inline">:name</span> या <span class="code-inline">:age</span>
        , को भेजने केलिए <span class="code-inline">method_missing</span>
        का उपयोग करके काल्पनिक तरीके प्रदान कर सकते हैं।'
      more: यदि (विश्लेषण के बाद) आप मेथड_स्मिसिंग के
        उपयोग से एक प्रदर्शन समस्या का पता लगाते हैं, <span class="code-inline">method_missing</span>
        तो आप पहली बार द्वारा संदेश प्राप्त करने के बाद एक वास्तविक
        विधि बनाने के लिए&quot; डायनेमिक विधि &quot;तकनीक का उपयोग कर सकते हैं।
  solid_principles:
    good: अच्छा!
    bad: खराब!
    title: ठोस सिद्धांत
    description: कंप्यूटर प्रोग्रामिंग में, SOLID (एकल जिम्मेदारी, ओपन-क्लोज्ड, लिस्कोव
      प्रतिस्थापन, इंटरफ़ेस अलगाव, और निर्भरता व्युत्क्रम) माइकल फैंस द्वारा &quot;फर्स्ट
      फाइव प्रिंसिपल्स&quot; के लिए रॉबर्ट फेन द्वारा पेश किया गया एक प्रारंभिक परिचय
      है जो 2000 के दशक की शुरुआत में खड़ा था। वस्तु उन्मुख प्रोग्रामिंग और डिजाइन के
      पांच बुनियादी सिद्धांतों के लिए। आशय यह है कि ये सिद्धांत, जब एक साथ लागू होते
      हैं, तो यह अधिक संभावना बना देगा कि एक प्रोग्रामर एक ऐसी प्रणाली बनाएगा जो समय
      के साथ बनाए रखने और विस्तारित करने में आसान हो। एसओएलआईडी के सिद्धांत दिशानिर्देश
      हैं जो प्रोग्रामर को सॉफ़्टवेयर के स्रोत कोड को फिर से दर्ज करने के लिए प्रोग्रामर
      के कारण कोड स्मेल को हटाने के लिए सॉफ्टवेयर पर काम करते समय लागू किया जा सकता
      है जब तक कि यह सुपाठ्य और एक्स्टेंसिबल दोनों न हो। यह चुस्त और अनुकूली सॉफ्टवेयर
      विकास की एक समग्र रणनीति का हिस्सा है।
    single:
      title: एकल जिम्मेदारी सिद्धांत
      description: एकल जिम्मेदारी सिद्धांत गुच्छा का सबसे सार है। यह कक्षाओं और विधियों
        को छोटा और बनाए रखने में मदद करता है। कक्षाओं को छोटा रखने और ध्यान केंद्रित
        करने के अलावा यह उन्हें समझने में भी आसान बनाता है। इसका एक उदाहरण संसाधित किए
        गए सौदे को चिह्नित करने के बाद किसी विशिष्ट व्यक्ति के कमीशन का ईमेल सारांश
        भेजने के लिए समर्थन जोड़ना हो सकता है। यह तथ्य कि हम संकेतों को बदलने के लिए
        कई कारणों की पहचान कर सकते हैं, एकल जिम्मेदारी सिद्धांत का उल्लंघन है।
    open_close:
      title: खुला / बंद सिद्धांत
      description: ओपन / क्लोज्ड सिद्धांत बताता है कि कक्षाएं या विधियां विस्तार के
        लिए खुली होनी चाहिए, लेकिन संशोधन के लिए बंद। यह हमें बताता है कि हमें उन मॉड्यूलर
        डिजाइनों के लिए प्रयास करना चाहिए जो हमें कक्षाओं में खुद को संशोधन किए बिना
        सिस्टम के व्यवहार को बदलना संभव बनाते हैं। यह आमतौर पर रणनीति पैटर्न जैसे पैटर्न
        के उपयोग के माध्यम से हासिल किया जाता है।
      after: 'इस रीफैक्टरिंग के साथ हमने बिना किसी कोड को बदले नए पार्सर्स जोड़ना संभव
        बना दिया है। किसी भी अतिरिक्त व्यवहार को केवल एक नए हैंडलर के अतिरिक्त की आवश्यकता
        होगी। यह हमारे FileParser को पुन: प्रयोज्य बनाता है और कई मामलों में हमें एकल
        जवाबदेही सिद्धांत के अनुपालन के साथ-साथ हमें और अधिक केंद्रित कक्षाएं बनाने
        के लिए प्रोत्साहित करेगा।'
    liskov:
      title: लिस्कोव के प्रतिस्थापन सिद्धांत
      description: लिस्कोव का सिद्धांत समझने के लिए सबसे कठिन है। सिद्धांत में कहा गया
        है कि आपको किसी भी अप्रत्याशित या गलत व्यवहार के बिना माता-पिता वर्ग के किसी
        भी उदाहरण को अपने बच्चों में से एक के उदाहरण से बदलने में सक्षम होना चाहिए।
    segregation:
      title: निर्भरता उलटा सिद्धांत
      description: 'सिद्धांत कहता है कि एक ग्राहक को उन तरीकों पर निर्भर होने के लिए
        मजबूर नहीं किया जाना चाहिए जो इसका उपयोग नहीं करते हैं। इस उदाहरण में, कंप्यूटर,
        प्रोग्रामर और तकनीशियन वर्ग हैं। प्रोग्रामर और टेक्नीशियन दोनों एक अलग तरीके
        से कंप्यूटर का उपयोग करते हैं। प्रोग्रामर टाइपिंग के लिए कंप्यूटर का उपयोग करता
        है, लेकिन तकनीशियन कंप्यूटर हार्ड ड्राइव को बदलना जानता है। इंटरफ़ेस पृथक्करण
        सिद्धांत (ISP) लागू करता है कि एक वर्ग को उन तरीकों पर निर्भर नहीं होना चाहिए
        जो इसका उपयोग नहीं करते हैं। हमारे मामले में, प्रोग्रामर को अनावश्यक रूप से
        कंप्यूटर # change_hard_drive विधि से जोड़ा जाता है क्योंकि यह इसका उपयोग नहीं
        करता है, लेकिन राज्य यह बदलता है कि यह विधि लागू होने से प्रोग्रामर प्रभावित
        हो सकता है। एलएसपी का पालन करने के लिए कोड को रिफलेक्टर करते हैं।'
      after: इस रिफ्लेक्टर के बाद तकनीशियन ComputerInternals प्रकार से एक अलग ऑब्जेक्ट
        का उपयोग करता है जो कंप्यूटर की स्थिति से अलग होता है। कंप्यूटर ऑब्जेक्ट की
        स्थिति प्रोग्रामर से प्रभावित हो सकती है लेकिन परिवर्तन किसी भी तरह से तकनीशियन
        को प्रभावित नहीं करेंगे।
    di:
      title: निर्भरता उलटा सिद्धांत
      description: 'निर्भरता उलटा सिद्धांत को उच्च-स्तरीय (व्यावसायिक तर्क के अनुसार)
        वस्तुओं के साथ करना पड़ता है जो निम्न-स्तर (डेटाबेस क्वेरी और IO) कार्यान्वयन
        विवरण पर निर्भर नहीं करता है। यह बतख टाइपिंग और डिपेंडेंसी इनवर्जन सिद्धांत
        के साथ प्राप्त किया जा सकता है। अक्सर इस पैटर्न का उपयोग ओपन / बंद सिद्धांत
        को प्राप्त करने के लिए किया जाता है जिसे हमने ऊपर चर्चा की थी। वास्तव में, हम
        इस सिद्धांत के प्रदर्शन के रूप में उसी उदाहरण का पुन: उपयोग भी कर सकते हैं।
        अब एक फॉर्मेटर क्लास है, लेकिन मैंने इसे रिपोर्ट क्लास पर हार्डकोड किया है,
        इस प्रकार रिपोर्ट से JSONFormatter पर निर्भरता पैदा करता है। चूंकि रिपोर्ट JSONFormatter
        की तुलना में अधिक सार (उच्च-स्तरीय) अवधारणा है, हम प्रभावी रूप से DIP को तोड़
        रहे हैं।'
      after: इस तरह से रिपोर्ट JSONFormatter पर निर्भर नहीं करती है और किसी भी प्रकार
        के फ़ॉर्मैटर का उपयोग कर सकती है जिसमें प्रारूप नामक एक विधि है (इसे बतख टाइपिंग
        कहा जाता है)। नोट की एक और बात यह है कि हमने एक बार फिर से, एक समस्या को हल
        करने के लिए निर्भरता इंजेक्शन का उपयोग किया है। यह तकनीक एक बहुत शक्तिशाली है
        जब हमारा लक्ष्य वस्तुओं को डिकोड कर रहा है, और भले ही यह निर्भरता उलटा सिद्धांत
        (बनाम निर्भरता इंजेक्शन पैटर्न) के समान प्रारंभिक है, वे पूरी तरह से अलग अवधारणाएं
        हैं।
  threads:
    example: उदाहरण
    title: धागे
    description: 'समानता और संगति के बारे में ध्यान दें: प्रक्रियाओं बनाम थ्रेड्स का
      उपयोग करने के बीच प्राथमिक अंतर वह तरीका है जिससे स्मृति को संभाला जाता है। उच्च
      स्तर पर, प्रक्रियाएं मेमोरी की प्रतिलिपि बनाती हैं, जबकि थ्रेड्स मेमोरी साझा करते
      हैं। यह थ्रेड स्पैनिंग की तुलना में प्रक्रिया को धीमा बनाता है और एक बार चलने
      पर अधिक संसाधनों की खपत करने वाली प्रक्रियाओं की ओर जाता है। कुल मिलाकर, धागे
      प्रक्रियाओं की तुलना में कम ओवरहेड को उकसाते हैं। यह थ्रेड एपीआई एक रूबी एपीआई
      है। मैंने संकेत दिया है कि विभिन्न रूबी कार्यान्वयन में अलग-अलग अंतर्निहित थ्रेडिंग
      व्यवहार होते हैं।'
    green:
      title: हरे धागे
      description: रूबी 1.9 ने हरे रंग के धागों को देशी धागों से बदल दिया। हालाँकि,
        GIL अभी भी समानता को रोक रहा है। कहा जा रहा है कि, बेहतर समय-सारिणी के माध्यम
        से सुगमता में सुधार किया गया है। नया शेड्यूल संदर्भ स्विच के फैसलों को अधिक
        कुशल बनाता है, अनिवार्य रूप से उन्हें एक अलग देशी धागे में स्थानांतरित करके,
        जिसे टाइमर धागे के रूप में जाना जाता है।
    gil:
      title: GIL - ग्लोबल इंटरप्रेटर लॉक
      description: MRI में एक वैश्विक दुभाषिया ताला (GIL) है। यह रूबी कोड के निष्पादन
        के चारों ओर एक ताला है। इसका मतलब यह है कि बहु-थ्रेडेड संदर्भ में, केवल एक धागा
        किसी भी समय रूबी कोड को निष्पादित कर सकता है। यदि आपके पास 8 धागे हैं, तो बस
        8-कोर मशीन पर बस काम कर रहा है, केवल एक धागा और एक कोर किसी भी समय व्यस्त होगा
        । जीआईएल रूबी इंटर्नल को दौड़ की स्थिति से बचाने के लिए मौजूद है जो डेटा को
        दूषित कर सकती है। कैविएट और ऑप्टिमाइज़ेशन हैं, लेकिन यह जिस्ट है।
      example: यह सरल तथ्य यह है कि धागों को इतना शक्तिशाली बनाता है, और यह भी कि उनके
        साथ काम करना मुश्किल हो जाता है। मैंने आपको पहले से ही एक विचार दिया है कि थ्रेड्स
        अच्छे क्यों हैं; उनकी कठिनाई को स्पष्ट करने के लिए यहां एक सरल कार्यक्रम है।
        यहां आप देख सकते हैं कि हमारे पास सरणी में <span class="code-inline">10 * 10000</span>
        तत्व हैं। ध्यान दें कि अलग-अलग माणिक एक अलग परिणाम दिखा सकते हैं। जीआईएल केवल
        एमआरआई माणिक में मौजूद है।
    mutex:
      title: म्यूटेक्स - पारस्परिक निष्पादन
      description: म्यूटेक्स कोड के एक महत्वपूर्ण हिस्से तक पहुंच को सिंक्रनाइज़ करने
        के लिए कई थ्रेड के लिए एक तंत्र प्रदान करता है। दूसरे शब्दों में, वे बहु-पिरोया
        अराजकता की दुनिया में कुछ आदेश, और कुछ गारंटी लाने में मदद करते हैं। &#39;म्यूटेक्स&#39;
        नाम &#39;आपसी बहिष्कार&#39; के लिए आशुलिपि है। यदि आप अपने कोड के कुछ खंड को
        म्यूटेक्स के साथ लपेटते हैं, तो आप गारंटी देते हैं कि कोई भी दो धागे एक ही समय
        में उस अनुभाग में प्रवेश नहीं कर सकते। म्यूटेक्स कोड के एक महत्वपूर्ण हिस्से
        तक पहुंच को सिंक्रनाइज़ करने के लिए कई थ्रेड के लिए एक तंत्र प्रदान करता है।
        यह बहु-पिरोया अराजकता की दुनिया में कुछ आदेश और कुछ गारंटी लाने में मदद करता
        है।
      example: इस कार्यक्रम में, चूंकि किसी भी थ्रेड को म्यूटेक्स को लॉक करना पड़ता
        है, इससे पहले कि वह ऐरे को धक्का दे सकता है, इस बात की गारंटी है कि कोई भी दो
        थ्रेड इस ऑपरेशन को एक ही समय में नहीं करेंगे। दूसरे शब्दों में, इस ऑपरेशन को
        पूरा होने से पहले बाधित नहीं किया जा सकता है। एक बार जब एक धागा ऐरे को धकेलना
        शुरू कर देता है, तो कोई दूसरा धागा कोड के उस हिस्से में प्रवेश नहीं कर पाएगा
        जब तक कि पहला धागा समाप्त नहीं हो जाता। यह ऑपरेशन अब थ्रेड-सेफ है। यहां आप देख
        सकते हैं कि हमारे पास सरणी में <span class="code-inline">10 * 10000</span> तत्व
        हैं। म्यूटेक्स के कारण अब सभी समान हैं। म्यूटेक्स धागे के लिए एक ही सीमा निर्धारित
        करता है। इस बिट कोड को हिट करने वाला पहला धागा म्यूटेक्स को लॉक करेगा। यह उस
        म्यूटेक्स का मालिक बन जाता है। जब तक मालिक धागा म्यूटेक्स को अनलॉक नहीं करता,
        तब तक कोई अन्य धागा इसे लॉक नहीं कर सकता है।
    fibers:
      title: रेशे
      description: रूबी में हल्के वजन सहकारिता की संगोष्ठी को लागू करने के लिए फाइबर
        आदिम हैं। असल में, वे कोड ब्लॉक बनाने का एक साधन हैं जिन्हें थ्रेड की तरह रोका
        और फिर से शुरू किया जा सकता है। मुख्य अंतर यह है कि वे कभी भी पूर्व निर्धारित
        नहीं होते हैं और यह कि कार्यक्रम प्रोग्रामर द्वारा किया जाना चाहिए न कि वीएम
        द्वारा। जैसा कि अन्य स्टैकलेस लाइटवेट कंसीलर मॉडल के विपरीत है, प्रत्येक फाइबर
        एक छोटे 4KB स्टैक के साथ आता है। यह फाइबर ब्लॉक के भीतर गहरी नेस्टेड फ़ंक्शन
        कॉल से फाइबर को रोकने में सक्षम बनाता है।
    rails:
      title: धागा-सुरक्षा रेल
      description: इसके साथ समस्या यह है कि पूर्ण निश्चितता के साथ यह कहने का कोई सरल
        तरीका नहीं है कि क्या संपूर्ण रूप से कोई ऐप थ्रेड-सुरक्षित है।
      global_variables: वैश्विक चर वैश्विक हैं। इसका मतलब है कि वे धागे के बीच साझा
        किए जाते हैं। यदि आप अब तक वैश्विक चर का उपयोग नहीं करने के बारे में आश्वस्त
        नहीं थे, तो उन्हें कभी न छूने का एक और कारण है। यदि आप वास्तव में किसी एप्लिकेशन
        में विश्व स्तर पर कुछ साझा करना चाहते हैं, तो आप एक निरंतर (लेकिन नीचे देखें)
        द्वारा बेहतर सेवा कर रहे हैं, वैसे भी।
      class_variables: कक्षा चर। धागे के बारे में चर्चा के उद्देश्य के लिए, वर्ग चर
        वैश्विक चर से बहुत अलग नहीं हैं। वे बस एक ही तरीके से धागे के पार साझा किए जाते
        हैं। समस्या वर्ग चर का उपयोग करने के बारे में बहुत नहीं है, लेकिन उन्हें बदलने
        के बारे में है। और अगर आप एक वर्ग चर को म्यूट नहीं करने जा रहे हैं, तो कई मामलों
        में एक स्थिर फिर से एक बेहतर विकल्प है।
      instance_variables: कक्षा उदाहरण चर। लेकिन हो सकता है कि आपने पढ़ा हो कि आपको
        हमेशा रूबी में क्लास वेरिएबल्स के बजाय क्लास इंस्टेंस वेरिएबल्स का उपयोग करना
        चाहिए। ठीक है, शायद आपको करना चाहिए, लेकिन वे केवल कक्षा चर के रूप में थ्रेडेड
        प्रोग्राम के लिए समस्याग्रस्त हैं।
      memoization: 'अपने आप में संस्मरण एक धागा सुरक्षा मुद्दा नहीं है। इसका उपयोग अक्सर
        वर्ग चर या वर्ग उदाहरण चर (पिछले अंक देखें) में डेटा को स्टोर करने के लिए किया
        जाता है। The <span class="code-inline">= =</span> ऑपरेटर, वास्तव में, दो ऑपरेशन
        हैं, इसलिए इसके बीच में एक संभावित संदर्भ स्विच हो रहा है, जो थ्रेड्स के बीच
        दौड़ की स्थिति पैदा करता है। तो भले ही आप केवल उदाहरण चर का उपयोग कर रहे हों,
        आप संस्मरण के साथ दौड़ की स्थिति को समाप्त कर सकते हैं। वर्ग चर या वर्ग उदाहरण
        चर के लिए याद मत करो। यदि आपको कक्षा स्तर पर कुछ याद रखने की आवश्यकता है, तो
        इसके स्थान पर थ्रेड लोकल वैरिएबल (<span class="code-inline">Thread.current[:baz]</span>)
        का उपयोग करें। हालाँकि, अवगत रहें, कि यह अभी भी एक वैश्विक चर की तरह है।'
    config:
      title: धागे को कॉन्फ़िगर करें !?
      description: इस पद्धति को कॉल करना हमारे एप्लिकेशन कॉन्फ़िगरेशन में चार विकल्प
        सेट करता है। चलो प्रत्येक विकल्प के माध्यम से चलते हैं और इसके बारे में बात
        करते हैं कि यह क्या करता है।
      frameworks: 'प्रीलोडिंग फ्रेमवर्क: पहला विकल्प @preload_frameworks बहुत कुछ कहता
        है, यह रेल ढांचे को बूट पर उत्सुकता से लोड करने के लिए मजबूर करता है। जब यह
        विकल्प सक्षम नहीं होता है, तो फ्रेमवर्क कक्षाएं ऑटोलैड के माध्यम से आलसी लोड
        की जाती हैं। बहु-थ्रेडेड वातावरण में, किसी भी थ्रेड को ऑटोलैड के साथ थ्रेड सुरक्षा
        समस्याओं के कारण बनाए जाने से पहले फ्रेम को उत्सुकता से लोड करने की आवश्यकता
        होती है। हम जानते हैं कि फ्रेमवर्क लोड करना थ्रेडसेफ़ नहीं है, इसलिए किसी भी
        थ्रेड्स अनुरोधों को संभालने के लिए तैयार होने से पहले इसे पूरा करने की रणनीति
        है।'
      cache: 'कैशिंग क्लासेस: @cache_classes विकल्प नियंत्रित करता है कि कक्षाएं पुनः
        लोड की जाएं या नहीं। याद रखें कि आप अपने आवेदन में &quot;टीडीडी&quot; कब कर
        रहे हैं? आप एक नियंत्रक को संशोधित करते हैं, फिर पृष्ठ को &quot;परीक्षण&quot;
        के लिए फिर से लोड करते हैं और देखते हैं कि चीजें बदल गईं? हां, यही विकल्प नियंत्रित
        करता है। जब यह विकल्प गलत होता है, तो विकास के रूप में, आपकी कक्षाएं संशोधित
        होने पर पुनः लोड की जाएंगी। इस विकल्प के बिना, हम अपना &quot;F5DD&quot; नहीं
        कर पाएंगे (हाँ, यह F5 संचालित विकास है)। उत्पादन में, हम जानते हैं कि वर्गों
        को मक्खी पर संशोधित नहीं किया जा सकता है, इसलिए कक्षाओं को फिर से लोड करने के
        लिए काम करना है या नहीं, केवल संसाधनों को बर्बाद करना है, इसलिए यह समझ में आता
        है कि कभी भी कक्षा परिभाषाओं को पुनः लोड न करें'
      di: 'निर्भरता लोड हो रहा है: यह विकल्प, @ निर्भरता_ लोडिंग नियंत्रण कोड लोड हो
        रहा है जब लापता स्थिरांक का सामना करना पड़ रहा है। उदाहरण के लिए, एक नियंत्रक
        उपयोगकर्ता मॉडल का संदर्भ देता है, लेकिन उपयोगकर्ता निरंतर परिभाषित नहीं होता
        है। उस स्थिति में, यदि @d dependency_loading सत्य है, तो रेल को वह फ़ाइल मिलेगी
        जिसमें उपयोगकर्ता स्थिर है और उस फ़ाइल को लोड करता है। हमने पहले से ही इस बारे
        में बात की थी कि कैसे कोड लोडिंग थ्रेड सुरक्षित नहीं है, इसलिए यहां विचार यह
        है कि हमें फ्रेमवर्क लोड करना चाहिए, फिर सभी उपयोगकर्ता कोड लोड करना चाहिए,
        फिर निर्भरता लोडिंग अक्षम करें। एक बार निर्भरता लोडिंग अक्षम हो जाने के बाद,
        फ्रेमवर्क कोड और ऐप कोड लोड किया जाना चाहिए, और कोई भी लापता स्थिरांक केवल कोड
        लोड करने के प्रयास के बजाय एक अपवाद बढ़ाएगा। हम उत्पादन में इस विकल्प को अक्षम
        करने को सही ठहराते हैं क्योंकि (जैसा कि पहले उल्लेख किया गया था) कोड लोड करना
        थ्रेडसेफ़ नहीं है, और हम किसी भी थ्रेड के अनुरोधों को संभालने से पहले सभी कोड
        लोड होने की उम्मीद करते हैं।'
      concurrency: 'अनुमति देने वाली संगणना: @allow_concurrency विकल्प नियंत्रित करता
        है कि क्या रैक :: लॉक मिडलवेयर का उपयोग आपके स्टैक में किया गया है या नहीं।
        रैक :: लॉक आपके अनुरोध के चारों ओर म्यूटेक्स लपेटता है। यह विचार किया जा रहा
        है कि यदि आपके पास कोड है जो थ्रेडसेफ़ नहीं है, तो यह म्यूटेक्स एक ही समय में
        कई थ्रेड्स को आपके कंट्रोलर कोड को निष्पादित करने से रोकेगा। जब थ्रेडसेफ़! सेट
        किया गया है, इस मिडलवेयर को हटा दिया गया है, और नियंत्रक कोड को समानांतर में
        निष्पादित किया जा सकता है।'
    credits: 'कोड और लेख संसाधनों से लिए गए थे:'
  ruby_meister:
    title: रूबी मिस्टर बनें
    description: इस चर्चा में, हम रूबी नौसिखिया होने से लेकर रूबी महारत हासिल करने तक
      के लंबे सफर की पड़ताल करेंगे और कुछ महत्वपूर्ण जानकारियों को साझा करके आपके लिए
      इसे थोड़ा छोटा करने की कोशिश करेंगे। एक मास्टर रूबिस्ट के पास एक महान सैद्धांतिक
      आधार है, एक व्यापक टूलबॉक्स पर निर्भर करता है, रूबी के मूल मूल्यों और सिद्धांतों
      की गहरी समझ है और हमेशा अपने कौशल का सम्मान कर रहा है। शायद आप खुद को बता रहे
      हैं &quot;वाह, यह बहुत अस्पष्ट है!&quot;, लेकिन अगर आप इस सत्र में भाग लेते हैं,
      तो मैं वादा करता हूं कि आप प्रबुद्ध होंगे, खुश होंगे और आप पूरी तरह से इसका आनंद
      लेंगे। बढ़िया है? महान पुस्तकें उन संसाधनों का हिस्सा होंगी जो मैं लोगों को अपने
      कौशल को समतल करने के लिए सुझाऊंगा।
    video: Bozhidar Batsov द्वारा रूबी मास्टरी की लंबी यात्रा।
    computer_science_fundamentals:
      title: कंप्यूटर विज्ञान बुनियादी बातों
      articles:
        - name: inside_machine
          title: 'मशीन के अंदर: माइक्रोप्रोसेसरों और कंप्यूटर वास्तुकला का एक इलस्ट्रेटेड
            परिचय'
          description: कंप्यूटर व्यवसाय से लेकर मनोरंजन तक अनगिनत कार्य करते हैं, लेकिन
            चाहे वे कितने ही अलग दिखें और व्यवहार करें, वे सभी आश्चर्यजनक रूप से मूल
            कार्य के समान हैं। एक बार जब आप समझ जाते हैं कि माइक्रोप्रोसेसर- या सेंट्रल
            प्रोसेसिंग यूनिट (सीपीयू) -वर्क्स, आपके पास सभी आधुनिक कंप्यूटिंग के दिल
            में मूलभूत अवधारणाओं की एक मजबूत पकड़ है
        - name: code
          title: 'कोड: कंप्यूटर हार्डवेयर और सॉफ्टवेयर की छिपी हुई भाषा'
          description: फ्लैशलाइट्स, ब्रिटिश आक्रमण, काली बिल्लियों और सीसाओं को कंप्यूटर
            के साथ क्या करना है? CODE में, वे हमें उन सरल तरीकों को दिखाते हैं जिन्हें
            हम भाषा में हेरफेर करते हैं और एक दूसरे के साथ संवाद करने के नए माध्यमों
            का आविष्कार करते हैं। और CODE के माध्यम से, हम देखते हैं कि यह सरलता और
            संवाद करने की हमारी बहुत मानवीय मजबूरी ने पिछले दो शताब्दियों के तकनीकी
            नवाचारों को कैसे संचालित किया है।
        - name: concrete_math
          title: 'ठोस गणित: कंप्यूटर विज्ञान के लिए एक फाउंडेशन'
          description: यह पुस्तक गणित का परिचय देती है जो उन्नत कंप्यूटर प्रोग्रामिंग
            और एल्गोरिदम के विश्लेषण का समर्थन करती है। इसके प्रसिद्ध लेखकों का प्राथमिक
            उद्देश्य गणितीय कौशल का एक ठोस और प्रासंगिक आधार प्रदान करना है - जटिल समस्याओं
            को हल करने के लिए आवश्यक कौशल, भयावह रकम का मूल्यांकन करने के लिए, और डेटा
            में सूक्ष्म पैटर्न की खोज करना। यह एक अपरिहार्य पाठ और संदर्भ है जो न केवल
            कंप्यूटर वैज्ञानिकों के लिए है - लेखक स्वयं इस पर बहुत भरोसा करते हैं! -
            लेकिन लगभग हर अनुशासन में गणित के गंभीर उपयोगकर्ताओं के लिए।
        - name: sicp
          title: कंप्यूटर प्रोग्राम की संरचना और व्याख्या
          description: 'कंप्यूटर प्रोग्राम की संरचना और व्याख्या की पिछले एक दशक में
            कंप्यूटर विज्ञान पाठ्यक्रम पर एक नाटकीय प्रभाव पड़ा है। इस लंबे समय से प्रतीक्षित
            संशोधन में पूरे पाठ में परिवर्तन होते हैं। पुस्तक में अधिकांश प्रमुख प्रोग्रामिंग
            प्रणालियों के नए कार्यान्वयन हैं, जिनमें दुभाषियों और संकलक भी शामिल हैं,
            और लेखकों ने कई छोटे बदलावों को शामिल किया है जो एमआईटी में पाठ्यक्रम को
            पढ़ाने के उनके अनुभव को दर्शाते हैं क्योंकि पहला संस्करण प्रकाशित हुआ था।
            एक नया विषय पेश किया गया है जो कम्प्यूटेशनल मॉडल में समय के साथ काम करने
            के लिए विभिन्न दृष्टिकोणों द्वारा निभाई गई केंद्रीय भूमिका पर जोर देता है:
            राज्य, समवर्ती प्रोग्रामिंग, कार्यात्मक प्रोग्रामिंग, और आलसी मूल्यांकन,
            और नॉन्डेटर्मिनिस्टिक प्रोग्रामिंग के साथ ऑब्जेक्ट।'
        - name: design_programms
          title: 'कैसे डिजाइन करने के लिए कार्यक्रम: प्रोग्रामिंग और कम्प्यूटिंग के
            लिए एक परिचय'
          description: यह प्रोग्रामिंग एक उदार कला शिक्षा के मूल में कंप्यूटर विज्ञान
            को पेश करता है। अन्य परिचयात्मक पुस्तकों के विपरीत, यह कार्यक्रम डिजाइन
            प्रक्रिया पर केंद्रित है। यह दृष्टिकोण विभिन्न प्रकार के कौशल को बढ़ावा
            देता है f महत्वपूर्ण पढ़ना, विश्लेषणात्मक सोच, रचनात्मक संश्लेषण, और विस्तार
            ost पर ध्यान देना जो कि सभी के लिए महत्वपूर्ण हैं, न कि केवल भविष्य के कंप्यूटर
            प्रोग्रामर। पुस्तक पाठकों को दो मौलिक रूप से नए विचारों को उजागर करती है।
            सबसे पहले, यह प्रोग्राम डिज़ाइन दिशा-निर्देश प्रस्तुत करता है जो पाठक को
            एक समस्या कथन का विश्लेषण करने का तरीका दिखाता है; संक्षिप्त लक्ष्यों को
            कैसे बनाया जाए; उदाहरण कैसे बनाएं; विश्लेषण के आधार पर, समाधान की रूपरेखा
            कैसे विकसित की जाए; कैसे कार्यक्रम खत्म करने के लिए; और परीक्षण कैसे करें
        - name: algorithm_manual
          title: एल्गोरिथ्म डिजाइन मैनुअल
          description: सबसे अधिक बिकने वाले क्लासिक के इस नए विस्तारित और अपडेट किए
            गए दूसरे संस्करण को डिजाइनिंग एल्गोरिदम से &quot;रहस्य&quot; लेना जारी है,
            और उनकी प्रभावकारिता और दक्षता का विश्लेषण करना है। पहले संस्करण पर विस्तार
            करते हुए, यह पुस्तक अब प्रोग्रामर, शोधकर्ताओं और छात्रों के लिए एल्गोरिदम
            के प्रमुख व्यावहारिक संदर्भ गाइड के रूप में अपनी स्थिति बनाए रखते हुए एल्गोरिथम
            डिज़ाइन पाठ्यक्रमों के लिए पसंद की प्राथमिक पाठ्यपुस्तक के रूप में कार्य
            करती है।
        - name: cormen
          title: एल्गोरिदम का परिचय, तीसरा संस्करण (एमआईटी प्रेस)
          description: एल्गोरिदम पर कुछ किताबें कठोर हैं लेकिन अधूरी हैं; दूसरों ने
            सामग्री के द्रव्यमान को कवर किया, लेकिन कठोरता की कमी थी। एल्गोरिदम का परिचय
            विशिष्ट रूप से कठोरता और व्यापकता को जोड़ता है। पुस्तक गहराई से एल्गोरिदम
            की एक विस्तृत श्रृंखला को कवर करती है, फिर भी उनके डिजाइन और विश्लेषण को
            सभी स्तरों के पाठकों के लिए सुलभ बनाती है। प्रत्येक अध्याय अपेक्षाकृत आत्म-निहित
            है और इसका उपयोग अध्ययन की इकाई के रूप में किया जा सकता है। एल्गोरिदम अंग्रेजी
            में वर्णित है और एक छद्मकोड में डिज़ाइन किया गया है जिसे किसी ने भी पढ़ा
            है जिसने थोड़ी प्रोग्रामिंग की है। कवरेज या गणितीय कठोरता की गहराई का त्याग
            किए बिना स्पष्टीकरण को प्राथमिक रखा गया है।
        - name: compilers
          title: 'संकलक: सिद्धांत, तकनीक और उपकरण (दूसरा संस्करण)'
          description: 'कंपाइलर: सिद्धांत, तकनीक और उपकरण, जिन्हें प्रोफेसरों, छात्रों
            और डेवलपर्स को दुनिया भर में &quot;ड्रैगन बुक&quot; के रूप में जाना जाता
            है, एक नए संस्करण में उपलब्ध है। हर अध्याय को सॉफ्टवेयर इंजीनियरिंग, प्रोग्रामिंग
            भाषाओं और कंप्यूटर आर्किटेक्चर में विकास को प्रतिबिंबित करने के लिए पूरी
            तरह से संशोधित किया गया है, जो कि 1986 से अंतिम संस्करण प्रकाशित होने के
            बाद हुआ है। लेखकों ने यह स्वीकार करते हुए कि कुछ पाठक कभी भी एक कंपाइलर
            का निर्माण करेंगे, सॉफ्टवेयर डिजाइन और सॉफ्टवेयर विकास में आने वाली समस्याओं
            के व्यापक सेट पर अपना ध्यान केंद्रित रखेंगे।'
        - name: c_lang
          title: सी प्रोग्रामिंग लैंग्वेज, दूसरा संस्करण
          description: लेखक एएनएसआई मानक सी भाषा प्रोग्रामिंग के लिए पूरा गाइड प्रस्तुत
            करते हैं। C के डेवलपर्स द्वारा लिखित, यह नया संस्करण पाठकों को C के लिए
            अंतिम ANSI मानक के साथ बनाए रखने में मदद करता है, जबकि यह दर्शाता है कि
            C के समृद्ध सेटों, अभिव्यक्ति की अर्थव्यवस्था, बेहतर नियंत्रण प्रवाह और
            डेटा संरचनाओं का लाभ कैसे उठाया जाए। 2 / ई को पूरी तरह से अतिरिक्त उदाहरण
            और समस्या सेट के साथ फिर से लिखा गया है ताकि कठिन भाषा के निर्माण के कार्यान्वयन
            को स्पष्ट किया जा सके। वर्षों के लिए, सी प्रोग्रामर ने केएंडआर को अच्छी
            तरह से संरचित और कुशल कार्यक्रमों के निर्माण के लिए उनका मार्गदर्शन करने
            दिया है। अब, एएनएसआई संकलक के साथ काम करने वालों के लिए भी यही मदद उपलब्ध
            है। इसमें सी लैंग्वेज की विस्तृत कवरेज और सिंटैक्स नोटेशन, घोषणाओं, एएनएसआई
            में बदलाव, स्कोप नियम और सूची में मदद के लिए आधिकारिक सी लैंग्वेज रेफरेंस
            मैनुअल शामिल है।
    oop:
      title: ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग
      articles:
        - name: growing
          title: बढ़ते ऑब्जेक्ट-ओरिएंटेड सॉफ्टवेयर, टेस्ट द्वारा निर्देशित
          description: 'टेस्ट-डेवलप्ड डेवलपमेंट (टीडीडी) अब बेहतर सॉफ्टवेयर को तेजी
            से वितरित करने के लिए एक स्थापित तकनीक है। TDD एक सरल विचार पर आधारित है:
            कोड लिखने से पहले अपने कोड के लिए परीक्षण लिखें। हालांकि, यह &quot;सरल&quot;
            विचार अच्छा करने के लिए कौशल और निर्णय लेता है। अब TDD के लिए एक व्यावहारिक
            मार्गदर्शिका है जो आपको मूल अवधारणाओं से परे ले जाती है। वास्तविक-विश्व
            प्रणालियों के निर्माण के एक दशक के अनुभव पर आकर्षित, दो TDD अग्रदूत दिखाते
            हैं कि कैसे परीक्षणों को आपके विकास और &quot;विकसित&quot; सॉफ़्टवेयर को
            सुसंगत, विश्वसनीय और बनाए रखने योग्य बनाया जाए।'
        - name: domain_driven
          title: 'डोमेन-चालित डिजाइन: सॉफ्टवेयर के दिल में जटिलता का सामना करना'
          description: यह सॉफ्टवेयर डिजाइन में डोमेन मॉडलिंग के बारे में एक गंभीर पुस्तक
            है। सॉफ्टवेयर विकास समाज एक प्रचार लहर से दूसरे तक रहता है। OOP, पैटर्न,
            XP, TDD, CI / CD, BigData, DevOps - यह केवल कुछ नाम रखने के लिए है। इस पुस्तक
            की उत्पत्ति OOP के स्वर्ण युग से हुई है। लेखक स्वीकार करता है कि ऑब्जेक्ट-ओरिएंटेड
            प्रतिमान केवल एक ही उपलब्ध नहीं है, लेकिन OOP / OOD के प्रति पूर्वाग्रह
            स्पष्ट (और उचित) है। यह पुस्तक कोर सॉफ्टवेयर घटकों के मॉडलिंग करने के तरीके
            के बारे में बताती है &quot;सही तरीका&quot;।
    ruby:
      title: जानिए आप
      articles:
        - name: well_grounded
          title: द वेल-ग्राउंडेड रूबीस्ट
          description: द वेल-ग्राउंडेड रूबीस्ट, दूसरा संस्करण रूबी के साथ-साथ रूबी प्रोग्रामर
            दोनों को संबोधित करता है जो भाषा की अपनी समझ को गहरा करना चाहते हैं। इस
            खूबसूरती से लिखे गए और पूरी तरह से संशोधित दूसरे संस्करण में उन विशेषताओं
            का कवरेज शामिल है जो रूबी 2.1 में नए हैं, साथ ही साथ भाषा के पहलुओं के विस्तार
            और अद्यतन कवरेज में भी बदलाव हुए हैं।
        - name: programming_ruby
          title: 'प्रोग्रामिंग रूबी: द प्रैगमैटिक प्रोग्रामर्स गाइड, दूसरा संस्करण'
          description: 'रूबी एक तेजी से लोकप्रिय, पूरी तरह से ऑब्जेक्ट-ओरिएंटेड डायनेमिक
            प्रोग्रामिंग लैंग्वेज है, जिसे कई चिकित्सकों द्वारा बेहतरीन और सबसे उपयोगी
            भाषा के रूप में आज भी उपलब्ध कराया गया है। जब रूबी पहली बार पश्चिमी दुनिया
            में दृश्य पर आई, तो प्रोगामेटिक प्रोग्रामर्स निश्चित संदर्भ मैनुअल, प्रोग्रामिंग
            रूबी: द प्रोगैमैटिक प्रोग्रामर गाइड के साथ थे।'
        - name: ruby_programming
          title: 'रूबी प्रोग्रामिंग लैंग्वेज: एवरीथिंग यू नीड टू नो'
          description: 'यह पुस्तक भाषा के लिए एक त्वरित-प्रारंभ ट्यूटोरियल के साथ शुरू
            होती है, और फिर भाषा को नीचे से ऊपर तक विस्तार से समझाती है: लेक्सिकल और
            सिंटैक्टिक संरचना से डेटाटाइप्स से लेकर अभिव्यक्तियों और बयानों तक और तरीकों,
            ब्लॉकों, लैम्ब्डा, क्लोजर, क्लासेस और के माध्यम से मॉड्यूल। पुस्तक में रूबी
            प्लेटफ़ॉर्म के समृद्ध एपीआई का एक लंबा और गहन परिचय भी शामिल है, जो प्रदर्शित
            करता है - भारी-भरकम उदाहरण वाले कोड के साथ - पाठ प्रसंस्करण, संख्यात्मक
            हेरफेर, संग्रह, इनपुट / आउटपुट, नेटवर्किंग, और संगामिति के लिए रूबी की सुविधाएं।
            एक पूरा अध्याय रूबी की मेटाप्रोग्रामिंग क्षमताओं के लिए समर्पित है।'
  interview_questions:
    title: साक्षात्कार के प्रश्न
    description: यह खंड पढ़ने और साक्षात्कार की तैयारी के लिए संसाधन लिंक रखता है
    list:
      - name: 'Toptal: कैसे एक महान रूबी डेवलपर किराया करने के लिए'
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: 'Toptal: 21 आवश्यक रूबी साक्षात्कार प्रश्न'
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: 'हुकॉप्स: 35+ रूबी और रेल्स साक्षात्कार प्रश्न और उत्तर'
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: 'Educba: 15 सबसे महत्वपूर्ण रूबी साक्षात्कार प्रश्न और उत्तर'
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: 'रूबी गैराज: रेल्वे डेवलपर पर अपने रूबी साक्षात्कार कैसे करें'
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: 'रयानसोबोल: रूबी साक्षात्कार के दौरान पूछने के लिए 15 प्रश्न'
        link: "https://gist.github.com/ryansobol/5252653"
      - name: 'Toptal: रेल साक्षात्कार के सवालों पर 9 आवश्यक रूबी'
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: क्या है बेहतर डॉक्स
    description: यह वेबसाइट है वेब रूपांतरण <a href="https://github.com/khusnetdinov/ruby.fundamental">गितुब</a>
      रिपॉजिटरी <a href="https://github.com/khusnetdinov/ruby.fundamental">रूबी.फंडामेंटल</a>
      जिसमें बहुत सारे सितारे एकत्र हुए और चीनी भाषा में इसका अनुवाद किया गया। बेहतर
      डॉक्स आपको एक रिपॉजिटरी में एकत्र किए गए बहुत अच्छे अभ्यास को जल्दी से ढूंढने
      की अनुमति देता है। बस आप इस रेपो को संदर्भ या साक्षात्कार तैयारी संसाधन की तरह।
    oss:
      title: ओपन सोर्स के लिए धन्यवाद
      description: रूबी में लिखे गए वेब डेवलपमेंट एप्लिकेशनों के लिए एक ओपन सोर्स इंजीनियरिंग,
        रूबी के बारे में सबसे अच्छी प्रथाओं और ज्ञान के बारे में जानने और जानने के दौरान
        बेहतर डॉक्स बनाए गए।
      thanks: अगर बेहतर डॉक्स ने आपकी किसी भी तरह से मदद की, तो हमें <a href="https://github.com/howtohireme/ruby.fundamental">गितुब</a>
        पर एक स्टार देने के बारे में सोचें (यह हमें अधिक डेवलपर्स तक पहुंचने में मदद
        करता है) या हमारी परियोजनाओं में योगदान देता है।
