head:
  title: BetterDocs
  metatags:
    description: Основно програмиране с рубински примери и референции. Тя обхваща нишки, принципи на SOLID, дизайнерски модели, структури от данни, алгоритми.
    keywords: По-добри документи, Ruby, Основи, Основи на програмирането на Ruby. Ruby gotchas, Функционално програмиране, Метапрограмиране, Теми, твърди принципи на Ruby с примери, Ruby дизайн модели с примери, Ruby алгоритми с примери, Ruby структури с данни с примери.

content:
  menu:
    open: Отворете менюто
    close: Затваряне на менюто

sidebar:
  - title: Алгоритми
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: Структури на данни
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: Дизайнерски модели
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: Функционално програмиране
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: Въпроси за интервю
    url: interview_questions
  - title: Метапрограмиране
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: SOLID принципи
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: Стани Ruby Meister
    url: ruby_meister
  - title: Теми
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:  
  wiki: Прочетете Уики
  credits: Кредити
  page404:
    title: Страницата не е намерена :(
    description: Заявената страница не можа да бъде намерена.
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: Алгоритми
    complexity:
      best: Най-доброто
      average: Средно аритметично
      worst: Най-лошото
    sorting:
      title: Сортиране
      description: Алгоритъм за сортиране е алгоритъм, който поставя елементи от списък в определен ред. Най-използваните поръчки са числов ред и лексикографски ред. Ефективното сортиране е важно за оптимизиране на използването на други алгоритми (като алгоритми за търсене и сливане), които изискват входните данни да бъдат в сортирани списъци; често е полезно и за канонизиране на данни и за създаване на човешки четлив изход.
      bubble_sort:
        title: Балонче
        description: Балонният вид има много от същите свойства като сортирането при вмъкване, но има малко по-високи режийни разходи. В случая на почти сортирани данни, сортирането на балонче взема <span class="code-inline time">O(n)</span>, но изисква поне 2 преминавания през данните (докато сортирането на вмъкване изисква нещо повече като 1 пас).
      insertion_sort:
        title: Сортиране на вмъкване
        description: Въпреки че това е един от елементарните алгоритми за сортиране с <span class="code-inline">O(n<sup>2</sup>)</span> време нанай-лошия случай, сортирането на вмъкване е алгоритъмът на избор, когато данните са почти сортирани (защото е адаптивно) или когато размерът на проблема е малък (защото има ниски режийни). Поради тези причини, и тъй като е стабилен, сортирането на вмъкване често се използва като рекурсивен основен случай (когато размерът на проблема е малък) за по-високи режими за разделяне и завземане, като сортиране на сливане или бърз сортиране.
      selection_sort:
        title: Сортиране на селекцията
        description: От представеното тук сравнение може да се заключи, че сортирането на селекция никога не трябва да се използва. Той не се адаптира към данните по никакъв начин (забележете, че четирите анимации по-горе се изпълняват в lockstep), така че времето за изпълнение винаги е квадратично. Въпреки това, сортирането на селекцията има свойството да минимизира броя на суаповете. В приложения, където разходите за размяна на елементи са високи, сортирането на селекцията много добре може да бъде алгоритъмът на избор.
      shell_sort:
        title: Сорт на черупката
        description: Времевата сложност на най-лошия случай зависи от последователността на нарастване. За стъпките 1 4 13 40 121 ..., което е използвано тук, времевата сложност е <span class=\"code-inline\">O(n<sup><sup>3</sup>&frasl;<sub>2</sub></sup>)</span>. За други инкременти е известно, че времевата сложност е <span class="code-inline">O(n<sup><sup>4</sup>⁄<sub>3</sub></sup>)</span> и дори <span class="code-inline">O(n·lg<sub>2</sub>(n))</span>. Не е известна нито тясната горна граница на времевата сложност, нито най-добрата последователност на нарастване. Тъй като сортирането на обвивката се основава на сортиране на вмъкване, сортирането на обвивката наследява адаптивните свойства на сортирането. Адаптацията не е толкова драматична, тъй като сортирането на обвивката изисква едно преминаване през данните за всяко увеличение, но е значително. За показаната по-горе последователност на нарастване, има <span class="code-inline">log<sub>3</sub>(n)</span> стъпки, така че времевата сложност за почти сортираните данни е <span class="code-inline">O(n·log<sub>3</sub>(n))</span> . Поради ниската си натовареност, относително проста реализация, адаптивни свойства и суб-квадратична времева сложност, сортирането на обвивката може да бъде жизнеспособна алтернатива на алгоритмите за сортиране <span class="code-inline">O(n·lg(n))</span> за някои приложения, когато данните, които трябва да се сортират, са не е много голям.
      heap_sort:
        title: Пирамидално сортиране
        description: Heapsort е лесен за изпълнение, изпълнява <span class="code-inline">O(n·lg(n))</span> на място, но не е стабилен. Първият цикъл, <span class="code-inline">Θ(n)</span> “heapify” фазата, поставя масива в реда с куп. Вторият цикъл, <span class="code-inline">O(n·lg(n))</span> фаза &quot;сортиране&quot;, многократно извлича максимума и възстановява реда с куп. Функцията мивка се записва рекурсивно за яснота. По този начин, както е показано, кодът изисква <span class="code-inline">Θ(lg(n))</span> пространство за рекурсивния стек на повикванията. Обаче, рекурсията на опашката в мивка() лесно се преобразува в итерация, която дава пространството <span class="code-inline">O(1)</span> . Двете фази са леко адаптивни, макар и не особено полезни. В почти сортирания случай, фазата на heapify унищожава първоначалния ред. В обратния случай, heapify фазата е възможно най-бърза, тъй като масивът започва в купчина, но след това фазата на сортиране е типична. В случая с няколкото уникални ключа, има някакво ускорение, но не толкова, колкото в сортиране на черупки или трипосочно бързо.
      merge_sort:
        title: Сортиране чрез сливане
        description: Сливането е много предсказуемо. Това прави между <span class="code-inline">0.5lg(n)</span> и <span class="code-inline">lg(n)</span> сравнения на елемент и между <span class="code-inline">lg(n)</span> и <span class="code-inline">1.5lg(n)</span> суапове за елемент. Минимумите се постигат за вече сортирани данни; средните максимуми се постигат за случайни данни. Ако използването на <span class="code-inline">Θ(n)</span> допълнително пространство е без значение, тогава сливането е отличен избор; Той е лесен за изпълнение и е единственият стабилен алгоритъм за сортиране <span class="code-inline">O(n·lg(n))</span>. Имайте предвид, че когато сортирате свързани списъци, сливането изисква само <span class="code-inline">Θ(lg(n)</span> допълнително пространство (за рекурсия). Сортирането на сливане е алгоритъм за избор при редица ситуации когато се изисква стабилност, когато се сортират свързани списъци, и когато случайно Достъпът е много по-скъп от секвенционалния достъп (например външно сортиране на лента). За последната стъпка от алгоритъма съществуват линейни алгоритми за сливане на място, но те са едновременно скъпи и сложни. като например външно сортиране, когато <span class="code-inline">Θ(n)</span> допълнително пространство не е налично.
      quick_sort:
        title: Бързо сортиране
        description: Когато внимателно се изпълни, бързият режим е стабилен и има ниски режийни разходи. Когато не е необходим стабилен сортиране, бързото сортиране е отличен сорт с общо предназначение - въпреки че триизмерната версия на разделяне трябва винаги да се използва вместо това. Показаният по-горе двупосочен код за разделяне е написан за яснота, а не за оптимална производителност; той показва лоша местност и, критично, показва <span class="code-inline">O(n<sup>2</sup>)</span> време, когато има няколко уникални ключа. По-ефективен и стабилен двупосочен метод на разделяне е даден в Quicksort е Optimal от Robert Sedgewick и Jon Bentley. Здравото разделяне произвежда балансирана рекурсия, когато има много стойности, равни на осите, което дава вероятностни гаранции за <span class="code-inline">O(n·lg(n))</span> време и <span class="code-inline">O(lg(n))</span> пространство за всички входове. Когато и двата подреда се изпълняват рекурсивно, бързото сортиране изисква <span class="code-inline">O(n)</span> допълнително пространство за рекурсивния стек в най-лошия случай, когато рекурсията не е балансирана. Това е изключително малко вероятно да се случи, но може да бъде избегнато чрез сортиране на по-малката под-масив рекурсивно първо; Вторият поддиректен тип е рекурсивно повикване, което може да бъде направено с итерация. С тази оптимизация алгоритъмът използва <span class="code-inline">O(lg(n))</span> допълнително пространство в най-лошия случай.
      other: Други алгоритми за сортиране
      additional: Допълнително четене
    searching:
      title: Търсене
      binary_search:
        title: Двоично търсене
        description: В компютърните науки двоичното търсене, известно също като търсене на полуинтервал или логаритмично търсене, е алгоритъм за търсене, който намира позицията на целева стойност в сортиран масив. Той сравнява целевата стойност със средния елемент на масива; ако те са неравномерни, половината, в която мишената не може да лъже, се елиминира и търсенето продължава по останалата половина, докато успее.
      knuth_moriss_pratt_search:
        title: Търсене на Кнут-Морис-Прат
        description: В компютърните науки алгоритъмът за търсене на низ от Knuth – Morris – Pratt (или KMP алгоритъм) търси появата на &quot;дума&quot; W в главен &quot;текстов низ&quot; S, като използва наблюдението, че когато възникне несъответствие, самата дума въплъщава достатъчно информация, за да се определи къде може да започне следващото съвпадение, като по този начин се заобикаля преразглеждането на предварително съвпадащи символи.
      other:
        title: Други алгоритми за търсене
        dijkstra: Алгоритъмът на Дейкстра
        kruskal: Алгоритъмът на Крускал
        longest: Най-дълго нарастващата последователност
        telephone_number: Телефонен номер за думи
    credits: 'Кодът и статиите бяха взети от ресурси:'
  data_structures:
    title: Структури на данни
    description: В компютърната наука големият нотация O се използва за класифициране на алгоритмите по начина, по който те реагират на промените във входящия размер, като например как времето на обработка на алгоритъма се променя, тъй като размерът на проблема става изключително голям. В аналитичната теория на числата тя се използва за оценка на &quot;извършената грешка&quot;, като се замества асимптотичния размер на аритметичната функция със стойността, която тя приема при голям краен аргумент. Известен пример е проблемът за оценка на остатъчния член в теоремата за простото число.
    axioms:
      title: Основни аксиоми на структури от данни
      description: Времето за изпълнение на общото време за изпълнение на езика е дадено от набор от аксиоми, които сега ще постулираме.
      fetch_store:
        title: Извличане и съхраняване на времето
        description1: Времето, необходимо за изтегляне на препратка към обект от паметта, е константа, <span class="code-inline">T_fetch</span> , а времето, необходимо за съхраняване на препратка към обект в паметта, е константа, <span class="code-inline">T_store</span>
        description2: Според Axiom, операторът за присвояване има време на работа <span class="code-inline">T_fetch + T_store</span> . Това означава, че времето, необходимо за извличане на препратката на обект от променлива x, е <span class="code-inline">T_fetch</span> и времето, необходимо за съхраняване на тази референция на обекта в променливата y е <span class="code-inline">T_store</span>.
        description3: Също има време за изпълнение <span class="code-inline">T_fetch + T_store</span>. За да разберем защо това трябва да се случи, вземете предвид, че константата <span class="code-inline">1</span> нарича Fixnum обект със стойност едно. Следователно можем да очакваме, че цената на извличане на препратката към обект с име 1 е същата като тази за извличане на препратка към друг обект.
      elementary_operations:
        title: Време за елементарни аритметични операции
        description1: Времето, необходимо за извършване на елементарни аритметични операции, като събиране, изваждане, умножение, деление и сравнение, са константи. Тези времена са означени съответно с <span class="code-inline">T_ +, T_-, T_ /, T_ *, T_ &lt;</span>.
        description2: Можем да определим времето на изявление, подобно на <span class="code-inline">2 * T_fetch + T_ + + T_store</span> . Това е така, защото трябва да извличаме две референции на обекти от променливите y и 1; изпълни добавянето, давайки нов обект, чиято стойност е сумата; и, съхранявайте препратка към новия обект в променливата y.
        description3: Ще приемем, че алтернативата изисква точно същото време на работа като първоначалното изявление.
      call_method:
        title: Време за метод на повикванията
        description1: Времето, необходимо за извикване на метод, е константа, <span class="code-inline">T_call</span> , а времето, необходимо за връщане от метод, е константа, <span class="code-inline">T_return</span> Обосновката за натоварване, свързано с преминаване на параметър, същото като времето за съхранение на обект, е, че преминаването на аргумент е концептуално същото като присвояване на действителната стойност на параметъра към формалния параметър на метода.
        description2: Според Axiom, времето за изпълнение на оператора ще бъде <span class="code-inline">T_fetch + 2 * T_store + T_call + T_f(x)</span>, където <span class="code-inline">T_f (x)</span> е времето за работа на метод f за вход x. Първият от двата магазина се дължи на преминаването на параметъра x към метода f; втората възниква от присвояването на променливата y.
      calculating:
        title: Време за изчисление
        description1: Времето, необходимо за изчислението на адреса, подразбирано от операция за абонамент на масив, например <span class="code-inline">a[i]</span>, е константа, <span class="code-inline">T_ []</span>. Това време не включва времето за изчисляване на индексното изразяване, нито включва времето за достъп до елемента на масива.
        description2: Това е <span class="code-inline">3 * T_fetch</span>. Необходими са три извличания на операнди - първият, който извлича препратка към обект на масив a; вторият да извлича препратка към индексния обект i; и третата да донесе препратка към елемента на масив <span class="code-inline">a[i]</span>.
      object:
        title: Време за създаване на обект
        description1: Времето, необходимо за създаване на нов обект на клас, е константа, <span class="code-inline">T_new</span>. Това време не включва времето, необходимо за инициализиране на обекта. Чрез прилагане на Аксиоми можем да определим, че времето на изпълнение на изявлението.
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call + T_fixnum_init</span> , където <span class="code-inline">T_fixnum_init</span> е времето за изпълнение на инициализиращия метод на класа Fixnum.
      example:
        title: Пример
        description: В този раздел ще приложим Аксиоми, анализът на времето за изпълнение на програмата, за да изчислим следното просто аритметично серийно сумиране.
    implementations:
      title: Изпълнение
      stack:
        title: Купчина
        description: Стекът е братът на опашката. Той имитира реалния живот (например хартия). Това е FILO (първи в последния изход), така че когато елементите се извличат от стека, те се връщат в обратната посока на реда, в който са били добавени. Отново, Ruby Arrays осигуряват перфектен контейнер. Както и при опашката, тя може да бъде приложена и чрез свързан списък.
        as_array: Стек като масив
        as_linked_list: Стек като свързан списък
      queue:
        title: Опашка
        description: Опашката е проста структура, базирана на контейнери, която имитира опашка в реалния живот (напр. Чакане на опашка в банката). Това е FIFO (first-in-first-out), което означава, че когато извличате елементи от опашката, те се връщат в реда, в който са въвели. Ruby Arrays осигуряват методи, които правят реализацията на Queue тривиално лесна, но като се назовават по подходящ начин и се съдържат в удобен клас, си струва да се видят, че са реализирани и защото други структури ще наследят от това. Може да се извърши алтернативно изпълнение, като се използва свързан списък.
        as_array: Опашка като масив
        as_linked_list: Опашка като свързан списък
      deque:
        title: Deque
        description: Deque е опашка, която позволява добавяне и премахване на елементи от двата края.
        as_array: И като масив
        as_linked_list: Заглавие като свързан
      singly_linked_list:
        title: Единно свързан списък
        description: Единично свързаните списъци съдържат възли, които имат поле за данни, както и &quot;следващо&quot; поле, което сочи към следващия възел в линията на възлите. Операциите, които могат да се извършват на отделно свързани списъци, включват вмъкване, изтриване и преливане.
      doubly_linked_list:
        title: Двойно свързан списък
        description: В двойно свързан списък, всеки елемент от списъка съдържа две препратки - един към неговия приемник и един към неговия предшественик.
      ordered_list:
        title: Поръчан списък
        description: Подреденият списък е списък, в който редът на елементите е значителен. Въпреки това, елементите в подредени списъци не са непременно сортирани. Следователно е възможно да се промени реда на елементите и все още да има валиден подреден списък.
        as_array: Подредени като масив
      hash_table:
        title: Хеш таблица
        description: Хеш таблицата е контейнер за търсене. Като такъв, той осигурява методи за поставяне на обект в контейнера, намиране на обект в контейнера и отстраняване на обект от контейнера.
      binary_tree:
        title: Двоично дърво
        description: Двоичното дърво е дърво, в което всеки възел може да има максимум две деца. Децата са определени наляво и надясно.
      binary_search_tree:
        title: Двоично дърво за търсене
        description: В компютърната наука, двоичните дървета за търсене (BST), понякога наричани подредени или подредени двоични дървета, са специален вид контейнери; структури от данни, които съхраняват &quot;елементи&quot; (като номера, имена и т.н.) в паметта. Те позволяват бързо търсене, добавяне и премахване на елементи и могат да се използват за реализиране на динамични набори от елементи или таблици за търсене, които позволяват намирането на елемент по неговия ключ (например, намирането на телефонния номер на човек по име)
      b_tree:
        title: B-дърво
        description: В компютърните науки, B-дървото е самобалансираща се дървовидна структура, която съхранява сортираните данни и позволява търсене, последователен достъп, вмъкване и изтриване в логаритмично време. B-дървото е обобщение на двоично дърво за търсене в това, че един възел може да има повече от две деца (за разлика от самобалансиращите се двоични дървета за търсене, B-дървото е оптимизирано за системи, които четат и пишат големи блокове данни. дърветата са добър пример за структура от данни за външна памет, която често се използва в бази данни и файлови системи.
      binary_heap:
        title: Двоичен куп
        description: Двоичното куп е пълно двоично дърво, подредено с куп, което се изпълнява с помощта на масив. В един куп най-малкият ключ се намира в корена и тъй като коренът винаги се намира в първата позиция на масива, намирането на най-малкия ключ е тривиална операция в двоичен куп.
      credits: 'Кодът и статиите бяха взети от ресурси:'
      source: Тази страница съдържа кода на Ruby от книгата &quot;Структури от данни и алгоритми с обектно-ориентирани дизайнерски модели в Ruby&quot; от Bruno R. Preiss. Авторски права (с) 2004 г. от Bruno R. Preiss, P.Eng. Всички права запазени.
  design_patterns:
    title: Модели на дизайн
    creational:
      title: Креационни модели
      description: В софтуерното инженерство, креационните дизайн модели са дизайнерски модели, които се занимават с механизмите за създаване на обекти, опитвайки се да създават обекти по начин, подходящ за ситуацията. Основната форма на създаване на обект може да доведе до проблеми при проектирането или до допълнителна сложност на дизайна. Креационните дизайнерски модели решават този проблем, като по някакъв начин контролират създаването на този обект. Креационните дизайн модели са съставени от две доминиращи идеи. Едната е капсулиране на знания за конкретните класове, които системата използва. Друг е да се крие как се създават и комбинират копия на тези конкретни класове.
      abstract_factory:
        title: Абстрактна фабрика
        description: Абстрактен фабричен модел осигурява начин за капсулиране на група от отделни фабрики, които имат обща тема, без да определят конкретните им класове. При нормална употреба клиентският софтуер създава конкретна реализация на абстрактната фабрика и след това използва общия интерфейс на фабриката за създаване на конкретни обекти, които са част от темата. Клиентът не знае (или се грижи) кои конкретни обекти получава от всяка от тези вътрешни фабрики, тъй като използва само родовите интерфейси на своите продукти. Този модел разделя детайлите от реализацията на набор от обекти от общата им употреба и разчита на състава на обекта, тъй като създаването на обект се прилага в методи, експонирани във фабричния интерфейс.
      builder:
        title: Модел на строителя
        description: Моделът на строителя е шаблон за проектиране на софтуер за създаване на обекти. За разлика от абстрактния фабричен модел и модела на фабричния метод, чието намерение е да се даде възможност за полиморфизъм, целта на модела на строителя е да намери решение на анти-модела на телескопичния конструктор. Анти-моделът на телескопичния конструктор се появява, когато увеличаването на комбинацията параметри на конструктора на обекти води до експоненциален списък на конструкторите. Вместо да се използват множество конструктори, моделът на строителя използва друг обект, строител, който получава всеки параметър за инициализация стъпка по стъпка и след това връща полученият конструиран обект наведнъж.
      factory:
        title: Фабричен модел
        description: В класово-базираното програмиране фабричният шаблон е създаден модел, който използва фабрични методи, за да се справи с проблема за създаване на обекти, без да се налага да указва точния клас на обекта, който ще бъде създаден. Това се прави чрез създаване на обекти чрез извикване на фабричен метод - или зададен в интерфейс и реализиран от детски класове, или реализиран в базов клас и евентуално заменен от производни класове - вместо чрез извикване на конструктор.
      prototype:
        title: Образец на прототип
        description: Прототипният модел е креационен модел по линия на фабриката. Номерът с прототипа е, че създавате нови обекти чрез копиране на главен обект. Променете този главен обект и всички последващи обекти, които създавате, ще се включат в живота с копие на промяната.
      singleton:
        title: Сингълтон
        description: Уверете се, че един клас има само един екземпляр и осигурява глобална точка за достъп до него. Това е полезно, когато е необходим точно един обект за координиране на действията в системата. Понякога понятието понякога се обобщава за системи, които работят по-ефективно, когато съществува само един обект, или които ограничават представянето до определен брой обекти.
      not_covered:
        title: 'Не са обхванати модели:'
        lazy: Мързелива инициализация
        multiton: Multiton
        pool: Пул обект
        resource: Придобиването на ресурси е инициализация
    structural:
      title: Структурни модели
      description: В софтуерното инженерство структурните модели на проектиране са дизайнерски модели, които улесняват дизайна, като идентифицират прост начин за реализиране на взаимоотношенията между субектите.
      adapter:
        title: Модел на адаптера
        description: В софтуерното инженерство, моделът на адаптера е модел на софтуерен дизайн, който позволява интерфейсът на съществуващ клас да се използва като друг интерфейс. Често се използва, за да накара съществуващите класове да работят с другите, без да променят техния изходен код.
      composite:
        title: Композитен модел
        description: Съставният модел на проектиране е структурен модел, използван за представяне на обекти, които имат йерархична дървовидна структура. Тя позволява еднакво третиране както на отделните листови възли, така и на клонове, съставени от много възли.
      decorator:
        title: Декоратор
        description: В обектно-ориентираното програмиране декораторният модел (известен също като Wrapper, алтернативно име, споделен с модела на адаптера) е дизайн модел, който позволява поведението да бъде добавено към отделен обект, или статично или динамично, без да се засяга поведението на други обекти от същия клас. Декораторният модел често е полезен за спазването на принципа за единна отговорност, тъй като позволява функционалността да бъде разделена между класове с уникални области на загриженост.
      facade:
        title: Фасаден модел
        description: Дизайнът на фасада често се използва, когато системата е много сложна или трудна за разбиране, защото системата има голям брой взаимозависими класове или не е достъпен изходният код. Този модел скрива сложността на по-голямата система и осигурява по-прост интерфейс на клиента. Обикновено включва единичен клас обвивка, който съдържа набор от членове, изисквани от клиента. Тези членове влизат в системата от името на клиента на фасадата и скриват детайлите по изпълнението.
      flyweight:
        title: Шаблон за мухи
        description: В компютърното програмиране мухи това е модел на софтуерен дизайн. Мухите е обект, който минимизира използването на паметта, като споделя възможно най-много данни с други подобни обекти; това е начин да се използват обекти в големи количества, когато простото многократно представяне ще използва неприемливо количество памет. Често някои части от състоянието на обекта могат да се споделят и е обичайна практика те да се задържат във външни структури от данни и да се предават временно на обектите с мулти тегло, когато се използват.
      proxy:
        title: Модел на прокси
        description: 'Прокси, в най-общата си форма, е клас, функциониращ като интерфейс към нещо друго. Проксито може да се свързва с всичко: мрежова връзка, голям обект в паметта, файл или друг ресурс, който е скъп или невъзможно да се дублира. Накратко, прокси е обвиващ или агентски обект, който се извиква от клиента за достъп до реалния обслужващ обект зад кулисите. Използването на прокси сървъра може просто да препраща към реалния обект или може да осигури допълнителна логика. В прокси може да бъде предоставена допълнителна функционалност, например кеширане, когато операциите върху реалния обект са ресурсоемки, или проверка на предварителните условия, преди операциите по реалния обект да бъдат извикани. За клиента, използването на прокси обект е подобно на използването на реалния обект, тъй като и двете реализират един и същ интерфейс.'
      protection_proxy:
        title: Защитен прокси
        description: Защитен прокси. Работите ли на MNC? Ако е така, може да сме наясно с прокси сървъра, който ни осигурява интернет чрез ограничаване на достъпа до някакъв вид уебсайтове като обществена електронна поща, социални мрежи, съхранение на данни и т.н. предоставят само уеб страници, свързани с работата. Прокси сървър прави тази работа. Това е тип дизайн на прокси
      virtual_proxy:
        title: Виртуален прокси
        description: Виртуален прокси. Вместо сложен или тежък обект, използвайте скелетно представяне. Когато основният образ е огромен по размер, просто го представете с помощта на виртуален прокси обект и натоварването по заявка на реалния обект. Знаете, че реалният обект е скъп от гледна точка на инстанцирането и затова без реалната нужда няма да използваме реалния обект. Докато възникне необходимост, ще използваме виртуалния прокси.
      remote_proxy:
        title: Отдалечен прокси сървър
        description: Отдалечен прокси сървър. В общуването на разпределени обекти локалният обект представлява отдалечен обект (който принадлежи на различно адресно пространство). Локалният обект е прокси за отдалечения обект, а извикването на метода на локалния обект води до извикване на отдалечен метод на отдалечения обект. Помислете за изпълнението на ATM, той ще съдържа прокси обекти за банкова информация, която съществува в отдалечения сървър.
      not_covered:
        title: 'Не са обхванати модели:'
        callback: Анотирано обратно извикване
        bridge: мост
        data_bus: Шина за данни
        role: Ролеви обект
    behavioral:
      title: Поведенчески модели
      description: В софтуерното инженерство моделите на поведенчески дизайн са дизайнерски модели, които идентифицират общите комуникационни модели между обектите и реализират тези модели. По този начин тези модели увеличават гъвкавостта при осъществяването на тази комуникация.
      chain_of_responsobility:
        title: Модел на веригата на отговорност
        description: В обектно-ориентирания дизайн, моделът на веригата на отговорност е модел на проектиране, състоящ се от източник на командни обекти и серия от обработващи обекти. Всеки обработващ обект съдържа логика, която определя типовете на командните обекти, с които може да се справи; останалите се предават на следващия обработващ обект във веригата. Съществува и механизъм за добавяне на нови обекти за обработка до края на тази верига.
      command:
        title: Команден модел
        description: Командният модел е модел на дизайн на поведението, използван за съхраняване на информацията, необходима за набиране на методи в бъдеще. Командата е просто набор от действия, обвити в обект. С руби можем да използваме Procs, за да направим същото, без да е необходимо да създаваме отделен обект. Това е добър вариант, когато действието е просто и не изисква запаметяване на информация за състоянието, в противен случай командният клас е най-добрият вариант.
      interpreter:
        title: Модел на интерпретатора
        description: При компютърното програмиране моделът на интерпретатора е модел на проектиране, който определя как да се оценяват изреченията на даден език. Основната идея е да има клас за всеки символ (терминал или нетерминал) на специализиран компютърен език. Синтаксичното дърво на изречение в езика е инстанция на композитния модел и се използва за оценка (интерпретиране) на изречението за клиент.
      iterator:
        title: Итератор
        description: Шаблонът за проектиране на итератори осигурява последователен достъп до елементи в контейнер, без да се излага как действително контейнерът представлява елементите. Итераторът може да се разглежда като подвижен указател, който позволява достъп до елементи, капсулирани в контейнер.
      external_iterator:
        title: Външен итераторен модел
        description: 'Външен итератор: Итерационната логика се съдържа в отделен клас. Класът на итерацията може да бъде обобщен, за да се справят с множество типове обекти, стига да позволяват индексиране. Необходимо е допълнителният клас да извърши действителното повторение, но те позволяват по-голяма гъвкавост, защото можете да контролирате итерацията, кои елементи се повторяват и в какъв ред.'
      internal_iterator:
        title: Вътрешен итератор
        description: 'Вътрешен итератор: цялата итерационна логика се появява вътре в общия обект. Използвайте кодов блок, за да пренесете вашата логика в агрегата, който след това призовава блока за всеки от неговите елементи.'
      mediator:
        title: Посредник модел
        description: Обикновено една програма се състои от голям брой класове. Така логиката и изчисленията се разпределят между тези класове. Въпреки това, тъй като в програмата се разработват повече класове, особено по време на поддръжката и / или рефакторинга, проблемът за комуникацията между тези класове може да стане по-сложен. Това прави програмата по-трудна за четене и поддръжка. Освен това може да се окаже трудно да се промени програмата, тъй като всяка промяна може да повлияе на кода в няколко други класа. С модела на медиатора, комуникацията между обектите се капсулира с обект медиатор. Обектите вече не комуникират директно помежду си, а комуникират чрез посредника. Това намалява зависимостите между обменяните обекти, като по този начин намалява свързването.
      momento:
        title: Момент на модел
        description: 'Моментният модел се реализира с три обекта: създател, пазач и момент. Авторът е някакъв обект, който има вътрешно състояние. Служителят ще направи нещо на инициатора, но иска да може да отмени промяната. Пазителят първо пита създателя за моментален обект. Тогава тя прави каквато и да е операция (или поредица от операции), която ще направи. За да се върнете към състоянието преди операциите, той връща моменталния обект на създателя. Самият моментен обект е непрозрачен обект (който не може или не трябва да променя служебното лице). Когато се използва този модел, трябва да се внимава, ако създателят може да промени други обекти или ресурси - моментният модел работи върху един обект.'
      observer:
        title: Образец на наблюдател
        description: Моделът на наблюдателя е модел на софтуерно проектиране, в който един обект, наречен субект, поддържа списък на своите зависими, наречени наблюдатели, и автоматично ги уведомява за всякакви промени в състоянието, обикновено чрез извикване на един от техните методи. Той се използва главно за прилагане на системи за обработка на разпределени събития. Образецът на наблюдателя също е ключова част в познатия архитектурен модел на модела-изглед-контролер (MVC). Моделът на наблюдателите е реализиран в множество библиотеки и системи за програмиране, включително почти всички инструменти на GUI.
      state:
        title: Модел на състоянието
        description: Моделът на състоянието е модел на поведенчески софтуерен дизайн, който реализира държавна машина по обектно-ориентиран начин. С модела на състоянието, държавната машина се реализира чрез прилагане на всяко отделно състояние като производен клас на интерфейса на модела на състоянието и осъществяване на преходи на състоянието чрез извикване на методи, определени от суперкласа на модела.
      strategy:
        title: Модел на стратегията
        description: Стратегията позволява алгоритъмът да варира независимо от клиентите, които го използват. Стратегията е един от моделите, включени в влиятелните книги Design Patterns от Gamma et al. които популяризираха концепцията за използване на модели за описание на дизайна на софтуера. Например, клас, който извършва валидиране на входящи данни, може да използва стратегически модел, за да избере алгоритъм за валидиране въз основа на типа данни, източника на данните, избор на потребителя или други дискриминиращи фактори. Тези фактори не са известни за всеки случай до момента на изпълнение и могат да изискват радикално различно валидиране, което да се извърши. Стратегиите за валидиране, капсулирани отделно от валидиращия обект, могат да бъдат използвани от други обекти за валидиране в различни области на системата (или дори различни системи) без дублиране на код.
      template:
        title: Шаблон на шаблонния метод
        description: В обектно-ориентираното програмиране първо се създава клас, който осигурява основните стъпки на дизайна на алгоритъма. Тези стъпки се изпълняват чрез абстрактни методи. По-късно подкласовете променят абстрактните методи за реализиране на действителни действия. Така общият алгоритъм се записва на едно място, но конкретните стъпки могат да бъдат променени от подкласовете.
      visitor:
        title: Модел на посетителя
        description: В обектно-ориентираното програмиране и софтуерното инженерство, моделът за проектиране на посетители е начин за разделяне на алгоритъм от обектна структура, върху която работи. Практически резултат от това разделяне е възможността да се добавят нови операции към съществуващите обектни структури, без да се променят тези структури. Това е един от начините да се следва принципът на отвореност / затвореност. По същество, посетителят позволява да се добавят нови виртуални функции към семейство от класове, без да се променят самите класове; вместо това човек създава клас посетител, който изпълнява всички подходящи специализации на виртуалната функция. Посетителят взема референтния номер като входен сигнал и изпълнява целта чрез двойно изпращане.
      not_covered:
        title: 'Не са обхванати модели:'
        hierarchical: Йерархичен посетител
      credits: 'Кодът и статиите бяха взети от ресурси:'
  functional_programming:
    title: Функционално програмиране
    description: 'Използването на език във функционален стил означава, че имате достъп до няколко ключови функции, изброени по-долу:'
    axioms:
      immutable: 'Непроменими стойности: след като е зададена „променлива“, тя не може да се променя. В Ruby това означава, че трябва ефективно да третирате променливи като константи.'
      side_effects: 'Няма странични ефекти: когато се предава дадена стойност, функцията трябва винаги да връща същия резултат. Това върви ръка за ръка с неизменните ценности; функцията никога не може да приеме стойност и да я промени, тъй като това би довело до страничен ефект, който е допиращ към връщането на резултата.'
      pure_functions: 'Функции от по-висок ред: това са функции, които позволяват функции като аргументи или използват функции като връщана стойност. Това е един от най-критичните характеристики на всеки функционален език.'
      applying: 'Извършване на превъртане: разрешено от функции от по-висок порядък, currying превръща функцията, която взема множество аргументи във функция, която приема един аргумент. Това върви ръка за ръка с частично приложение на функциите, което превръща функцията за множество аргументи в функция, която отнема по-малко аргументи, отколкото първоначално.'
      recursion: 'Рекурсия: цикъл чрез извикване на функция от самата себе си. Когато нямате достъп до променливи данни, рекурсията се използва за изграждане и изграждане на верижни данни. Това е така, защото цикълът не е функционална концепция, тъй като изисква променливите да се предават наоколо, за да съхранят състоянието на цикъла в даден момент.'
      lazy: 'Мързелива оценка или забавена оценка: забавяне на обработката на стойностите до момента, в който е действително необходима. Ако, като пример, имате някакъв код, който генерира списък от числа на Фибоначи с активирана ленива оценка, това всъщност няма да бъде обработено и изчислено, докато една от стойностите в резултата не се изисква от друга функция, като напр.'
    pure_functions:
      title: Чисти функции
      description: Можете да видите, че тази функция изчислява резултата само с аргументите си.
    closures:
      title: Приключване
      description: Ламбда също налага затваряне и така могат да запазят своя контекст в обектите.
    applying:
      title: Частично прилагане и носене
      description: Нека първо разберем какви са тези две различни приложения на функции. Приложението на частична функция извиква функция с някакъв брой аргументи, за да получи обратно функция, която ще отнеме много по-малко аргументи. Currying приема функция, която приема n аргументи и го разделя на n функции, които приемат един аргумент.
      proc: За да ви дадем по-ясна представа за това какво ще направи всяка от тези две неща, нека вземем един пример.
      partial: Частичното прилагане на тази функция ще се върне, ако преминем в първите два аргумента, следните вложени Procs.
      curry: <span class="code-inline">.curry</span> връща <span class="code-inline">curried</span> proc. Ако е даден опционален аргумент, той определя броя на аргументите. Извикан процес получава някои аргументи. Ако се предоставят достатъчен брой аргументи, той предава предоставените аргументи на оригиналния proc и връща резултата. В противен случай връща друг curried proc, който взема останалите аргументи.
  gotchas:
    title: Gotchas
    description1: Повечето начинаещи Ruby on Rails се вълнуват от рамката и започват да изработват приложения, без да знаят езика. И това е магията на RoR.
    description2: В един момент нещата започват да стават сериозни. Някои от тях изискват време и усилия, за да изследват мръсни тайни на Ruby on Rails, докато други пренебрегват и стават старши разработчици с почти нулево познаване на езика.
    description3: Както и да е, рано или късно, начинаещи или опитни програмисти, ние всички се сблъскваме с така наречените Ruby Gotchas - тези дребни езикови тънкости, които се крият от нашия сайт в продължение на часове на хардкор отстраняване на грешки.
    description4: Ето списък на популярните рубове и любопитни факти, които разработчиците трябва да знаят. За всеки случай има пример за объркващ и / или податлив на грешки код.
    description5: Те идват заедно с добри практики, които ще ви попречат да правите прости (но трудни за намиране) грешки и да опростите живота (и вашия поддръжник на код).
    surprising:
      title: Ruby може да бъде изненадващо
      description: Въпреки, че &quot;е проектиран да максимизира щастието на програмиста&quot;, с &quot;принципа на най-малката изненада&quot;, Ruby все още има неприятности. Тази презентация ще премине от новак тривиално gotchas, по-напреднали и объркващи gotchas.
    quotes:
      title: Не ми цитирай за това, но ...
      description: Струнната интерполация (включително специални символи като <span class="code-inline">n</span>) се проваля с <span class="code-inline">&quot;единични&quot;</span> кавички - изисква <span class="code-inline">&quot;двойни&quot;</span> кавички. Точно както в повечето езици със струйна интерполация. За да го избегнете, използвайте двойки, когато е възможно.
    twue:
      title: Това е twue! Това е twue!
      description: 'Само две неща са неверни: <span class="code-inline">false</span> и <span class="code-inline">nil</span> . Всичко останало е истинско, дори <span class="code-inline">0</span> (лъжливо в C), <span class="code-inline">&quot;&quot;</span> (невярно в JS), <span class="code-inline">[]</span> и т.н. Пътува хора от C, JS и т.н., където някои от тях са фалшиви.'
    symbols_and_strings:
      title: Дръж го в чучело или го символизирай.
      description: '<span class="code-inline">Symbol!</span> Дори и да е същото при отпечатване. Не забравяйте кой да използвате за args. В идеалния случай, вземете и и използвайте това, което метод очаква: &quot;Бъдете либерални в това, което приемате, и консервативни в това, което изпращате.&quot; Закон на Постел.'
    string_or_nothing:
      title: String ... или нищо!
    constants:
      title: Константите не са
      description: Първоначалното главно означава постоянна, в Ruby. Опитайте се да промените константата. Ooooh получавате ВНИМАНИЕ! BFD. Дори замразяването не работи за Fixnums. Той работи за масиви (нещо като) и повечето други обекти ... каза той предвещаващ.
    equals:
      title: Някои са по-равни от другите
      description: <span class="code-inline">==</span> е обичайната същата стойност, <span class="code-inline">.eql?</span> е стойност и клас (1 е Fixnum, 1.0 е Float), <span class="code-inline">.equal?</span> е същият обект. Това всъщност е много по-зле.
    operations:
      title: "&gt; ===! = ==!"
      description: <span class="code-inline">===</span> е &quot;равенство на случая&quot;, както е в случая. По-добро име може да е <span class="code-inline">.includes?</span> или претоварване <span class="code-inline">.</span> , Отново, това всъщност е много по-опасно; вижте документите за клас Object. Взима хора от езици, където <span class="code-inline">===</span> е или идентичност на обекта или същата стойност и клас.
    priority:
      title: and != &amp;&amp;, or != ||
      description: '<span class="code-inline">&amp;&amp;</span> има по-висок приоритет от <span class="code-inline">=</span> , така че <span class="code-inline">x = true &amp;&amp; false</span> означава <span class="code-inline">x = (true &amp;&amp; false)</span> и има по-нисък приоритет, така че <span class="code-inline">x = true и false</span> означава <span class="code-inline">(x = true) и false</span> . Ръководство за стил Ruby: Използвайте <span class="code-inline">&amp;&amp;, ||</span> за булеви изрази <span class="code-inline">and, or</span> за поток на управление.'
    sensitive:
      title: Не бъдете толкова чувствителни!
      description: Пространството нечувствително? НЕ ВИНАГИ! Парсер смята, че това е израз, като един арг, но <span class="code-inline">(1, 2)</span> не е валиден Ruby израз! (Всички работи добре с 1 аргумент).
      usage: >
        С няколко аргумента:
        <br/>
        - Никакви дупки, няма проблем.
        <br/>
        - Родители без пространство, ОК.
        <br/>
        - Паренс и пространство, НЕ!'
      methods: '<span class="code-inline">method / num</span> е unended regex или string! Ruby смята, че даваш аргумент на метода. Общ принцип: използвайте BALANCED whitespace; и двете страни.'
      arguments: '<span class="code-inline">one -2</span> прави Ruby мисълта, че даваш аргумент <span class="code-inline">-2</span> на метод едно. Същото е за <span class="code-inline">+2</span> или дори <span class="code-inline">* 2</span> . Отново: използвайте BALANCED whitespace, от двете страни или нито едно от двете.'
      stubby: "&quot;Stabby&quot; lambdas (1.9+) Скоби опционално Space преди след args без родители, OK. Пространство след родители, добре. Отново, пространство пред родителите, НЕ! АКТУАЛИЗАЦИЯ: Фиксирана в 2.0!"
    onto:
      title: Yer @ on!
      description: 'Голата стойност става временна локална променлива! Решение: запомнете <span class="code-inline">@!</span> (Или &quot;самостоятелно&quot;. Или използвайте <span class="code-inline">attr_writer, attr_accessor</span> .) Взима хора от Java / C ++, не толкова Python (който също се нуждае от &quot;self&quot;). - Продължаваш да използваш тази променлива. Не мисля, че това означава това, което мислиш, че означава. Не Иниго Монтоя.'
    variables:
      title: Внимавай, това е @@!
      description: Виж какво е пълното празно място? Ние не променихме родителския <span class="code-inline">@@value</span> преди да я проверим, нито пък детето! Или ние? <span class="code-inline">@@variables</span> се споделят с подкласове - не само, че съществуват, но и самите променливи! Декларирането на  детето <span class="code-inline">@@value</span> променило родителската стойност, като включи и промененото Child&#39;s.ut на родителя, това е @@!
    initialize:
      title: С init (ialize) или без него
      description: Инициализацията на родителите се изпълнява автоматично, само ако детето няма такава. Иначе, родителите трябва да бъдат извикани, за да работят.
    superman:
      title: Супермен срещу Невидимия човек
      description: '<span class="code-inline">super</span> с no-arg списък изпраща това, което повикващия получи <span class="code-inline">super</span> с явни аргументи изпраща тези аргументи да изпращат NO аргументи, използвайте празни parens: <span class="code-inline">super()</span> .'
    regexp:
      title: Кога ще свърши? (Или започнете?)
      description: 'В стандартните regexps: <span class="code-inlne">^</span> е начало и <span class="code-inline">$</span> е края на целия низ. Ruby&#39;s regexes по подразбиране са multiline, така че: <span class="code-inline">^</span> е начало и <span class="code-inline">$</span> е край на всяка линия! <span class="code-inline">А</span> е начало и <span class="code-inline">Z</span> е край на целия низ. (Или да включите нов ред… който е друг \ t'
    any:
      title: Какъв?
      description: '<span class="code-inline">.any?</span> не означава &quot;някакви елементи?&quot;! С блок: &quot;Дали някой прави блока истински?&quot;. Без: &quot;има ли някаква истина?&quot; Има скрит блок: <span class="code-inline">{ | element | element }</span> .'
    undef:
      title: "(Un)Def Leppard"
      description: Променливите, обявени в блокове, предавани на итератори (например, времена или всяка), са неопределени в горната част на всяка итерация! Итераторите извикват блока многократно, така че vars са извън обхвата отново след всяко повикване. Вградените контурни конструкции (напр., Докато или за) са ОК. (Или обявете преди блока.)
    freeze:
      title: Замразяване (Ar)ray
      description: Замразяването на масив (или хеш) го замразява, а не елементите, които съдържа. Струни могат да се променят на място. По този начин можете да модифицирате даден слот в замразен масив от низове.
    one_is_one:
      title: 1 е 1 … и все повече ще бъде така!
      description: 'Смяната на Fixnum на нова стойност означава нов обект. Те не могат да бъдат променени на място! Така че, не може да се модифицира замразен масив от Fixnums. (Fixnums и Integers нямат bang-методи за демонстрация). BTW: <span class="code-inline">object_id</span> на Fixnum е <span class="code-inline">value * 2 + 1</span>'
    bang:
      title: "(to! || ! to!) == ?" 
      description: Ударът маркира метода като опасен. Защо? Често, може да модифицира приемника, срещу немодираща версия, която не е взет. НЕ ОТПУСКАЙТЕ ВЪРХУ ВРЪЩАНЕТО НА СЪЩАТА СТОЙНОСТ, КАТО НЕБАНГОВА ВЕРСИЯ! Много се връщат нула, ако не е необходима промяна!
    array:
      title: Масив от Нови Гочас
      description: Стойността по подразбиране, зададена като обект, е един и същ обект за всеки слот! Mutating едно мутира по подразбиране за всички. Първоначалната стойност, дадена като блок, се оценява отделно за всеки слот. Използвайте това, за да създадете нови обекти за всеки.
    hash:
      title: Осъществяване на хеш
      description: 'Предимно същият проблем (и решение) като масиви. ПОВЕЧЕ GOTCHAS: създава нов обект във всеки достъп до празен слот! Може да създаде прекомерен брой нови обекти; руини, които проверяват &quot;реално&quot; съдържание или брой (проверка за нула, размер и т.н.).'
    rescue:
      title: Спаси ме, хвърли линия, ще се опитам да го хвана!
      description: В Ruby, хвърлят и улов не са за изключения! Те са усъвършенстван контрол на потока, за да излезете от дълбоко гнездо. Ruby използва рейз и спасяване за изключения.
    to_str:
      title: to_s VS to_str
      description: '<span class="code-inline">to_s</span> се дефинира на всеки обект и винаги ще връща нещо. <span class="code-inline">to_str</span> е дефиниран само за обекти, които са подобни на низ. Например, <span class="code-inline">Symbol</span> има <span class="code-inline">to_str</span>, но <span class="code-inline">Array</span> не го прави. По този начин можете да използвате <span class="code-inline">obj.respond_to?(:to_str)</span> вместо нещо като <span class="code-inline">obj.is_a?(String)</span>, ако искате да се възползвате от <span class="code-inline">obj.is_a?(String)</span> на патици, без да се притеснявате дали класът, с който работите, е подклас от <span class="code-inline">String</span> или не.'
    missing:
      title: Трябва да координирате method_missing и respond_to_missing?
      description: 'Когато пренебрегвате <span class="code-inline">method_missing</span> , не забравяйте да замените <span class="code-inline">respond_to_missing?</span> също. Когато използвате method_missing за връщане на обект в извикване на метод, винаги се уверете, че сте предефинирали respond_to_missing ?. Ако не го направите, нищо няма да се счупи на пръв поглед, но в крайна сметка ще срещнете проблеми. Помислете за този клас:'
      respond_to: 'Много код (скъпоценни камъни или ваши собствени) разчита на respond_to? (по основателна причина). Трябва ли да поправите respond_to_missing? както и:'
    exception:
      title: спасяване от StandardError, а не Exception
      description: 'Не спасявайте изключение, спасяване StandardError Преди изрично спасяване на Exception ще спаси дори и нормално невъзстановими грешки като SyntaxError, LoadError и Interrupt. Ако пропуснете квалификатора за тип изключение, Ruby ще улови само StandardError, което вероятно е това, което искате:'
    private:
      title: Частните данни не са наистина, а не изобщо методи
      description: Има начин да направим класните методи частни в Ruby, просто трябва да скочиш през някои обръчи. Err, искам да кажа използвайте синтаксиса на <span class="code-inline">class << self</span> . Тази странност тласка един екземпляр в класа ефективно да създава класови методи.
    braces:
      title: Скоби срещу до края
      description: Общата конвенция е да се използва <span class="code-inline">do .. end</span> за многоредови блокове и къдрави скоби за единични блокови линии, но има и разлика между двете, които могат да бъдат илюстрирани. Това означава, че <span class="code-inline">{}</span> има по-висок приоритет, отколкото <span class="code-inline">do .. end</span>, така че имайте това предвид, когато решавате какво искате да използвате.
    module:
      title: 'class Foo :: Bar, определен извън модула Foo, няма да види вътре Foo'
      description: Можете да мислите за всяка поява на <span class="code-inline">module Something</span>, <span class="code-inline">class Something</span> или да <span class="code-inline">def something</span> като &quot;портал&quot; в нов обхват. Когато Ruby търси дефиницията на име, което е посочено, то първо изглежда в текущия обхват (метод, клас или модул), и ако не е намерен там, където ще се върне през всяка съдържаща &quot;gateway&quot; и търсене обхвата.
    credits: 'Кодът и статиите бяха взети от ресурси:'
  meta_programming:
    title: Metaprogramming
    description: Метапрограмирането е писането на компютърни програми, които пишат или манипулират други програми (или себе си) като свои данни, или които правят част от работата по време на компилация, която иначе би била извършена по време на изпълнение. В много случаи това позволява на програмистите да се справят повече в същия период от време, колкото биха направили, за да напишат целия код ръчно, или дава на програмите по-голяма гъвкавост, за да се справят ефективно с нови ситуации без прекомпилация. Метапрограмирането е писане на код, който пише код по време на изпълнение, за да направи живота ви по-лесен.
    dynamic_dispatch:
      title: Динамично изпращане
      description: Позволява ни да изпращаме съобщения <span class="code-inline">subject.public_send(message, *arguments)</span>
    dynamic_method:
      title: Динамичен метод
      description: 'Позволява ни динамично да създаваме методи <span class="code-inline">define_method :method_name { block that becomes method body }</span>'
    ghost_methods:
      title: Призрачни методи
      description: Улавяне на &quot;Ghost Methods&quot; и препращането им към друг метод Докато евентуално се добавя логика около повикването. Използва <span class="code-inline">метода</span>
    dynamic_proxies:
      title: Динамични прокси
      description: 'Например, можете да предоставите въображаеми методи, като използвате <span class="code-inline">method_missing</span> за анализиране на входящото съобщение (напр. <span class="code-inline">get_name</span> , <span class="code-inline">get_age</span> ) и за делегиране на друг метод, като <span class="code-inline">get (: data_type)</span> където <span class="code-inline">: data_type</span> е <span class="code-inline">: name</span> или <span class="code-inline">: age</span> .'
      more: Ако (след анализ) откриете проблем с производителността с помощта на <span class="code-inline">method_missing,</span> можете да използвате техниката &quot;Dynamic Method&quot;, за да създадете реален метод, след като съобщението е получено от `method_missing` за първи път.
  solid_principles:
    good: Добре!
    bad: Лошо!
    title: Твърди принципи
    description: В компютърното програмиране, SOLID (единична отговорност, Open-closed, Liskov подмяна, интерфейс сегрегация и инверсия на зависимостта) е мнемоничен акроним, въведен от Майкъл Feathers за &quot;Първите Пет Принципа&quot;, наречен от Robert C. Martin в началото на 2000-те години. за пет основни принципа на обектно-ориентираното програмиране и проектиране. Намерението е тези принципи, когато се прилагат заедно, да направят по-вероятно, че програмист ще създаде система, която е лесна за поддържане и разширяване с течение на времето. Принципите на SOLID са насоки, които могат да се прилагат по време на работа със софтуера за премахване на миризми на код, като накара програмиста да рефакторира изходния код на софтуера, докато не бъде четлив и разширяем. Той е част от цялостна стратегия за гъвкава и адаптивна разработка на софтуер.
    single:
      title: Принцип на единната отговорност
      description: Принципът на единната отговорност е най-абстрактен от групата. Той помага да се запазят малките класове и методи и да се поддържат. В допълнение към запазването на малките и фокусирани класове, те също така ги правят по-лесни за разбиране. Фактът, че можем да идентифицираме множество причини за промяна, показва нарушение на Принципа на единната отговорност.
    open_close:
      title: Отворен / затворен принцип
      description: Принципът Open / Closed гласи, че класовете или методите трябва да бъдат отворени за разширение, но затворени за модификация. Това ни казва, че трябва да се стремим към модулни проекти, които да ни позволят да променим поведението на системата, без да правим промени в самите класове. Това обикновено се постига чрез използването на модели като модела на стратегията.
      after: С този рефакторинг сме направили възможно добавянето на нови парсери, без да се променя код. Всяко допълнително поведение ще изисква само добавянето на нов манипулатор. Това прави нашия FileParser за многократно използване и в много случаи ще ни държи в съответствие с принципа за единна отговорност, като ни насърчава да създаваме по-малки фокусирани класове.
    liskov:
      title: Принцип на заместване на Лисков
      description: Принципът на Лисков е най-трудният за разбиране. Принципът гласи, че трябва да можете да замените всички случаи на родителски клас с инстанция на едно от неговите деца, без да създавате неочаквано или неправилно поведение.
    segregation:
      title: Принцип на инверсия на зависимост
      description: 'Принципът гласи, че клиентът не трябва да бъде принуден да зависи от методите, които не използва. В този пример има класове Компютър, Програмист и Техник. И двамата програмисти и техници използват компютъра по различен начин. Програмистът използва компютъра за писане, но техникът знае как да смени твърдия диск на компютъра. Какъв принцип на интерфейс сегрегация (ISP) налага, че един клас не трябва да зависи от методите, които не използва. В нашия случай, програмистът е ненужно свързан с метода Computer # change_hard_drive, защото той не го използва, но промените в състоянието, които този метод налага, могат да повлияят на програмиста. Нека рефакторираме кода, за да спазваме LSP.'
      after: След този рефактор техникът използва различен обект от типа ComputerInternals, който е изолиран от състоянието на компютъра. Състоянието на обекта Компютър може да бъде повлияно от Програмиста, но промените няма да повлияят на Техника по никакъв начин.
    di:
      title: Принцип на инверсия на зависимост
      description: Принципът на инверсия на зависимостта е свързан с обекти на високо ниво (мисъл бизнес логика), които не зависят от детайлите за изпълнение на ниско ниво (търсене на база данни и IO). Това може да бъде постигнато с въвеждане на патица и Принцип на инверсия на зависимост. Често този модел се използва за постигане на отворения / затворен принцип, който обсъдихме по-горе. Всъщност дори можем да използваме същия пример като демонстрация на този принцип. Сега има клас на форматиране, но аз съм го закодирал в класа Report, като по този начин създавам зависимост от Отчета към JSONFormatter. Тъй като Докладът е по-абстрактна (високо ниво) концепция от JSONFormatter, ние ефективно прекъсваме DIP.
      after: По този начин Докладът не зависи от JSONFormatter и може да използва всякакъв вид форматиращо устройство, което има метод, наречен формат (това е познато като типизиране на патица). Друго нещо, което трябва да се отбележи, е, че отново използвахме инжектиране на зависимост, за да решим проблема. Тази техника е много мощна, когато целта ни е да разделим обекти, и въпреки че има същите инициали като принципа на инверсията на зависимостта (спрямо модела на инжектиране на зависимостта), те са напълно различни понятия.
  threads:
    example: Пример
    title: Теми
    description: 'Забележка за паралелизъм и паралелност: Основната разлика между използването на процеси спрямо нишките е начинът, по който се обработва паметта. На високо ниво, процесите копират памет, докато нишките споделят паметта. Това прави процеса по-бавен от хвърляне на хайвер и води до процеси, които консумират повече ресурси, след като веднъж са стартирани. Като цяло, нишките имат по-малко режийни от процесите. Този интерфейсен API е Ruby API. Намекнах, че различните изпълнения на Ruby имат различно поведение, което се основава на нишките.'
    green:
      title: Зелени конци
      description: Ruby 1.9 заменя зелените нишки с естествени нишки. Въпреки това, GIL все още предотвратява паралелизма. Това е казано, че едновременността е подобрена чрез по-добро планиране. Новият график прави контекстните решения по-ефективни, като по същество ги премества в отделна собствена нишка, известна като „таймер”.
    gil:
      title: GIL - Глобално заключване на интерпретаторите
      description: MRI има глобална блокировка на интерпретатора (GIL). Това е ключалка около изпълнението на Ruby кода. Това означава, че в многонишковия контекст само една нишка може да изпълни Ruby код във всеки един момент. Така че ако имате 8 нишки, работещи на 8-ядрена машина, само една нишка и едно ядро ще бъдат заети във всеки един момент. , GIL съществува, за да защити Ruby вътрешностите от расови условия, които могат да повредят данните. Има предупреждения и оптимизации, но това е същността.
      example: Този прост факт е това, което прави нишките толкова мощни, а също и това, което ги прави трудни за работа. Вече ви дадох представа защо нишките са добри; Ето една проста програма за илюстриране на трудностите им. Тук можете да видите, че имаме <span class="code-inline">10 * 10000</span> елемента в масив. Имайте предвид, че различен рубин може да покаже различен резултат. GIL съществува само в MRI рубин.
    mutex:
      title: Mutex - взаимно изпълнение
      description: Mutexes осигуряват механизъм за множество нишки за синхронизиране на достъпа до критична част от кода. С други думи, те помагат да се въведе някакъв ред и някои гаранции в света на многонишковия хаос. Името „mutex“ е съкращение за „взаимно изключване“. Ако увийте част от кода си с мутекс, гарантирате, че няма две нишки, които могат да влязат в този раздел по едно и също време. Mutexes осигуряват механизъм за множество нишки за синхронизиране на достъпа до критична част от кода. Той помага за въвеждането на някакъв ред и гаранция за света на многонишковия хаос.
      example: В тази програма, тъй като всяка нишка трябва да заключи mutex, преди да може да се придвижи към масива, има гаранция, че няма две нишки, които да изпълняват тази операция едновременно. С други думи, тази операция вече не може да бъде прекъсната, преди да бъде завършена. След като една нишка започне да се придвижва към масива, няма други нишки, които да могат да въведат тази част от кода, докато първата нишка приключи. Тази операция вече е защитена от нишки. Тук можете да видите, че имаме <span class="code-inline">10 * 10000</span> елемента в масив. Сега всички са еднакви, поради мутекс. Mutex задава същите граници за нишката. Първата нишка, която достига до този бит код, ще заключи мутекс. тогава той става собственик на този мутекс. Докато нишката на притежателя не отключи мутекс, никоя друга нишка не може да я заключи.
    fibers:
      title: Влакна
      description: Влакната са примитиви за осъществяване на лека кооперативна съвместимост в Ruby. По принцип те са средство за създаване на кодови блокове, които могат да бъдат поставени на пауза и възобновени, подобно на нишките. Основната разлика е, че те никога не са изхвърляни и че планирането трябва да се извършва от програмиста, а не от ВМ. За разлика от останалите леки модели за едновременна употреба, всяко влакно се доставя с малък 4KB стек. Това позволява на влакното да бъде спряно от дълбоко вложени функции в рамките на влакнестия блок.
    rails:
      title: Безопасност на релсите
      description: Проблемът с това е, че няма лесен начин да се каже с абсолютна сигурност дали приложението като цяло е безопасно за конци.
      global_variables: Глобалните променливи са глобални. Това означава, че те се споделят между нишките. Ако не сте били убедени, че досега не използвате глобални променливи, ето още една причина никога да не ги докосвате. Ако наистина искате да споделите нещо глобално в дадено приложение, най-вероятно ще бъдете по-добре да се обслужвате от константа (но вижте по-долу).
      class_variables: Променливи на класа. За целите на дискусията за нишките, класовите променливи не се различават много от глобалните променливи. Те се споделят по нишки по същия начин. Проблемът не е толкова в използването на променливите на класа, а в тяхното мутиране. И ако няма да мутирате променлива на класа, в много случаи константата отново е по-добър избор.
      instance_variables: Променливи на потребителския клас. Но може би сте прочели, че винаги трябва да използвате променливи на потребителски клас, вместо променливи на класа в Ruby. Е, може би би трябвало, но те са също толкова проблематични за програми с резба като променливи клас.
      memoization: 'Мемоазирането само по себе си не е въпрос за безопасност на конците. Често се използва за съхраняване на данни в променливи на класове или променливи на потребителски класове (вж. Предишните точки). Операторът <span class="code-inline">|| =</span> всъщност е две операции, така че в средата на него се случва потенциално превключване на контекста, което води до състезание между нишките. Така че, въпреки че бихте използвали само променливи на екземпляри, може да завършите с условия на състезание с memoization. Не запомняйте за променливите на класа или променливите на потребителския клас. Ако трябва да запомните нещо на ниво клас, използвайте локални променливи на нишки ( <span class="code-inline">Thread.current [: baz]</span> ). Имайте предвид обаче, че тя все още е глобална променлива.'
    config:
      title: Конфигурирайте нишките !?
      description: Извикването на този метод задава четири опции в нашата конфигурация на приложението. Нека да преминем през всяка опция и да поговорим за това, което прави.
      frameworks: 'Предварително зареждане на рамки: Първата опция @preload_frameworks прави почти това, което казва, принуждава рамката на Rails да бъде заредена с нетърпение при зареждане. Когато тази опция не е активирана, рамковите класове се зареждат лениво чрез autoload. В многонишкови среди, рамката трябва да бъде заредена с нетърпение, преди да се създадат каквито и да било теми поради проблеми с безопасността на нишките с autoload. Знаем, че зареждането на рамката не е ниско-сигурно, така че стратегията е да я заредите, преди всички нишки да са готови да обработват заявки.'
      cache: 'Класове кеширане: Опцията @cache_classes контролира дали класовете се презареждат или не. Помниш ли, когато правиш „TDD“ във вашето приложение? Вие модифицирате контролер, след това презаредете страницата, за да го тествате и да видите, че нещата се променят? Ya, това е, което тази опция контролира. Когато тази опция е невярна, както при разработката, вашите класове ще бъдат презаредени, когато бъдат променени. Без тази опция не бихме могли да направим „F5DD” (да, това е F5 Driven Development). В производството знаем, че класовете няма да бъдат модифицирани в движение, така че да вършим работата, за да разберем дали да презареждаме класове, просто губи ресурси, така че има смисъл никога да не презареждате дефинициите на класове.'
      di: 'Зареждане на зависимост: Тази опция, @dependency_loading контролира зареждането на кода, когато липсват константи. Например, контролерът се позовава на потребителския модел, но потребителската константа не е дефинирана. В този случай, ако @dependency_loading е вярно, Rails ще намери файла, който съдържа константата на потребителя, и ще зареди този файл. Вече говорихме за това как зареждането на кодове не е безопасно за нишки, така че идеята тук е да заредим рамката, след това да заредим целия потребителски код, след което да деактивираме зареждането на зависимостта. След като зареждането на зависимостта е забранено, кодът на кода и кодът на приложението трябва да се заредят, а липсващите константи просто ще вдигнат изключение, вместо да се опитват да заредят код. Ние оправдаваме деактивирането на тази опция в продукцията, защото (както беше споменато по-рано) зареждането на код не е нищо сигурно и очакваме да има цял код, натоварен, преди да могат да се обработват заявки.'
      concurrency: 'Разрешаване на паралелност: опцията @allow_concurrency контролира дали в стека се използва мидълуерът Rack :: Lock. Rack :: Lock обгръща мутекс около вашата заявка. Идеята е, че ако имате код, който не е нисък, този мутекс ще попречи на няколко нишки да изпълняват кода на вашия контролер по едно и също време. Когато нишката е безопасна! е настроен, този мидълуер се премахва и кодът на контролера може да се изпълнява паралелно.'
    credits: 'Кодът и статиите бяха взети от ресурси:'
  ruby_meister:
    title: Стани Ruby Meister
    description: В този разговор ще разгледаме дългото пътуване от начинаещ Ruby до постигане на истинско Ruby майсторство и ще се опитаме да го скъсим малко за вас, като споделим някои важни данни. А майстор Rubyist има голяма теоретична основа, разчита на обширен набор от инструменти, има дълбоко разбиране на основните ценности и принципи на Ruby и винаги усъвършенства уменията си. Може би си казваш &quot;Уау, това е доста неясно!&quot;, Но ако присъстваш на тази сесия, обещавам, че ще бъдеш просветена, развеселена и ще ти се наслади напълно! Звучи добре? Големите книги ще бъдат част от ресурсите, които бих предложил на хората да изравнят уменията си.
    video: Дългото пътуване до майсторството на Руби от Божидар Бацов.
    computer_science_fundamentals:
      title: Основи на компютърните науки
      articles:
        - name: inside_machine
          title: 'Вътре в машината: илюстрирано въведение в микропроцесорите и компютърната архитектура'
          description: Компютрите изпълняват безброй задачи, вариращи от бизнес критичните до рекреационните, но независимо от това, по различен начин могат да изглеждат и да се държат, всички те са удивително сходни в основната функция. След като разберете как работи микропроцесорът или централният процесор (CPU), ще имате твърдото схващане за основните концепции, които са в основата на всички съвременни компютри.
        - name: code
          title: 'Код: Скритият език на компютърния хардуер и софтуер'
          description: Какво правят фенерчетата, британската инвазия, черните котки и люлките с компютрите? В CODE, те ни показват находчивите начини, по които манипулираме езика и измисляме нови средства за общуване помежду си. И чрез CODE виждаме как тази находчивост и нашата човешка принуда за общуване са движили технологичните иновации от последните два века.
        - name: concrete_math
          title: 'Конкретна математика: Фондация за компютърни науки'
          description: Тази книга представя математиката, която поддържа модерното компютърно програмиране и анализа на алгоритмите. Основната цел на нейните добре известни автори е да осигурят солидна и подходяща база от математически умения - умения, необходими за решаване на сложни проблеми, за оценка на ужасяващи суми и за откриване на фини модели в данните. Той е незаменим текст и справка не само за компютърни учени - самите автори разчитат на него! - но за сериозни потребители на математиката в почти всяка дисциплина.
        - name: sicp
          title: Структура и интерпретация на компютърни програми
          description: 'Структурата и интерпретацията на компютърните програми имаха драматично въздействие върху учебните програми по компютърни науки през последното десетилетие. Това дългоочаквано преразглеждане съдържа промени в целия текст. Има нови реализации на повечето от основните програми за програмиране в книгата, включително и на преводачите и съставителите, а авторите са включили много малки промени, които отразяват техния опит в преподаването на курса в MIT от публикуването на първото издание. Въведена е нова тема, която подчертава централната роля на различните подходи за справяне с времето в изчислителните модели: обекти с състояние, паралелно програмиране, функционално програмиране и мързеливо оценяване и недетерминирано програмиране.'
        - name: design_programms
          title: 'Как да проектираме програми: Въведение в програмирането и изчисленията'
          description: Това въведение в програмирането поставя компютърните науки в основата на образованието за либерални изкуства. За разлика от други въвеждащи книги, тя се фокусира върху процеса на проектиране на програмата. Този подход насърчава различни умения - критично четене, аналитично мислене, творчески синтез и внимание към детайла - които са важни за всеки, а не само за бъдещи компютърни програмисти. Книгата излага читателите на две фундаментално нови идеи. Първо, тя представя насоки за проектиране на програми, които показват на читателя как да анализира изявлението на проблема; как да се формулират кратки цели; как да съставяме примери; как да се разработи схема на решението, базирано на анализа; как да завършите програмата; и как да тествате.
        - name: algorithm_manual
          title: Ръководството за проектиране на алгоритъм
          description: Това ново разширено и актуализирано второ издание на най-продаваната класика продължава да взема &quot;мистерията&quot; от проектирането на алгоритми и анализира тяхната ефикасност и ефективност. Разширявайки се на първото издание, книгата сега служи като основен учебник по избор за курсове за разработване на алгоритми, като същевременно запазва статута си на водещо практическо ръководство за алгоритми за програмисти, изследователи и студенти.
        - name: cormen
          title: Въведение в алгоритми, 3-то издание (MIT Press)
          description: Някои книги за алгоритми са строги, но непълни; други покриват маси от материали, но нямат строгост. Въведение в алгоритмите уникално съчетава строгост и всеобхватност. Книгата обхваща широк спектър от алгоритми в дълбочина, но прави техния дизайн и анализ достъпни за всички нива на читателите. Всяка глава е относително самостоятелна и може да се използва като единица на изследване. Алгоритмите са описани на английски и в псевдокод, проектирани да бъдат четими от всеки, който е направил малко програмиране. Обясненията са запазени елементарно, без да се жертва дълбочината на покритие или математическата строгост.
        - name: compilers
          title: 'Съставители: принципи, техники и инструменти (второ издание)'
          description: 'Съставители: Принципи, Техники и Инструменти, познати на преподаватели, студенти и разработчици по света като &quot;Дракон Книга&quot;, се предлага в ново издание. Всяка глава е напълно преработена, за да отразява развитието на софтуерното инженерство, програмните езици и компютърната архитектура, настъпили след 1986 г., когато е публикувано последното издание. Авторите, признавайки, че малко читатели ще продължат да конструират компилатор, запазват фокуса си върху по-широкия набор от проблеми, пред които е изправен софтуерният дизайн и разработката на софтуер.'
        - name: c_lang
          title: C език за програмиране, 2-ро издание
          description: Авторите представят пълното ръководство за ANSI стандартното програмиране на C език. Написана от разработчиците на C, тази нова версия помага на читателите да следват финализирания ANSI стандарт за C, като показват как да се възползвате от богатия набор от оператори на C, икономията на изразяване, подобрения поток на управление и структурите на данните. 2 / E е напълно пренаписана с допълнителни примери и задачи, за да се изясни прилагането на сложни езикови конструкции. В продължение на години C програмистите са позволили на K&amp;R да ги насочат към изграждането на добре структурирани и ефективни програми. Сега същата помощ е на разположение на работещите с ANSI компилатори. Включва подробно покритие на езика С плюс официалния справочен наръчник за езика C за по-бърза помощ със синтактични нотации, декларации, ANSI промени, правила за обхвата и списъкът продължава и продължава.
    oop:
      title: Обектно-ориентирано програмиране
      articles:
        - name: growing
          title: Нарастващ обектно-ориентиран софтуер, ръководен от тестове
          description: 'Test-Driven Development (TDD) е вече утвърдена техника за по-бързо доставяне на по-добър софтуер. TDD се основава на проста идея: Напишете тестове за вашия код, преди да напишете самия код. Тази „проста“ идея обаче изисква умения и преценка да се справят добре. Сега има практическо ръководство за TDD, което ви отвежда извън основните понятия. Въз основа на десетилетия опит в изграждането на реални системи, двама пионери на TDD показват как да позволят на тестовете да ръководят вашето развитие и да „развиват” софтуера, който е последователен, надежден и поддържан.'
        - name: domain_driven
          title: 'Дизайн, управляван от домейн: Справяне със сложността в сърцето на софтуера'
          description: Това е една сериозна книга за моделиране на домейни в дизайна на софтуера. Социалното развитие на обществото живее от една вълна в друга. ООП, шаблони, XP, TDD, CI / CD, BigData, DevOps - това е само няколко имена. Тази книга произхожда от златния век на ООП. Авторът признава, че обектно ориентираната парадигма не е единствената налична, но пристрастието към ООП / ООД е очевидно (и оправдано). Тази книга разказва как се прави моделирането на основните софтуерни компоненти “по правилния начин”.
    ruby:
      title: Познаваш ли езика
      articles:
        - name: well_grounded
          title: Добре затвореният рубист
          description: Добре заземеният рубист, второто издание, адресира както новодошлите в Ruby, така и Ruby програмистите, които искат да задълбочат разбирането си за езика. Това красиво написано и напълно ревизирано второ издание включва покритие на нови функции в Ruby 2.1, както и разширен и актуализиран обхват на изменените аспекти на езика.
        - name: programming_ruby
          title: 'Програмиране Ruby: Прагматичното ръководство на програмистите, второ издание'
          description: 'Ruby е все по-популярен, напълно обектно-ориентиран динамичен език за програмиране, приветстван от много практикуващи като най-добрия и най-полезен език, достъпен днес. Когато Ruby избухна на сцената в западния свят, прагматичните програмисти бяха там с окончателното ръководство за програмиране Ruby: Прагматичното ръководство на програмиста.'
        - name: ruby_programming
          title: 'Езикът за програмиране на Ruby: всичко, което трябва да знаете'
          description: 'Тази книга започва с урок за бързо стартиране на езика и след това обяснява езика в детайли отдолу нагоре: от лексикална и синтактична структура до типове данни до изрази и твърдения и чрез методи, блокове, ламбди, затваряния, класове и модули. Книгата включва също дълъг и задълбочен въведение в богатия API на платформата на Ruby, демонстрирайки - със силно коментирания примерен код - възможностите на Ruby за обработка на текст, манипулация с цифри, колекции, вход / изход, работа в мрежа и конкурентност. Цяла глава е посветена на метапрограмиращите възможности на Ruby.'
  interview_questions:
    title: "Въпроси за интервюта"
    description: "В този раздел се съхраняват ресурсните връзки за подготовка за четене и интервю"
    list:
      - name: "Toptal: Как да наемете велик Ruby Developer"
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: "Toptal: 21 Въпроси за интервю с Ruby"
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: "Hookops: 35+ въпроси и отговори за интервю с Ruby и Rails"
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: "Educba: 15 Най-важните въпроси и отговор на интервюто в Ruby"
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: "Ruby Garage: Как да интервюираме вашия Ruby на Rails Developer"
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: "RyanSobol: 15 въпроса по време на интервю за Ruby"
        link: "https://gist.github.com/ryansobol/5252653"
      - name: "Toptal: 9 Въпроси за интервю с Essential Ruby on Rails"
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: Какво е по-добра документация
    description: Този сайт е уеб адаптация Github хранилище <a href="https://github.com/khusnetdinov/ruby.fundamental">Ruby.Fundamental,</a> който събира много звезди и е преведен на китайски език. По-добри документи ви позволяват бързо да намерите много добри практики, които са били събрани в едно хранилище. Само ти този репо като референтен или интервю подготовка ресурс.
    oss:
      title: Благодарение на Open Source
      description: По-добро Docs е създаден по време на работа и да научите за най-добрите практики и знания за рубин, инженеринг с отворен код за приложения за уеб разработки, написани на Ruby.
      thanks: Ако по-добри документи ви помогнаха по някакъв начин, помислете дали да ни дадете звезда в <a href="https://github.com/howtohireme/ruby.fundamental">Github</a> (това ни помага да достигнем до повече разработчици) или да допринесем за нашите проекти.
