head:
  title: BetterDocs
  metatags:
    description: Βασικός προγραμματισμός με παραδείγματα ρουμπίνι και αναφορές. Καλύπτει
      τα θέματα, τις SOLID αρχές, τα σχέδια σχεδιασμού, τις δομές δεδομένων, τους
      αλγορίθμους.
    keywords: Καλύτερα docs, Ruby, Θεμελιώδεις αρχές, Βασικά στοιχεία προγραμματισμού
      του Ruby. Ruby gotchas, Λειτουργικός προγραμματισμός, Μεταπρογραμματισμός, Νήματα,
      αρχές Ruby με παραδείγματα, Σχέδια σχεδιασμού Ruby με παραδείγματα, Αλγόριθμοι
      Ruby με παραδείγματα, Δομές δεδομένων Ruby με παραδείγματα.
content:
  menu:
    open: Ανοίξτε το Μενού
    close: Κλείσιμο Μενού

sidebar:
  - title: Αλγόριθμοι
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: ΔΟΜΕΣ ΔΕΔΟΜΕΝΩΝ
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: Σχεδιαστικά πρότυπα
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: Λειτουργικός Προγραμματισμός
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: Ερωτήσεις συνέντευξης
    url: interview_questions
  - title: Metaprogramming
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: Στερεές αρχές
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: Γίνετε Ruby Meister
    url: ruby_meister
  - title: Νήματα
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config
pages:
  wiki: Διαβάστε το wiki
  credits: Πιστώσεις
  page404:
    title: Η σελίδα δεν βρέθηκε :(
    description: Η σελίδα που ζητήσατε δεν βρέθηκε.
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: Αλγόριθμοι
    complexity:
      best: Καλύτερος
      average: Μέση τιμή
      worst: Χειριστός
    sorting:
      title: Ταξινόμηση
      description: Ένας αλγόριθμος ταξινόμησης είναι ένας αλγόριθμος που τοποθετεί στοιχεία
        μιας λίστας με μια συγκεκριμένη σειρά. Οι πιο χρησιμοποιούμενες εντολές είναι
        η αριθμητική σειρά και η λεξικογραφική σειρά. Η αποτελεσματική ταξινόμηση είναι
        σημαντική για τη βελτιστοποίηση της χρήσης άλλων αλγορίθμων (όπως αλγορίθμων
        αναζήτησης και συγχώνευσης) που απαιτούν δεδομένα εισόδου να είναι σε ταξινομημένες
        λίστες. είναι επίσης συχνά χρήσιμο για κανονικοποίηση δεδομένων και για παραγωγή
        αναγνώσιμων από άνθρωπο εξόδων.
      bubble_sort:
        title: Τύπος φούσκα
        description: Το είδος φυσαλίδας έχει πολλές από τις ίδιες ιδιότητες με το είδος
          εισαγωγής, αλλά έχει ελαφρώς υψηλότερη επιβάρυνση. Στην περίπτωση των δεδομένων
          που έχουν ταξινομηθεί με σχεδόν διαχωρισμό, η τύχη των φυσαλίδων παίρνει το
          <span class="code-inline time">O (n)</span> , αλλά απαιτεί τουλάχιστον 2 περάσματα
          μέσω των δεδομένων (ενώ το είδος εισαγωγής απαιτεί κάτι περισσότερο σαν 1
          πέρασμα).
      insertion_sort:
        title: Εισαγωγή είδος
        description: Αν και είναι ένας από τους στοιχειώδεις αλγόριθμους ταξινόμησης
          με τον <span class="code-inline">O (n <sup>2</sup> )</span> χειρότερο χρόνο,
          ο τύπος εισαγωγής είναι ο αλγόριθμος επιλογής είτε όταν τα δεδομένα είναι
          σχεδόν ταξινομημένα (επειδή είναι προσαρμοστικά) είτε όταν το μέγεθος του
          προβλήματος είναι μικρό (επειδή έχει χαμηλό γενικό κόστος). Για τους λόγους
          αυτούς και επειδή είναι επίσης σταθερός, το είδος εισαγωγής χρησιμοποιείται
          συχνά ως αναδρομική βασική περίπτωση (όταν το μέγεθος του προβλήματος είναι
          μικρό) για υψηλότερους γενικούς αλγόριθμους ταξινόμησης και κατακράτησης,
          όπως συγχώνευση ή γρήγορη ταξινόμηση.
      selection_sort:
        title: Ταξινόμηση επιλογής
        description: Από τη σύγκριση που παρουσιάζεται εδώ, θα μπορούσε κανείς να συμπεράνει
          ότι το είδος επιλογής δεν πρέπει ποτέ να χρησιμοποιηθεί. Δεν προσαρμόζεται
          στα δεδομένα με οποιονδήποτε τρόπο (παρατηρήστε ότι τα τέσσερα κινούμενα σχέδια
          παραπάνω τρέχουν σε lockstep), οπότε ο χρόνος εκτέλεσης είναι πάντα τετραγωνικός.
          Ωστόσο, το είδος επιλογής έχει την ιδιότητα να ελαχιστοποιεί τον αριθμό των
          ανταλλαγών. Σε εφαρμογές όπου το κόστος ανταλλαγής αντικειμένων είναι υψηλό,
          η επιλογή μπορεί να είναι ο αλγόριθμος επιλογής.
      shell_sort:
        title: Κέλυφος είδος
        description: Η πολυπλοκότητα χειρότερης περίπτωσης της ταξινόμησης του κελύφους
          εξαρτάται από την ακολουθία αύξησης. Για τις προσαυξήσεις 1 4 13 40 121 ...,
          η οποία είναι αυτό που χρησιμοποιείται εδώ, ο χρόνος πολυπλοκότητα είναι <span
          class="code-inline">O(n<sup><sup>3</sup>/<sub>2</sub></sup>)</span>
          Για άλλες προσαυξήσεις, πολυπλοκότητα χρόνου είναι γνωστό ότι είναι <span
          class="code-inline">O(n<sup><sup>4</sup>/<sub>3</sub></sup>)</span> και
          ακόμη και <span class="code-inline">O(n·lg<sub>2</sub>(n)).</span> Ούτε
          τα σφιχτά ανώτερα όρια σχετικά με την πολυπλοκότητα του χρόνου ούτε η καλύτερη
          ακολουθία αύξησης είναι γνωστά. Επειδή το είδος του κελύφους βασίζεται στο
          είδος εισαγωγής, το είδος κελύφους κληρονομεί τις προσαρμοστικές ιδιότητες
          του είδους εισαγωγής. Η προσαρμογή δεν είναι τόσο δραματική επειδή η ταξινόμηση
          του κελύφους απαιτεί μία διέλευση από τα δεδομένα για κάθε αύξηση, αλλά είναι
          σημαντική. Για την ακολουθία αύξησης που παρουσιάζεται παραπάνω, υπάρχουν
          βήματα <span class="code-inline">log <sub>3</sub> (n)</span> , επομένως η
          χρονική πολυπλοκότητα για σχεδόν ταξινομημένα δεδομένα είναι <span class="code-inline">O
          (n·log<sub>3</sub>(n))</span> . Λόγω της χαμηλής επιβάρυνσης, της σχετικά
          απλής εφαρμογής, των προσαρμοστικών ιδιοτήτων και της υποταγιακής πολυπλοκότητας
          του χρόνου, το είδος του κελύφους μπορεί να είναι μια βιώσιμη εναλλακτική
          λύση στους αλγόριθμους ταξινόμησης <span class="code-inline">O(n·lg(n))</span>
          για ορισμένες εφαρμογές, όταν τα προς ταξινόμηση δεδομένα είναι όχι πολύ μεγάλο.
      heap_sort:
        title: Σωρός είδος
        description: Σωρός είδος είναι απλό στην εφαρμογή, εκτελεί ένα <span class="code-inline">O
          (n · lg (n))</span> είδος, αλλά δεν είναι σταθερό. Ο πρώτος βρόχος, η φάση
          <span class="code-inline">θ (n)</span> &quot;heapify&quot;, θέτει τη συστοιχία
          σε σειρά σωρών. Ο δεύτερος βρόχος, η φάση <span class="code-inline">O (n ·
          lg (n))</span> «ταξινόμησης», επαναλαμβάνει επανειλημμένα το μέγιστο και επαναφέρει
          τη σειρά σωρών. Η λειτουργία νεροχύτη γράφεται αναδρομικά για μεγαλύτερη σαφήνεια.
          Έτσι, όπως φαίνεται, ο κώδικας απαιτεί <span class="code-inline">Θ (lg (n))</span>
          χώρο για την επαναλαμβανόμενη στοίβα κλήσεων. Ωστόσο, η επαναφορά ουράς στο
          νεροχύτη () μετατρέπεται εύκολα σε επανάληψη, η οποία αποδίδει τον δεσμό <span
          class="code-inline">Ο (1)</span> . Και οι δύο φάσεις είναι ελαφρώς προσαρμοστικές,
          αν και όχι με ιδιαίτερα χρήσιμο τρόπο. Στην σχεδόν ταξινομημένη περίπτωση,
          η φάση heapify καταστρέφει την αρχική σειρά. Στην αντίστροφη περίπτωση, η
          φάση heapify είναι όσο το δυνατόν γρηγορότερη από τη στιγμή που ο πίνακας
          ξεκινάει με τη σειρά σωρών, αλλά στη συνέχεια η τυπική φάση ομαδοποίησης.
          Στις λίγες περιπτώσεις μοναδικών κλειδιών, υπάρχει κάποια επιτάχυνση, αλλά
          όχι τόσο όσο στο είδος του κελύφους ή το γρήγορο ταξίδι 3 δρόμων.
      merge_sort:
        title: Συγχώνευση είδος
        description: 'Το είδος συγχώνευσης είναι πολύ προβλέψιμο. Κάνει μεταξύ των <span
          class="code-inline">0,5lg(n)</span> και <span class="code-inline">lg(n)</span>
          συγκρίσεις ανά στοιχείο, και μεταξύ <span class="code-inline">lg(n)</span>
          και <span class="code-inline">1.5lg(n)</span> ανά στοιχείο. Τα ελάχιστα επιτυγχάνονται για ήδη ταξινομημένα δεδομένα.
          τα μέγιστα επιτυγχάνονται, κατά μέσο όρο, για τυχαία δεδομένα. Αν η χρήση
          του <span class="code-inline">Θ (n)</span> επιπλέον χώρου δεν ενδιαφέρει,
          τότε η συγχώνευση είναι μια εξαιρετική επιλογή: Είναι απλή στην εφαρμογή και
          είναι ο μόνος σταθερός αλγόριθμος ταξινόμησης <span class="code-inline">O
          (n · lg (n))</span> . Σημειώστε ότι κατά την ταξινόμηση των συνδεδεμένων λιστών,
          η συγχώνευση απαιτεί μόνο <span class="code-inline">θ (lg (n))</span> επιπλέον
          χώρο (για την επανάληψη). Η συγχώνευση είναι ο αλγόριθμος επιλογής για μια
          ποικιλία καταστάσεων: όταν απαιτείται σταθερότητα, κατά την ταξινόμηση των
          συνδεδεμένων λιστών η πρόσβαση είναι πολύ πιο ακριβή από τη διαδοχική πρόσβαση
          (για παράδειγμα, η εξωτερική ταξινόμηση σε ταινία) .Υπάρχουν γραμμικοί χρόνοι
          επί τόπου αλγόριθμοι συγχώνευσης για το τελευταίο βήμα του αλγορίθμου, αλλά
          είναι και οι δύο δαπανηροί και περίπλοκοι. όπως η εξωτερική ταξινόμηση όταν
          ο <span class="code-inline">θ (n)</span> επιπλέον χώρος δεν είναι διαθέσιμος.'
      quick_sort:
        title: Γρήγορη ταξινόμηση
        description: Όταν εφαρμόζεται προσεκτικά, το quicksort είναι γερό και έχει χαμηλή
          επιβάρυνση. Όταν δεν απαιτείται σταθερή ταξινόμηση, το quicksort είναι ένα
          εξαιρετικό είδος γενικής χρήσης - αν και θα έπρεπε να χρησιμοποιείται πάντοτε
          η 3-διαχωριστική έκδοση. Ο παραπάνω κωδικός διαχωρισμού δύο γραμμών γράφεται
          για λόγους σαφήνειας και όχι για βέλτιστη απόδοση. παρουσιάζει κακή τοποθεσία
          και, κριτικά, εμφανίζει <span class="code-inline">O (n <sup>2</sup> )</span>
          χρόνο όταν υπάρχουν λίγα μοναδικά κλειδιά. Μια πιο αποτελεσματική και ισχυρή
          μέθοδος 2-way partitioning δίνεται στο Quicksort είναι Optimal από τον Robert
          Sedgewick και τον Jon Bentley. Ο ισχυρός διαχωρισμός παράγει ισορροπημένη
          αναδρομή όταν υπάρχουν πολλές τιμές ίσες με τον άξονα, δίνοντας πιθανολογικές
          εγγυήσεις του χρόνου <span class="code-inline">O (n · lg (n))</span> και του
          <span class="code-inline">O (lg (n))</span> για όλες τις εισόδους. Με τα δύο
          υπο-είδη να εκτελούνται αναδρομικά, η γρήγορη ταξινόμηση απαιτεί <span class="code-inline">O
          (n)</span> επιπλέον χώρο για τη στοίβα ανακύκλωσης στη χειρότερη περίπτωση
          όταν η αναδρομή δεν είναι ισορροπημένη. Αυτό είναι εξαιρετικά απίθανο να συμβεί,
          αλλά μπορεί να αποφευχθεί με την ταξινόμηση της μικρότερης υπο-συστοιχίας
          αναδρομικά πρώτα. το δεύτερο είδος υπο-συστοιχιών είναι μια ουρά αναδρομική
          κλήση, η οποία μπορεί να γίνει με την επανάληψη αντί. Με αυτή τη βελτιστοποίηση,
          ο αλγόριθμος χρησιμοποιεί <span class="code-inline">O (lg (n))</span> επιπλέον
          χώρο στη χειρότερη περίπτωση.
      other: Άλλοι αλγόριθμοι ταξινόμησης
      additional: Πρόσθετη ανάγνωση
    searching:
      title: Ερευνητικός
      binary_search:
        title: Δυαδική αναζήτηση
        description: Στην επιστήμη των υπολογιστών, η δυαδική αναζήτηση, επίσης γνωστή
          ως αναζήτηση μισού διαστήματος ή λογαριθμική αναζήτηση, είναι ένας αλγόριθμος
          αναζήτησης που βρίσκει τη θέση μιας τιμής στόχου μέσα σε μια ταξινομημένη
          συστοιχία. Συγκρίνει την τιμή στόχο με το μεσαίο στοιχείο του πίνακα. αν είναι
          άνισες, το εξάμηνο στο οποίο ο στόχος δεν μπορεί να βρεθεί εξαλείφεται και
          η αναζήτηση συνεχίζεται στο υπόλοιπο μισό μέχρι να πετύχει.
      knuth_moriss_pratt_search:
        title: Αναζήτηση Knuth-Morris-Pratt
        description: Στην επιστήμη των υπολογιστών, ο αλγόριθμος αναζήτησης αλφαριθμητών
          Knuth-Morris-Pratt (ή ο αλγόριθμος KMP) αναζητά περιστατικά μιας &quot;λέξης&quot;
          W μέσα σε μια κύρια &quot;συμβολοσειρά κειμένου&quot; S χρησιμοποιώντας την
          παρατήρηση ότι όταν συμβαίνει μια αναντιστοιχία, πληροφορίες για να προσδιοριστεί
          πού θα μπορούσε να ξεκινήσει ο επόμενος αγώνας, παρακάμπτοντας έτσι την επανεξέταση
          των προηγουμένως αντιστοιχισμένων χαρακτήρων.
      other:
        title: Άλλοι αλγόριθμοι αναζήτησης
        dijkstra: Αλγόριθμος του Dijkstra
        kruskal: Ο αλγόριθμος του Kruskal
        longest: Μεγαλύτερη αυξανόμενη αλληλουχία
        telephone_number: Αριθμός τηλεφώνου σε λέξεις
    credits: 'Κωδικός και άρθρα λήφθηκαν από πόρους:'
  data_structures:
    title: ΔΟΜΕΣ ΔΕΔΟΜΕΝΩΝ
    description: Στην επιστήμη των υπολογιστών, χρησιμοποιείται μεγάλη ταξινόμηση Ο
      για την ταξινόμηση αλγορίθμων με βάση τον τρόπο με τον οποίο αντιδρούν στις αλλαγές
      στο μέγεθος της εισόδου, όπως για παράδειγμα το πώς ο χρόνος επεξεργασίας ενός
      αλγορίθμου αλλάζει καθώς το μέγεθος του προβλήματος γίνεται εξαιρετικά μεγάλο.
      Στην θεωρία του αναλυτικού αριθμού χρησιμοποιείται για να εκτιμήσει το &quot;σφάλμα
      που διαπράττεται&quot; αντικαθιστώντας το ασυμπτωτικό μέγεθος μιας αριθμητικής
      συνάρτησης με την τιμή που παίρνει σε ένα μεγάλο πεπερασμένο επιχείρημα. Ένα διάσημο
      παράδειγμα είναι το πρόβλημα της εκτίμησης του υπολοίπου όρου στο θεώρημα του
      πρώτου αριθμού.
    axioms:
      title: Βασικά αξιώματα των δομών δεδομένων
      description: Η απόδοση του χρόνου εκτέλεσης του χρόνου εκτέλεσης της κοινής γλώσσας
        δίδεται από ένα σύνολο αξιωμάτων τα οποία θα υποθέσουμε τώρα.
      fetch_store:
        title: Φέρτε και αποθηκεύστε το χρόνο
        description1: Ο χρόνος που απαιτείται για την ανάκτηση μίας αναφοράς σε ένα
          αντικείμενο από τη μνήμη είναι μια σταθερά, <span class="code-inline">T_fetch</span>
          και ο χρόνος που απαιτείται για την αποθήκευση μίας αναφοράς σε ένα αντικείμενο
          στη μνήμη είναι μια σταθερά, <span class="code-inline">T_store</span>
        description2: Σύμφωνα με το Axiom, η εντολή εκχώρησης έχει χρόνο εκτέλεσης <span
          class="code-inline">T_fetch + T_store</span> . Δηλαδή, ο χρόνος που απαιτείται
          για την ανάκτηση της αναφοράς αντικειμένου από τη μεταβλητή x είναι <span
          class="code-inline">T_fetch</span> και ο χρόνος που απαιτείται για την αποθήκευση
          αυτής της αναφοράς αντικειμένου στη μεταβλητή y είναι <span class="code-inline">T_store</span>
          .
        description3: Επίσης έχει χρόνο εκτέλεσης <span class="code-inline">T_fetch
          + T_store</span> . Για να δείτε γιατί πρέπει να συμβαίνει αυτό, θεωρήστε ότι
          η σταθερά <span class="code-inline">1</span> ορίζει ένα αντικείμενο Fixnum
          με τιμή ένα. Επομένως, μπορούμε να αναμένουμε ότι το κόστος της παραλαβής
          της αναφοράς στο αντικείμενο που ονομάζεται 1 είναι το ίδιο με το κόστος της
          ανάληψης αναφοράς σε οποιοδήποτε άλλο αντικείμενο.
      elementary_operations:
        title: Στοιχειώδης χρόνος αριθμητικών λειτουργιών
        description1: Οι χρόνοι που απαιτούνται για την εκτέλεση στοιχειωδών αριθμητικών
          λειτουργιών, όπως η προσθήκη, η αφαίρεση, ο πολλαπλασιασμός, η διαίρεση και
          η σύγκριση, είναι όλες σταθερές. Αυτοί οι χρόνοι σημειώνονται με <span class="code-inline">T_
          +, T_-, T_ /, T_ *, T_ &lt;,</span> αντίστοιχα.
        description2: Μπορούμε να προσδιορίσουμε το χρόνο μιας δήλωσης όπως το <span
          class="code-inline">2 * T_fetch + T_ + + T_store</span> . Αυτό οφείλεται στο
          γεγονός ότι πρέπει να φέρουμε δύο αναφορές αντικειμένων από τις μεταβλητές
          y και 1. εκτελέστε την προσθήκη δίνοντας ένα νέο αντικείμενο της οποίας η
          αξία είναι το άθροισμα. και, αποθηκεύστε μια αναφορά στο νέο αντικείμενο στη
          μεταβλητή y.
        description3: Υποθέτουμε ότι η εναλλακτική λύση απαιτεί ακριβώς τον ίδιο χρόνο
          εκτέλεσης με την αρχική δήλωση.
      call_method:
        title: Χρόνος μεθόδου κλήσης
        description1: Ο χρόνος που απαιτείται για την κλήση μιας μεθόδου είναι μια σταθερή
          τιμή <span class="code-inline">T_call</span> και ο χρόνος που απαιτείται για
          την επιστροφή από μια μέθοδο είναι μια σταθερά <span class="code-inline">T_return</span>
          Το σκεπτικό για την πραγματοποίηση της επιβάρυνσης που σχετίζεται με την παράμετρο
          που περνάει το ίδιο με το χρόνο αποθήκευσης μιας αναφοράς αντικειμένου είναι
          ότι η παράδοση ενός επιχειρήματος είναι εννοιολογικά η ίδια με την εκχώρηση
          της πραγματικής τιμής παραμέτρου στην τυπική παράμετρο της μεθόδου.
        description2: Σύμφωνα με το Axiom, ο χρόνος εκτέλεσης της εντολής θα είναι <span
          class="code-inline">T_fetch + 2 * T_store + T_call + T_f (x)</span> , όπου
          <span class="code-inline">T_f (x)</span> είναι ο χρόνος εκτέλεσης της μεθόδου
          f για την είσοδο x. Το πρώτο από τα δύο καταστήματα οφείλεται στο πέρασμα
          της παραμέτρου x στη μέθοδο f. το δεύτερο προκύπτει από την εκχώρηση στη μεταβλητή
          y.
      calculating:
        title: Χρόνος υπολογισμού
        description1: Ο χρόνος που απαιτείται για τον υπολογισμό της διεύθυνσης που
          συνεπάγεται μια συνδρομητική λειτουργία πίνακα, π.χ. <span class="code-inline">a[i]</span>
          , είναι μια σταθερά, <span class="code-inline">T_[]</span> . Αυτή τη φορά
          δεν περιλαμβάνεται ο χρόνος για τον υπολογισμό της έκφρασης του δείκτη, ούτε
          και ο χρόνος για την πρόσβαση στο στοιχείο του πίνακα.
        description2: 'Αυτό είναι <span class="code-inline">3 * T_fetch</span> . Απαιτούνται
          τρία λαθραρίσματα οντολογίου: το πρώτο για να παραλάβει μια αναφορά στο αντικείμενο
          πίνακα a; το δεύτερο για να παραλάβει μια αναφορά στο αντικείμενο ευρετηρίου
          i. και το τρίτο για να φέρουμε μια αναφορά στο στοιχείο πίνακα <span class="code-inline">a
          [i]</span> .'
      object:
        title: Χρόνος δημιουργίας αντικειμένου
        description1: Ο χρόνος που απαιτείται για τη δημιουργία μιας νέας παρουσίας
          αντικειμένου μιας κλάσης είναι μια σταθερά, <span class="code-inline">T_new</span>
          . Αυτή τη φορά δεν περιλαμβάνεται ο χρόνος που απαιτείται για την αρχικοποίηση
          του αντικειμένου. Με την εφαρμογή των Axioms μπορούμε να καθορίσουμε ότι ο
          χρόνος εκτέλεσης της δήλωσης.
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> , όπου <span class="code-inline">T_fixnum_init</span>
          είναι ο χρόνος εκτέλεσης της μεθόδου initialize της κλάσης Fixnum.
      example:
        title: Παράδειγμα
        description: Σε αυτή την ενότητα εφαρμόζουμε το Axioms, την ανάλυση του χρόνου
          λειτουργίας ενός προγράμματος για τον υπολογισμό της ακόλουθης αθροιστικής
          σειράς αριθμητικών σειρών.
    implementations:
      title: Εκτέλεση
      stack:
        title: Σωρός
        description: Η στοίβα είναι ο αδελφός της ουράς. Μιμείται μια στοίβα πραγματικής
          ζωής (π.χ. χαρτιού). Είναι FILO (πρώτος-τελευταίος-out), έτσι ώστε όταν τα
          αντικείμενα ανακτώνται από τη στοίβα, επιστρέφονται με την αντίστροφη σειρά
          της προσθήκης τους. Και πάλι, οι Ruby Arrays παρέχουν ένα τέλειο δοχείο. Όπως
          και με την ουρά, θα μπορούσε επίσης να εφαρμοστεί χρησιμοποιώντας μια συνδεδεμένη
          λίστα.
        as_array: Σωστή ως πίνακας
        as_linked_list: Στοίβα ως συνδεδεμένη λίστα
      queue:
        title: Ουρά
        description: Μια ουρά είναι μια απλή δομή με βάση δομή που μιμείται μια ουρά
          πραγματικής ζωής (π.χ. αναμονή σε γραμμή στη τράπεζα). Είναι FIFO (first-in-out-out),
          που σημαίνει ότι όταν ανακτάτε στοιχεία από την ουρά, επιστρέφονται με τη
          σειρά που εισήγαγαν. Οι Ruby Arrays παρέχουν μεθόδους που καθιστούν την εφαρμογή
          Queue ασήμαντη εύκολη αλλά το έχουν ονομάσει κατάλληλα και περιέχονται σε
          μια τάξη ευκολίας αξίζει να δουν ότι υλοποιούνται και επειδή άλλες δομές θα
          κληρονομήσουν από αυτή. Μια εναλλακτική εφαρμογή θα μπορούσε να γίνει χρησιμοποιώντας
          μια συνδεδεμένη λίστα.
        as_array: Η ουρά ως πίνακας
        as_linked_list: Ουρά ως συνδεδεμένη λίστα
      deque:
        title: και
        description: Το Deque είναι μια ουρά που επιτρέπει την προσθήκη και την αφαίρεση
          στοιχείων και στα δύο άκρα.
        as_array: Και ως μια σειρά
        as_linked_list: Deque ως συνδεδεμένη λίστα
      singly_linked_list:
        title: Ιδιαίτερα συνδεδεμένη λίστα
        description: Οι απλά συνδεδεμένες λίστες περιέχουν κόμβους που έχουν ένα πεδίο
          δεδομένων καθώς και ένα &#39;επόμενο&#39; πεδίο, το οποίο δείχνει στον επόμενο
          κόμβο στη γραμμή των κόμβων. Οι λειτουργίες που μπορούν να εκτελεστούν σε
          ξεχωριστά συνδεδεμένες λίστες περιλαμβάνουν εισαγωγή, διαγραφή και μετάβαση.
      doubly_linked_list:
        title: Λίστα διπλής σύνδεσης
        description: Σε μια λίστα διπλών συνδέσμων, κάθε στοιχείο λίστας περιέχει δύο
          αναφορές - μία για τον διάδοχό του και μία για τον προκάτοχό του.
      ordered_list:
        title: Λίστα παραγγελιών
        description: Μια ταξινομημένη λίστα είναι ένας κατάλογος στον οποίο η σειρά
          των στοιχείων είναι σημαντική. Ωστόσο, τα στοιχεία σε μια ταξινομημένη λίστα
          δεν είναι απαραίτητα ταξινομημένα. Συνεπώς, είναι δυνατό να αλλάξετε τη σειρά
          των στοιχείων και να έχετε ακόμα μια έγκυρη λίστα.
        as_array: Λίστα ταξινομημένων ως πίνακας
      hash_table:
        title: Πίνακας Hash
        description: Ένας πίνακας hash είναι ένα δοχείο με δυνατότητα αναζήτησης. Ως
          εκ τούτου, παρέχει μεθόδους για την τοποθέτηση αντικειμένου στο δοχείο, την
          εύρεση αντικειμένου στο δοχείο και την αφαίρεση ενός αντικειμένου από το δοχείο.
      binary_tree:
        title: Δυαδικό δένδρο
        description: Ένα δυαδικό δέντρο είναι ένα δέντρο στο οποίο κάθε κόμβος μπορεί
          να έχει μέχρι δύο παιδιά. Τα παιδιά ορίζονται αριστερά και δεξιά.
      binary_search_tree:
        title: Δυαδικό Δέντρο αναζήτησης &lt;
        description: 'Στην επιστήμη των υπολογιστών, δυαδικά δέντρα αναζήτησης (BST),
          μερικές φορές αποκαλούμενα εντοπισμένα ή ταξινομημένα δυαδικά δέντρα, είναι
          ένας ιδιαίτερος τύπος δοχείων: δομές δεδομένων που αποθηκεύουν &quot;στοιχεία&quot;
          (όπως αριθμούς, ονόματα κ.λπ.) στη μνήμη. Επιτρέπουν γρήγορη αναζήτηση, προσθήκη
          και αφαίρεση στοιχείων και μπορούν να χρησιμοποιηθούν για την υλοποίηση είτε
          δυναμικών ομάδων αντικειμένων είτε πίνακες αναζήτησης που επιτρέπουν την εύρεση
          ενός στοιχείου με το κλειδί του (π.χ. εύρεση του αριθμού τηλεφώνου ενός ατόμου
          με το όνομα)'
      b_tree:
        title: B-δέντρο
        description: Στην επιστήμη των υπολογιστών, ένα B-δέντρο είναι μια δομή δεδομένων
          δένδρων που εξισορροπεί τη φύση και διατηρεί τα δεδομένα ταξινομημένα και
          επιτρέπει αναζητήσεις, διαδοχική πρόσβαση, εισαγωγές και διαγραφές σε λογαριθμικό
          χρόνο. Το B-δέντρο είναι μια γενίκευση ενός δυαδικού δέντρου αναζήτησης, επειδή
          ένας κόμβος μπορεί να έχει περισσότερα από δύο παιδιά (αντίθετα με τα δυαδικά
          δέντρα αναζήτησης που εξισορροπούν την αυτονομία, το B-tree είναι βελτιστοποιημένο
          για συστήματα που διαβάζουν και γράφουν μεγάλα μπλοκ δεδομένων.) B- τα δέντρα
          είναι ένα καλό παράδειγμα δομής δεδομένων για την εξωτερική μνήμη. Χρησιμοποιείται
          συνήθως σε βάσεις δεδομένων και συστήματα αρχείων.
      binary_heap:
        title: Δυαδικός σωρός
        description: Ένας δυαδικός σωρός είναι ένα πλήρες δυαδικό δέντρο που έχει παραγγείλει
          σωρούς, το οποίο υλοποιείται χρησιμοποιώντας μια συστοιχία. Σε ένα σωρό το
          μικρότερο κλειδί βρίσκεται στη ρίζα και αφού η ρίζα εντοπίζεται πάντοτε στην
          πρώτη θέση της συστοιχίας, η εύρεση του μικρότερου κλειδιού είναι μια τετριμμένη
          λειτουργία σε ένα δυαδικό σωρό.
      credits: 'Κωδικός και άρθρα λήφθηκαν από πόρους:'
      source: Αυτή η σελίδα περιέχει τον κώδικα Ruby από το βιβλίο &quot;Δομές δεδομένων
        και αλγόριθμοι με αντικειμενοστρεφή μοτίβα σχεδίασης σε Ruby&quot; του Bruno
        R. Preiss. Πνευματικά δικαιώματα (c) 2004 από τους Bruno R. Preiss, P. Eng.
        Ολα τα δικαιώματα διατηρούνται.
  design_patterns:
    title: Σχεδιαστικά πρότυπα
    creational:
      title: Δημιουργικά πρότυπα
      description: Στη μηχανική λογισμικού, τα σχέδια δημιουργικής σχεδίασης είναι μοτίβα
        σχεδίασης που ασχολούνται με μηχανισμούς δημιουργίας αντικειμένων, προσπαθώντας
        να δημιουργήσουν αντικείμενα με τρόπο κατάλληλο για την κατάσταση. Η βασική
        μορφή της δημιουργίας αντικειμένων μπορεί να οδηγήσει σε προβλήματα σχεδιασμού
        ή σε πρόσθετη πολυπλοκότητα του σχεδιασμού. Τα μοντέλα σχεδίασης δημιουργίας
        λύουν αυτό το πρόβλημα ελέγχοντας με κάποιο τρόπο αυτήν τη δημιουργία αντικειμένου.
        Τα σχέδια δημιουργικού σχεδιασμού αποτελούνται από δύο κυρίαρχες ιδέες. Το ένα
        είναι η ενθυλάκωση της γνώσης σχετικά με τις συγκεκριμένες κατηγορίες που χρησιμοποιεί
        το σύστημα. Ένα άλλο κρύβει πώς δημιουργούνται και συνδυάζονται οι περιπτώσεις
        αυτών των συγκεκριμένων τάξεων.
      abstract_factory:
        title: Αφηρημένο σχέδιο εργοστασίου
        description: Το αφηρημένο μοτίβο του εργοστασίου παρέχει έναν τρόπο να ενσωματώνει
          μια ομάδα μεμονωμένων εργοστασίων που έχουν ένα κοινό θέμα χωρίς να προσδιορίζουν
          τις συγκεκριμένες κατηγορίες τους. Στην κανονική χρήση, το λογισμικό πελάτη
          δημιουργεί μια συγκεκριμένη εφαρμογή του αφηρημένου εργοστασίου και στη συνέχεια
          χρησιμοποιεί τη γενική διεπαφή του εργοστασίου για τη δημιουργία των συγκεκριμένων
          αντικειμένων που αποτελούν μέρος του θέματος. Ο πελάτης δεν γνωρίζει (ή φροντίζει)
          ποια συγκεκριμένα αντικείμενα παίρνει από κάθε ένα από αυτά τα εσωτερικά εργοστάσια,
          αφού χρησιμοποιεί μόνο τις γενικές διεπαφές των προϊόντων τους. Αυτό το μοτίβο
          διαχωρίζει τις λεπτομέρειες της εφαρμογής ενός συνόλου αντικειμένων από τη
          γενική χρήση τους και βασίζεται στη σύνθεση αντικειμένων, καθώς η δημιουργία
          αντικειμένων εφαρμόζεται σε μεθόδους που εκτίθενται στην εργοστασιακή διεπαφή.
      builder:
        title: Σχέδιο οικοδόμου
        description: Το μοτίβο οικοδόμου είναι ένα σχέδιο σχεδιασμού λογισμικού δημιουργίας
          αντικειμένου. Σε αντίθεση με το αφηρημένο μοτίβο του εργοστασίου και το πρότυπο
          της εργοστασιακής μεθόδου, η πρόθεση του οποίου είναι να επιτρέψει τον πολυμορφισμό,
          η πρόθεση του σχεδιαστή οικοδόμων είναι να βρεθεί λύση στο αντιολισθητικό
          δομοστοιχειωτό κατασκευαστή. Το αντιολισθητικό τηλεσκοπικό κατασκευαστή παρουσιάζεται
          όταν η αύξηση του συνδυασμού παραμέτρων κατασκευαστή αντικειμένου οδηγεί σε
          μια εκθετική λίστα κατασκευαστών. Αντί να χρησιμοποιήσει πολυάριθμους κατασκευαστές,
          το πρότυπο οικοδόμου χρησιμοποιεί ένα άλλο αντικείμενο, έναν οικοδόμο, ο οποίος
          λαμβάνει κάθε βήμα εκκίνησης κάθε βήμα προς βήμα και στη συνέχεια επιστρέφει
          το προκύπτον κατασκευασμένο αντικείμενο ταυτόχρονα.
      factory:
        title: Εργοστάσιο
        description: Στον προγραμματισμό που βασίζεται στην τάξη, το πρότυπο μεθόδου
          εργοστασίου είναι ένα σχέδιο δημιουργίας που χρησιμοποιεί τις εργοστασιακές
          μεθόδους για να αντιμετωπίσει το πρόβλημα της δημιουργίας αντικειμένων χωρίς
          να χρειάζεται να προσδιορίσει την ακριβή κλάση του αντικειμένου που θα δημιουργηθεί.
          Αυτό γίνεται με τη δημιουργία αντικειμένων καλώντας μια εργοστασιακή μέθοδο
          - είτε προσδιορίζεται σε μια διεπαφή και υλοποιείται από τάξεις παιδιού, είτε
          υλοποιείται σε μια βασική κλάση και προαιρετικά αντικαθίσταται από παράγωγες
          κλάσεις - αντί να καλεί έναν κατασκευαστή.
      prototype:
        title: Πρωτότυπο πρότυπο
        description: Το πρωτότυπο μοτίβο είναι ένα σχέδιο δημιουργίας κατά μήκος των
          γραμμών του εργοστασίου. Το κόλπο με το πρωτότυπο είναι ότι δημιουργείτε νέα
          αντικείμενα αντιγράφοντας ένα κύριο αντικείμενο. Αλλαγή αυτού του κύριου αντικειμένου
          και όλων των επόμενων αντικειμένων που δημιουργείτε θα πάει στη ζωή με ένα
          αντίγραφο της αλλαγής.
      singleton:
        title: Σχέδιο Singleton
        description: Βεβαιωθείτε ότι μια τάξη έχει μόνο μία παρουσία και παρέχει ένα
          παγκόσμιο σημείο πρόσβασης σε αυτήν. Αυτό είναι χρήσιμο όταν απαιτείται ένα
          ακριβώς αντικείμενο για τον συντονισμό των ενεργειών στο σύνολο του συστήματος.
          Η ιδέα γενικεύεται μερικές φορές σε συστήματα που λειτουργούν πιο αποτελεσματικά
          όταν υπάρχει μόνο ένα αντικείμενο ή περιορίζουν την παράσταση σε ένα ορισμένο
          αριθμό αντικειμένων.
      not_covered:
        title: 'Δεν καλύπτονται σχέδια:'
        lazy: Λανθασμένη προετοιμασία
        multiton: Multiton
        pool: Υποκατηγορία αντικειμένων
        resource: Η απόκτηση πόρων είναι αρχικοποίηση
    structural:
      title: Δομικά σχέδια
      description: Στη μηχανική λογισμικού, τα σχέδια δομικής σχεδίασης είναι σχεδιαστικά
        μοτίβα που διευκολύνουν το σχεδιασμό, προσδιορίζοντας έναν απλό τρόπο για να
        πραγματοποιήσουν σχέσεις μεταξύ οντοτήτων.
      adapter:
        title: Σχέδιο προσαρμογέα
        description: Στη μηχανική λογισμικού, το μοτίβο προσαρμογέα είναι ένα μοτίβο
          σχεδιασμού λογισμικού που επιτρέπει τη χρήση της διεπαφής μιας υπάρχουσας
          κλάσης ως άλλη διεπαφή. Συχνά χρησιμοποιείται για να κάνει τις υπάρχουσες
          τάξεις να δουλεύουν με άλλους χωρίς να τροποποιήσουν τον πηγαίο κώδικα τους.
      composite:
        title: Σύνθετο μοτίβο
        description: Το σχέδιο σύνθετου σχεδιασμού είναι ένα δομικό σχέδιο που χρησιμοποιείται
          για να αντιπροσωπεύει αντικείμενα που έχουν μια ιεραρχική δομή δέντρου. Επιτρέπει
          την ομοιόμορφη αντιμετώπιση τόσο των ατομικών κόμβων των φύλλων όσο και των
          κλάδων που αποτελούνται από πολλούς κόμβους.
      decorator:
        title: Σχέδιο διακοσμητή
        description: Στον αντικειμενοστραφή προγραμματισμό, το μοτίβο διακοσμητή (γνωστό
          και ως Wrapper, μια εναλλακτική ονομασία που μοιράζεται με το μοτίβο προσαρμογέα)
          είναι ένα μοτίβο σχεδίασης που επιτρέπει την προσθήκη συμπεριφοράς σε ένα
          μεμονωμένο αντικείμενο είτε στατικά είτε δυναμικά, χωρίς να επηρεάζεται η
          συμπεριφορά άλλων αντικείμενα από την ίδια κλάση. Το μοτίβο διακοσμητή είναι
          συχνά χρήσιμο για την τήρηση της Αρχής της Ενιαίας Ευθύνης, καθώς επιτρέπει
          τη διάρθρωση των λειτουργιών μεταξύ των κλάσεων με μοναδικές περιοχές ενδιαφέροντος.
      facade:
        title: Πρότυπο πρόσοψης
        description: Το μοτίβο σχεδιασμού προσόψεων χρησιμοποιείται συχνά όταν ένα σύστημα
          είναι πολύ περίπλοκο ή δύσκολο να κατανοηθεί επειδή το σύστημα έχει μεγάλο
          αριθμό αλληλοεξαρτώμενων τάξεων ή ο πηγαίος κώδικας του δεν είναι διαθέσιμος.
          Αυτό το μοτίβο κρύβει τις πολυπλοκότητες του μεγαλύτερου συστήματος και παρέχει
          μια απλούστερη διεπαφή στον πελάτη. Συνήθως περιλαμβάνει μια ενιαία κλάση
          περιτυλίγματος που περιέχει ένα σύνολο μελών που απαιτούνται από τον πελάτη.
          Αυτά τα μέλη έχουν πρόσβαση στο σύστημα για λογαριασμό του πελάτη της πρόσοψης
          και αποκρύπτουν τις λεπτομέρειες εφαρμογής.
      flyweight:
        title: Flyweight μοτίβο
        description: Στον προγραμματισμό υπολογιστών, το flyweight είναι ένα μοτίβο
          σχεδιασμού λογισμικού. Το flyweight είναι ένα αντικείμενο που ελαχιστοποιεί
          τη χρήση της μνήμης, μοιράζοντας όσο το δυνατόν περισσότερα δεδομένα με άλλα
          παρόμοια αντικείμενα. είναι ένας τρόπος να χρησιμοποιούμε αντικείμενα σε μεγάλους
          αριθμούς όταν μια απλή επαναλαμβανόμενη αναπαράσταση θα χρησιμοποιούσε μια
          μη αποδεκτή ποσότητα μνήμης. Συχνά ορισμένα τμήματα της κατάστασης του αντικειμένου
          μπορούν να μοιραστούν και είναι συνηθισμένη η πρακτική να τα κρατάτε σε εξωτερικές
          δομές δεδομένων και να τα μεταφέρετε προσωρινά στα flyweight αντικείμενα όταν
          χρησιμοποιούνται.
      proxy:
        title: Σχέδιο μεσολάβησης
        description: 'Ένας πληρεξούσιος, στην πιο γενική του μορφή, είναι μια τάξη που
          λειτουργεί ως διεπαφή σε κάτι άλλο. Ο διακομιστής μεσολάβησης μπορεί να συνδεθεί
          με οτιδήποτε: μια σύνδεση δικτύου, ένα μεγάλο αντικείμενο στη μνήμη, ένα αρχείο
          ή κάποιος άλλος πόρος που είναι ακριβός ή αδύνατος να αντιγραφεί. Με λίγα
          λόγια, ένας διακομιστής μεσολάβησης είναι ένα αντικείμενο περιτυλίγματος ή
          παράγοντα που καλείται από τον πελάτη για να αποκτήσει πρόσβαση στο πραγματικό
          αντικείμενο που εξυπηρετεί πίσω από τις σκηνές. Η χρήση του διακομιστή μεσολάβησης
          μπορεί απλά να προωθεί το πραγματικό αντικείμενο ή μπορεί να παρέχει πρόσθετη
          λογική. Στην πρόσθετη λειτουργικότητα του διακομιστή μεσολάβησης μπορεί να
          παρέχεται, για παράδειγμα η προσωρινή αποθήκευση όταν οι λειτουργίες στο πραγματικό
          αντικείμενο είναι εντατικές ή η επαλήθευση των προϋποθέσεων πριν την επίκληση
          των πράξεων στο πραγματικό αντικείμενο. Για τον πελάτη, η χρήση ενός αντικειμένου
          μεσολάβησης είναι παρόμοια με τη χρήση του πραγματικού αντικειμένου, επειδή
          και οι δύο εφαρμόζουν την ίδια διεπαφή.'
      protection_proxy:
        title: Προξενική προστασία
        description: Προξενική προστασία. Εργάζεστε σε ένα MNC; Αν ναι, ίσως να γνωρίζουμε
          καλά τον διακομιστή μεσολάβησης που μας παρέχει πρόσβαση στο Διαδίκτυο περιορίζοντας
          την πρόσβαση σε κάποιους τύπους ιστοτόπων όπως το δημόσιο ηλεκτρονικό ταχυδρομείο,
          την κοινωνική δικτύωση, την αποθήκευση δεδομένων κλπ. Η διοίκηση πιστεύει
          ότι είναι προτιμότερο να εμποδίζουμε κάποιο περιεχόμενο και παρέχει μόνο ιστοσελίδες
          που σχετίζονται με την εργασία. Ο διακομιστής μεσολάβησης κάνει αυτήν την
          εργασία. Αυτός είναι ένας τύπος μοτίβου σχεδιασμού μεσολάβησης
      virtual_proxy:
        title: Εικονικό proxy
        description: Εικονικό proxy. Αντί για ένα περίπλοκο ή βαρύ αντικείμενο, χρησιμοποιήστε
          μια παράσταση σκελετού. Όταν μια υποκείμενη εικόνα είναι τεράστια σε μέγεθος,
          απλώς την αντιπροσωπεύει χρησιμοποιώντας ένα εικονικό αντικείμενο proxy και
          φορτίο κατά παραγγελία το πραγματικό αντικείμενο. Γνωρίζετε ότι το πραγματικό
          αντικείμενο είναι ακριβό από την άποψη της δημιουργίας στιγμιότυπων και έτσι
          χωρίς την πραγματική ανάγκη δεν πρόκειται να χρησιμοποιήσουμε το πραγματικό
          αντικείμενο. Μέχρι να προκύψει η ανάγκη θα χρησιμοποιήσουμε τον εικονικό πληρεξούσιο.
      remote_proxy:
        title: Απομακρυσμένο διακομιστή μεσολάβησης
        description: Απομακρυσμένο διακομιστή μεσολάβησης Στην επικοινωνία κατανεμημένου
          αντικειμένου, ένα τοπικό αντικείμενο αντιπροσωπεύει ένα απομακρυσμένο αντικείμενο
          (το οποίο ανήκει σε διαφορετικό χώρο διευθύνσεων). Το τοπικό αντικείμενο είναι
          ένας διακομιστής μεσολάβησης για το απομακρυσμένο αντικείμενο και η επίκληση
          μεθόδων στο τοπικό αντικείμενο οδηγεί σε απομακρυσμένη κλήση μεθόδου στο απομακρυσμένο
          αντικείμενο. Σκεφτείτε μια εφαρμογή ΑΤΜ, θα διατηρήσει αντικείμενα διακομιστή
          μεσολάβησης για τραπεζικές πληροφορίες που υπάρχουν στον απομακρυσμένο διακομιστή.
      not_covered:
        title: 'Δεν καλύπτονται σχέδια:'
        callback: Σχολιασμένη κλήση σχολιασμού
        bridge: Γέφυρα
        data_bus: Δίαυλος δεδομένων
        role: Αντικείμενο ρόλου
    behavioral:
      title: Σχέδια συμπεριφοράς
      description: Στη μηχανική λογισμικού, τα σχέδια συμπεριφοράς είναι σχεδιαστικά
        μοτίβα που προσδιορίζουν κοινά πρότυπα επικοινωνίας μεταξύ αντικειμένων και
        υλοποιούν αυτά τα πρότυπα. Με αυτόν τον τρόπο, αυτά τα πρότυπα αυξάνουν την
        ευελιξία στην πραγματοποίηση αυτής της επικοινωνίας.
      chain_of_responsobility:
        title: Πρότυπο αλυσίδας ευθύνης
        description: Σε αντικειμενοστραφή σχεδιασμό, το μοτίβο αλυσίδας ευθύνης είναι
          ένα μοτίβο σχεδιασμού που αποτελείται από μια πηγή αντικειμένων εντολών και
          μια σειρά αντικειμένων επεξεργασίας. Κάθε αντικείμενο επεξεργασίας περιέχει
          λογική που καθορίζει τους τύπους αντικειμένων εντολών που μπορεί να χειριστεί.
          τα υπόλοιπα μεταφέρονται στο επόμενο αντικείμενο επεξεργασίας στην αλυσίδα.
          Υπάρχει επίσης ένας μηχανισμός για την προσθήκη νέων αντικειμένων επεξεργασίας
          στο τέλος αυτής της αλυσίδας.
      command:
        title: Σχέδιο εντολών
        description: Το μοτίβο εντολών είναι ένα σχέδιο σχεδιασμού συμπεριφοράς που
          χρησιμοποιείται για την αποθήκευση των πληροφοριών που απαιτούνται για την
          κλήση μεθόδων σε μια μελλοντική χρονική στιγμή. Η εντολή είναι απλά ένα σύνολο
          ενεργειών που τυλίγονται σε ένα αντικείμενο. Με το ρουμπίνι, μπορούμε να χρησιμοποιήσουμε
          το Procs για να κάνουμε το ίδιο πράγμα χωρίς να χρειάζεται να δημιουργήσουμε
          ένα ξεχωριστό αντικείμενο. Αυτή είναι μια καλή επιλογή όταν η ενέργεια είναι
          απλή και δεν απαιτεί την αποθήκευση πληροφοριών κατάστασης, διαφορετικά, μια
          τάξη εντολών είναι η καλύτερη επιλογή.
      interpreter:
        title: Πρότυπο διερμηνέα
        description: Στον προγραμματισμό υπολογιστών, το πρότυπο διερμηνείας είναι ένα
          σχέδιο σχεδιασμού που καθορίζει τον τρόπο αξιολόγησης των προτάσεων σε μια
          γλώσσα. Η βασική ιδέα είναι να υπάρχει μια κλάση για κάθε σύμβολο (τερματικό
          ή μη τερματικό) σε μια εξειδικευμένη γλώσσα υπολογιστή. Το δέντρο σύνταξης
          μιας πρότασης στη γλώσσα είναι μια παρουσία του σύνθετου σχεδίου και χρησιμοποιείται
          για την αξιολόγηση (ερμηνεία) της πρότασης για έναν πελάτη.
      iterator:
        title: Μοντέλο Iterator
        description: Το μοτίβο σχεδιασμού του iterator παρέχει διαδοχική πρόσβαση σε
          στοιχεία εντός ενός δοχείου χωρίς να εκθέτει τον τρόπο με τον οποίο το δοχείο
          αντιπροσωπεύει πραγματικά τα στοιχεία. Ο iterator μπορεί να θεωρηθεί ως ένας
          κινητός δείκτης που επιτρέπει την πρόσβαση σε στοιχεία που έχουν εγκλωβιστεί
          μέσα σε ένα δοχείο.
      external_iterator:
        title: Εξωτερικό μοτίβο iterator
        description: 'Εξωτερικός iterator: Η λογική επανάληψης περιέχεται σε ξεχωριστή
          κλάση. Η κλάση επανάληψης μπορεί να γενικευθεί για να χειριστεί πολλούς τύπους
          αντικειμένων εφόσον επιτρέπουν την ευρετηρίαση. Απαιτεί την πρόσθετη κλάση
          να κάνει την πραγματική αλλαγή, αλλά επιτρέπουν μεγαλύτερη ευελιξία επειδή
          μπορείτε να ελέγξετε την επανάληψη, ποια στοιχεία επαναλαμβάνονται και με
          ποια σειρά.'
      internal_iterator:
        title: Εσωτερικό πρότυπο iterator
        description: 'Εσωτερικός iterator: όλη η λογική του iterating εμφανίζεται μέσα
          στο συγκεντρωτικό αντικείμενο. Χρησιμοποιήστε ένα μπλοκ κώδικα για να περάσετε
          τη λογική σας στο σύνολο, το οποίο στη συνέχεια καλεί το μπλοκ για κάθε στοιχείο
          του.'
      mediator:
        title: Πρότυπο διαμεσολαβητή
        description: Συνήθως ένα πρόγραμμα αποτελείται από μεγάλο αριθμό τάξεων. Έτσι,
          η λογική και ο υπολογισμός κατανέμονται μεταξύ αυτών των τάξεων. Ωστόσο, καθώς
          αναπτύσσονται περισσότερες κατηγορίες σε ένα πρόγραμμα, ειδικά κατά τη διάρκεια
          συντήρησης ή / και refactoring, το πρόβλημα της επικοινωνίας μεταξύ αυτών
          των τάξεων μπορεί να γίνει πιο περίπλοκο. Αυτό καθιστά το πρόγραμμα πιο δύσκολο
          να διαβαστεί και να διατηρηθεί. Επιπλέον, μπορεί να γίνει δύσκολη η αλλαγή
          του προγράμματος, καθώς οποιαδήποτε αλλαγή μπορεί να επηρεάσει τον κώδικα
          σε πολλές άλλες κατηγορίες. Με το πρότυπο διαμεσολαβητή, η επικοινωνία μεταξύ
          αντικειμένων ενθυλακώνεται με ένα αντικείμενο μεσολαβητή. Τα αντικείμενα δεν
          επικοινωνούν πλέον άμεσα μεταξύ τους, αλλά επικοινωνούν μέσω του διαμεσολαβητή.
          Αυτό μειώνει τις εξαρτήσεις μεταξύ των αντικειμένων επικοινωνίας, μειώνοντας
          έτσι τη ζεύξη.
      momento:
        title: Στιγμή του σχεδίου
        description: 'Το πρότυπο Momento υλοποιείται με τρία αντικείμενα: τον δημιουργό,
          έναν επιστάτη και ένα momento. Ο δημιουργός είναι κάποιο αντικείμενο που έχει
          εσωτερική κατάσταση. Ο φύλακας πρόκειται να κάνει κάτι στον συντάκτη, αλλά
          θέλει να είναι σε θέση να αναιρέσει την αλλαγή. Ο θεματοφύλακας πρώτα ρωτά
          τον δημιουργό για ένα αντικείμενο momento. Στη συνέχεια, κάνει οποιαδήποτε
          ενέργεια (ή ακολουθία πράξεων) που θα κάνει. Για να επιστρέψετε στην κατάσταση
          πριν από τις λειτουργίες, επιστρέφει το αντικείμενο momento στον δημιουργό.
          Το ίδιο το momento αντικείμενο είναι ένα αδιαφανές αντικείμενο (το οποίο ο
          συντηρητής δεν μπορεί, ή δεν πρέπει να αλλάξει). Όταν χρησιμοποιείτε αυτό
          το μοτίβο, πρέπει να είστε προσεκτικοί εάν ο δημιουργός μπορεί να αλλάξει
          άλλα αντικείμενα ή πόρους - το μοτίβο momento λειτουργεί σε ένα μόνο αντικείμενο.'
      observer:
        title: Πρότυπο παρατηρητή
        description: Το πρότυπο παρατηρητή είναι ένα μοτίβο σχεδιασμού λογισμικού στο
          οποίο ένα αντικείμενο, που ονομάζεται θέμα, διατηρεί μια λίστα των εξαρτώμενων
          από αυτόν, που ονομάζονται παρατηρητές, και τους ειδοποιεί αυτόματα για οποιεσδήποτε
          κρατικές αλλαγές, συνήθως καλώντας μία από τις μεθόδους τους. Χρησιμοποιείται
          κυρίως για την εφαρμογή συστημάτων διανομής συμβάντων. Το μοτίβο Observer
          είναι επίσης ένα βασικό μέρος του αρχιτεκτονικού μοντέλου οικείου μοντέλου-ελεγκτή
          (MVC). Το πρότυπο παρατηρητή εφαρμόζεται σε πολλές βιβλιοθήκες και συστήματα
          προγραμματισμού, συμπεριλαμβανομένων σχεδόν όλων των GUI εργαλείων.
      state:
        title: Κλάση κράτους
        description: Το πρότυπο κατάστασης είναι ένα σχέδιο σχεδιαστικής συμπεριφοράς
          λογισμικού που υλοποιεί μια μηχανή κατάστασης με έναν αντικειμενοστραφή τρόπο.
          Με το πρότυπο κατάστασης, υλοποιείται μια μηχανή κατάστασης, εφαρμόζοντας
          κάθε μεμονωμένη κατάσταση ως παράγωγη κλάση της διεπαφής κατάστασης του κράτους
          και εφαρμόζοντας μεταβάσεις κατάστασης, επικαλούμενοι μεθόδους που ορίζονται
          από την υπερκλάση του προτύπου.
      strategy:
        title: Σχέδιο στρατηγικής
        description: Η στρατηγική επιτρέπει στον αλγόριθμο να διαφέρει ανεξάρτητα από
          τους πελάτες που το χρησιμοποιούν. Η στρατηγική είναι ένα από τα μοντέλα που
          περιλαμβάνονται στα σχεδιαγράμματα επιρροής του βιβλίου από τους Gamma et
          al. που διαφήμισε την έννοια της χρήσης μοτίβων για την περιγραφή του σχεδιασμού
          του λογισμικού. Για παράδειγμα, μια κλάση που εκτελεί επικύρωση στα εισερχόμενα
          δεδομένα μπορεί να χρησιμοποιήσει ένα πρότυπο στρατηγικής για να επιλέξει
          έναν αλγόριθμο επικύρωσης βάσει του τύπου δεδομένων, της πηγής των δεδομένων,
          της επιλογής του χρήστη ή άλλων παραγόντων διακριτικής μεταχείρισης. Αυτοί
          οι παράγοντες δεν είναι γνωστοί για κάθε περίπτωση μέχρι την ώρα εκτέλεσης
          και μπορεί να απαιτούν ριζικά διαφορετική επικύρωση. Οι στρατηγικές επικύρωσης,
          ενσωματωμένες χωριστά από το αντικείμενο επικύρωσης, μπορούν να χρησιμοποιηθούν
          από άλλα επικυρωτικά αντικείμενα σε διαφορετικές περιοχές του συστήματος (ή
          ακόμη και σε διαφορετικά συστήματα) χωρίς επικάλυψη κώδικα.
      template:
        title: Πρότυπο μεθόδου προτύπου
        description: Στον αντικειμενοστραφή προγραμματισμό, δημιουργείται πρώτα μία
          κλάση που παρέχει τα βασικά βήματα ενός σχεδιασμού αλγορίθμου. Αυτά τα βήματα
          υλοποιούνται χρησιμοποιώντας αφηρημένες μεθόδους. Αργότερα, οι υποκατηγορίες
          αλλάζουν τις αφηρημένες μεθόδους για να εφαρμόσουν πραγματικές ενέργειες.
          Έτσι ο γενικός αλγόριθμος αποθηκεύεται σε ένα σημείο αλλά τα συγκεκριμένα
          βήματα μπορούν να αλλάξουν από τις υποκατηγορίες.
      visitor:
        title: Πρότυπο επισκεπτών
        description: Στον αντικειμενοστραφή προγραμματισμό και στην τεχνολογία λογισμικού,
          το σχέδιο σχεδιασμού του επισκέπτη είναι ένας τρόπος διαχωρισμού ενός αλγορίθμου
          από μια δομή αντικειμένου στην οποία λειτουργεί. Ένα πρακτικό αποτέλεσμα αυτού
          του διαχωρισμού είναι η δυνατότητα προσθήκης νέων λειτουργιών σε υπάρχουσες
          δομές αντικειμένων χωρίς τροποποίηση αυτών των δομών. Είναι ένας τρόπος να
          ακολουθήσουμε την ανοικτή / κλειστή αρχή. Στην ουσία, ο επισκέπτης επιτρέπει
          σε κάποιον να προσθέσει νέες εικονικές λειτουργίες σε μια οικογένεια τάξεων
          χωρίς να τροποποιεί τα ίδια τα μαθήματα. Αντίθετα, δημιουργείται μια κατηγορία
          επισκεπτών που εφαρμόζει όλες τις κατάλληλες εξειδικεύσεις της εικονικής λειτουργίας.
          Ο επισκέπτης παίρνει την αναφορά του στιγμιότυπου ως είσοδο και υλοποιεί το
          στόχο με διπλή αποστολή.
      not_covered:
        title: 'Δεν καλύπτονται σχέδια:'
        hierarchical: Ιεραρχικός επισκέπτης
      credits: 'Κωδικός και άρθρα λήφθηκαν από πόρους:'
  functional_programming:
    title: Λειτουργικός προγραμματισμός
    description: 'Η χρήση μιας γλώσσας σε λειτουργικό στυλ υποδηλώνει ότι έχετε πρόσβαση
      σε μερικά βασικά χαρακτηριστικά που αναφέρονται παρακάτω:'
    axioms:
      immutable: 'Μεταβλητές τιμές: αφού οριστεί μια &quot;μεταβλητή&quot;, δεν μπορεί
        να αλλάξει. Στον Ruby, αυτό σημαίνει ότι πρέπει να αντιμετωπίζετε αποτελεσματικά
        μεταβλητές όπως οι σταθερές.'
      side_effects: 'Δεν υπάρχουν παρενέργειες: όταν περάσει μια δεδομένη τιμή, μια
        λειτουργία πρέπει πάντα να επιστρέφει το ίδιο αποτέλεσμα. Αυτό συμβαδίζει με
        την ύπαρξη αμετάβλητων αξιών. μια συνάρτηση δεν μπορεί ποτέ να πάρει μια τιμή
        και να την αλλάξει, καθώς αυτό θα προκαλούσε μια παρενέργεια που είναι εφαπτόμενη
        στην επιστροφή ενός αποτελέσματος.'
      pure_functions: 'Λειτουργίες υψηλότερης τάξης: αυτές είναι λειτουργίες που επιτρέπουν
        λειτουργίες ως επιχειρήματα ή χρησιμοποιούν λειτουργίες ως αξία επιστροφής.
        Αυτό είναι, αναμφισβήτητα, ένα από τα πιο κρίσιμα χαρακτηριστικά κάθε λειτουργικής
        γλώσσας.'
      applying: 'Currying: ενεργοποιείται από τις λειτουργίες υψηλότερης τάξης, το currying
        μετατρέπει μια συνάρτηση που παίρνει πολλαπλά επιχειρήματα σε μια συνάρτηση
        που παίρνει ένα όρισμα. Αυτό συμβαδίζει με την εφαρμογή μερικής λειτουργίας,
        η οποία μετασχηματίζει μια συνάρτηση πολλαπλών παραδειγμάτων σε μια συνάρτηση
        που παίρνει λιγότερα επιχειρήματα, τότε έκανε αρχικά.'
      recursion: 'Επανασύνδεση: βρόχος καλώντας μια λειτουργία από μέσα της. Όταν δεν
        έχετε πρόσβαση σε μεταβλητά δεδομένα, η υποτροπή χρησιμοποιείται για τη δημιουργία
        και την αλυσίδα δεδομένων. Αυτό συμβαίνει επειδή το looping δεν είναι μια λειτουργική
        ιδέα, καθώς απαιτεί μεταβλητές που πρέπει να περάσουν γύρω για να αποθηκεύσουν
        την κατάσταση του βρόχου σε μια δεδομένη στιγμή.'
      lazy: 'Lazy-αξιολόγηση ή καθυστερημένη αξιολόγηση: καθυστερεί την επεξεργασία
        των τιμών μέχρι τη στιγμή που είναι πραγματικά απαραίτητη. Εάν, για παράδειγμα,
        έχετε κάποιο κωδικό που δημιούργησε τον κατάλογο των αριθμών Fibonacci με ενεργοποιημένη
        την τεχνητή αξιολόγηση, αυτό δεν θα επεξεργάζεται και θα υπολογίζεται μέχρις
        ότου μια από τις τιμές στο αποτέλεσμα απαιτηθεί από μια άλλη λειτουργία, όπως
        το puts.'
    pure_functions:
      title: Καθαρές λειτουργίες
      description: Μπορείτε να δείτε ότι αυτή η λειτουργία υπολογίζει το αποτέλεσμα
        χρησιμοποιώντας μόνο τα επιχειρήματά της.
    closures:
      title: Κλείσιμο
      description: Η Lambda επιβάλλει επίσης ένα κλείσιμο και έτσι είναι σε θέση να
        κρατήσει το πλαίσιο τους σε αντικείμενα.
    applying:
      title: Μερική εφαρμογή και μεταφορά
      description: Ας καταλάβουμε πρώτα ποιες είναι αυτές οι δύο διαφορετικές εφαρμογές
        λειτουργιών. Η εφαρμογή μερικής λειτουργίας ονομάζει μια συνάρτηση με κάποιο
        αριθμό επιχειρημάτων, προκειμένου να πάρει μια λειτουργία πίσω που θα πάρει
        ότι πολλά λιγότερα επιχειρήματα. Η κάθαρση παίρνει μια συνάρτηση που παίρνει
        n επιχειρήματα, και χωρίζοντάς την σε n λειτουργίες που παίρνουν ένα επιχείρημα.
      proc: Προκειμένου να σας δώσουμε μια σαφέστερη ιδέα για το τι θα κάνει μια από
        τις δύο αυτές πράξεις, ας πάρουμε ένα παράδειγμα Proc.
      partial: Η μερική εφαρμογή αυτής της συνάρτησης θα επέστρεφε, εάν περάσαμε στα
        δύο πρώτα επιχειρήματα, τα ακόλουθα ενσωματωμένα Procs.
      curry: <span class="code-inline">.curry</span> επιστρέφει ένα κρυφό
        proc. Εάν δίνεται το προαιρετικό όρισμα arity, καθορίζει τον αριθμό των επιχειρημάτων.
        Ένας κακοποιημένος proc παίρνει κάποια επιχειρήματα. Αν παρέχεται ένας επαρκής
        αριθμός επιχειρημάτων, διαβιβάζει τα παρεχόμενα επιχειρήματα στον αρχικό proc
        και επιστρέφει το αποτέλεσμα. Διαφορετικά, επιστρέφει ένα άλλο κακόβουλο proc
        που παίρνει τα υπόλοιπα επιχειρήματα.
  gotchas:
    title: Γκότσα
    description1: Οι περισσότεροι αρχάριοι Ruby on Rails γίνονται ενθουσιασμένοι από
      το πλαίσιο και ξεκινούν να επεξεργάζονται εφαρμογές χωρίς να γνωρίζουν τη γλώσσα.
      Και αυτή είναι η μαγεία του RoR.
    description2: Σε κάποιο σημείο τα πράγματα αρχίζουν να γίνονται σοβαρά. Μερικοί
      χρειάζονται χρόνο και προσπάθεια για να εξερευνήσουν βρώμικα μυστικά του Ruby
      on Rails, ενώ άλλοι γυαλίζουν και γίνονται ανώτεροι προγραμματιστές με σχεδόν
      μηδενική γνώση της γλώσσας.
    description3: Εν πάση περιπτώσει, αργά ή γρήγορα, αρχάριοι ή έμπειροι προγραμματιστές,
      όλοι τρέχουμε στο αποκαλούμενο Ruby Gotchas - αυτές τις μικρές γλωσσικές λεπτές
      αποχρώσεις που κρύβονται από το site μας για ώρες σκληρών σφαλμάτων.
    description4: Εδώ είναι ένας κατάλογος δημοφιλών Ruby gotchas και των περιγραφών
      που οι προγραμματιστές πρέπει να γνωρίζουν. Για κάθε περίπτωση, υπάρχει ένα παράδειγμα
      σύγχυσης και / ή σφάλματος-επιρρεπείς κώδικα.
    description5: Έρχονται μαζί με καλές πρακτικές, που θα σας εμποδίσουν να κάνετε
      απλά (αλλά δύσκολο να βρείτε) λάθη και να απλοποιήσετε τη ζωή σας (και τη συντήρηση
      του κώδικα σας).
    surprising:
      title: Ο Ruby μπορεί να είναι εκπληκτικό
      description: Αν και &quot;κατασκευασμένο για να μεγιστοποιήσει την ευτυχία του
        προγραμματιστή&quot;, με την &quot;αρχή της ελάχιστης έκπληξης&quot;, ο Ruby
        εξακολουθεί να έχει gotchas. Αυτή η παρουσίαση θα προχωρήσει από τα newbie trivial
        gotchas, σε πιο εξελιγμένα και σύγχυση.
    quotes:
      title: Μην το αναφέρετε σε αυτό, αλλά ...
      description: String παρεμβολής (συμπεριλαμβανομένων των ειδικών χαρακτήρων όπως
        <span class="code-inline">\n</span> αποτυγχάνει με <span class="code-inline">'ενιαία'</span>
        εισαγωγικά - απαιτεί <span class="code-inline">"διπλά"</span> εισαγωγικά. Ακριβώς
        όπως στις περισσότερες γλώσσες με παρεμβολή συμβολοσειράς. Για να αποφύγετε
        τη χρήση διπλώνει όποτε είναι πρακτικό.
    twue:
      title: Είναι twue! Είναι twue!
      description: 'Μόνο δύο πράγματα είναι ψεύτικα: <span class="code-inline">false</span>
        και <span class="code-inline">nil</span> . Όλα τα υπόλοιπα είναι τραγικά,
        ακόμη και <span class="code-inline">0</span> (ψευδής στο C), <span class="code-inline">&quot;&quot;</span>
        (ψευδής στο JS), <span class="code-inline">[]</span> κλπ. Εκπαιδεύει ανθρώπους
        από το C, JS, κλπ. Όπου μερικές από αυτές είναι ψευδείς.'
    symbols_and_strings:
      title: Κρεμάστε τον με το μανίκι ή συμβουλευτείτε τον συμβολικά.
      description: '<span class="code-inline">Symbol != String</span>. Ακόμη και αν
        το ίδιο όταν εκτυπώνεται. Θυμηθείτε ποια να χρησιμοποιήσετε για args. Στην ιδανική
        περίπτωση, πάρτε είτε και χρησιμοποιήστε αυτό που μια μέθοδος αναμένει: &quot;Να
        είστε φιλελεύθερος σε αυτό που αποδέχεστε και συντηρητικό σε αυτό που στέλνετε&quot;.
        Νόμος του Postel.'
    string_or_nothing:
      title: Σειρά ... ή τίποτα!
    constants:
      title: Σταθερά δεν είναι
      description: Η αρχική κεφαλαία σημαίνει σταθερή, στο Ruby. Προσπαθήστε να αλλάξετε
        μια σταθερά. Ooooh έχετε ένα ΠΡΟΕΙΔΟΠΟΙΗΣΗ! BFD. Ακόμη και η κατάψυξη δεν λειτουργεί
        για τα Fixnums. Λειτουργεί για συστοιχίες (είδος) και για τα περισσότερα άλλα
        αντικείμενα ... δήλωσε προφητεία.
    equals:
      title: Μερικοί είναι πιο ίσοι από τους άλλους
      description: <span class="code-inline">==</span> είναι η συνηθισμένη ίδια τιμή,
        <span class="code-inline">.eql?</span> είναι η τιμή και η κλάση (1 είναι Fixnum,
        1.0 είναι Float), <span class="code-inline">.equal?</span> είναι το ίδιο αντικείμενο.
        Είναι στην πραγματικότητα πολύ πιο χαλαρή.
    operations:
      title: "> ===! = ==!"
      description: <span class="code-inline">===</span> είναι &quot;ισότητα των περιπτώσεων&quot;,
        όπως και στις δηλώσεις περίπτωσης. Ένα καλύτερο όνομα μπορεί να είναι. <span
        class="code-inline">.describes?</span> , ή υπερφόρτωση <span class="code-inline">.includes?</span>
        . Και πάλι, είναι στην πραγματικότητα πολύ πιο χαλαρή? ανατρέξτε στα έγγραφα
        του αντικειμένου κλάσης. Παίρνει άτομα από γλώσσες όπου <span class="code-inline">===</span>
        είναι ταυτότητα αντικειμένου ή ίδια τιμή και κλάση.
    priority:
      title: and != &&, or != ||
      description: '<span class="code-inline">&amp;&amp;</span> έχει υψηλότερη προτεραιότητα
        από το <span class="code-inline">=</span> , έτσι <span class="code-inline">x
        = true &amp;&amp; false</span> σημαίνει <span class="code-inline">x = (true
        && false)</span> και έχει χαμηλότερη προτεραιότητα, έτσι <span class="code-inline">x
        = true and false</span> σημαίνει <span class="code-inline">(x = true) and false</span>
        . Οδηγός στυλ Ruby: Χρησιμοποιήστε <span class="code-inline">&amp;&amp;, ||</span>
        για εκφράσεις boolean, <span class="code-inline">and, or</span> για ροή ελέγχου.'
    sensitive:
      title: Μην είσαι τόσο ευαίσθητος!
      description: Ασυμπλή ευθυγράμμιση; ΔΕΝ ΕΙΝΑΙ ΠΑΝΤΑ! Ο προγραμματιστής σκέφτεται
        ότι είναι μια έκφραση, όπως ένα arg, αλλά <span class="code-inline">(1, 2)</span>
        δεν είναι μια έγκυρη έκφραση Ruby! (Όλα λειτουργούν καλά με 1 επιχείρημα).
      usage: 'Με πολλαπλά args: <br/> - Χωρίς παρενέργειες, κανένα πρόβλημα. <br/> -
        Γονείς χωρίς χώρο, εντάξει. <br/> - Παρέντες και χώρος, ΟΧΙ!'
      methods: '<span class="code-inline">method / num</span> είναι ένα unended regex
        ή string! Ο Ruby νομίζει ότι δίνετε ένα επιχείρημα στη μέθοδο. Γενική αρχή:
        χρησιμοποιήστε ισορροπημένο κενό. και οι δύο πλευρές ή και οι δύο.'
      arguments: '<span class="code-inline">one -2</span> κάνει τον Ruby να πιστεύει
        ότι δίνετε ένα επιχείρημα <span class="code-inline">-2</span> στη μέθοδο ένα.
        Ίδια για <span class="code-inline">+2</span> ή ακόμα και <span class="code-inline">*
        2</span> . Και πάλι: χρησιμοποιήστε τα ισορροπημένα κενά, και τις δύο πλευρές
        ή και τα δύο.'
      stubby: "&quot;Stabby&quot; lambdas (1.9+) Παρενθέσεις προαιρετικά Διάστημα πριν
        από τα args χωρίς γονείς, Εντάξει. Χώρος μετά από γονείς, εντάξει. Και πάλι,
        χώρος πριν από τους γονείς, ΟΧΙ! UPDATE: Σταθερό σε 2.0!"
    onto:
      title: Το yer @ επάνω!
      description: 'Η γυμνή τιμή γίνεται μια προσωρινή τοπική μεταβλητή! Λύση: θυμηθείτε
        το <span class="code-inline">@!</span> (Ή &quot;αυτο.&quot; Ή χρησιμοποιήστε
        <span class="code-inline">attr_writer, attr_accessor</span> .) Παίρνει ανθρώπους
        από Java / C ++, όχι τόσο Python (που χρειάζεται επίσης &quot;εαυτό.&quot;).
        &quot;Συνεχίζετε να χρησιμοποιείτε αυτήν τη μεταβλητή. Δεν νομίζω ότι σημαίνει
        αυτό που νομίζετε ότι σημαίνει&quot;. Δεν είναι Inigo Montoya.'
    variables:
      title: Κοιτάξτε έξω, είναι @@!
      description: Κοίτα τι γεμίζει το κενό; Δεν <span class="code-inline">@@value</span> του γονέα πριν το ελέγξουμε, ούτε το παιδί καθόλου! Ή μήπως;
        <span class="code-inline">@@variables</span> μοιράζονται με υποκατηγορίες
        - όχι μόνο ότι υπάρχουν, αλλά και οι ίδιες οι μεταβλητές! Η διαπίστωση της <span
        class="code-inline">@@values</span> του παιδιού άλλαξε την τιμή
        του γονέα και συμπεριλαμ- βανόταν ότι το παιδί άλλαξε το Child&#39;s.ut,
        είναι @@!
    initialize:
      title: Με init (ialize) ή χωρίς αυτό
      description: Η προετοιμασία του γονέα εκτελείται αυτόματα μόνο εάν δεν έχει κανένα
        παιδί. Αλλιώς, οι γονείς πρέπει να κληθούν να τρέξουν.
    superman:
      title: Superman εναντίον του αόρατου ανθρώπου
      description: '<span class="code-inline">super</span> με λίστα χωρίς arg στέλνει
        τι καλούντα πήρε <span class="code-inline">super</span> με ρητό args στέλνει
        αυτά τα args για να στείλει NO args, χρήση κενών παρενθέσεων: <span class="code-inline">super()</span> .'
    regexp:
      title: Πότε θα τελειώσει; (Ή ξεκινήστε;)
      description: 'Στα πρότυπα regexps: <span class="code-inlne">^</span> είναι η αρχή
        και το <span class="code-inline">$</span> είναι το τέλος ολόκληρης της συμβολοσειράς.
        Οι επαναλήψεις του Ruby σε προεπιλεγμένη γραμμή, έτσι: <span class="code-inline">^</span>
        είναι αρχή και <span class="code-inline">$</span> είναι τέλος οποιασδήποτε γραμμής!
        <span class="code-inline">\ A</span> είναι αρχή και <span class="code-inline">\
        Z</span> είναι το τέλος ολόκληρης της συμβολοσειράς. (Ή \ z για να συμπεριλάβετε
        οποιαδήποτε νέα γραμμή ... η οποία είναι άλλη μια!'
    any:
      title: να πάρει το .any;
      description: '<span class="code-inline">.any?</span> δεν σημαίνει &quot;κανένα
        στοιχείο;&quot;! Με το μπλοκ: &quot;κάνουμε οποιοδήποτε κάνει το μπλοκ αληθινό;&quot;.
        Χωρίς: &quot;είναι οποιαδήποτε τεχνική;&quot; Έχει σιωπηρή δέσμευση: <span class="code-inline">{ |element| element }</span> .'
    undef:
      title: "(Un) Def Leppard"
      description: Οι μεταβλητές που δηλώνονται σε μπλοκ που μεταβιβάζονται στους iterators
        (π.χ. φορές ή καθένα) είναι ασαφείς στην κορυφή κάθε επανάληψης! Οι επαναληπτικές
        κλήσεις επαναλαμβάνουν το μπλοκ επανειλημμένα, έτσι ώστε οι βάρκες να βρεθούν
        ξανά εκτός πεδίου μετά από κάθε κλήση. Ενσωματωμένα κατασκευάσματα βρόχου (π.χ.,
        ενώ ή για) είναι εντάξει. (Ή δηλώστε vars πριν από το μπλοκ.)
    freeze:
      title: Πάγωμα (Ar) ray
      description: Η κατάψυξη ενός πίνακα (ή ενός κατακερματισμού) παγώνει, όχι τα στοιχεία
        που περιέχει. Οι χορδές μπορούν να τροποποιηθούν στη θέση τους. Με αυτόν τον
        τρόπο, μπορείτε να τροποποιήσετε μια συγκεκριμένη υποδοχή σε μια παγωμένη σειρά
        συστοιχιών.
    one_is_one:
      title: 1 είναι 1 ... και όλο και περισσότερο θα είναι έτσι!
      description: 'Η αλλαγή του Fixnum σε νέα τιμή σημαίνει ένα νέο αντικείμενο. Δεν
        μπορούν να τροποποιηθούν στη θέση τους! Επομένως, δεν μπορείτε να τροποποιήσετε
        μια παγωμένη συστοιχία Fixnums. (Τα Fixnums και τα Ακαταστήματα δεν έχουν μεθόδους
        bang για να δοκιμάσουν με demo). BTW: το object_id του <span class="code-inline">Fixnum</span>
        είναι <span class="code-inline">value * 2 + 1</span>'
    bang:
      title: "(to! || ! to!) == ?"
      description: Το bang χαρακτηρίζει τη μέθοδο ως επικίνδυνη. Γιατί; Συχνά, μπορεί
        να τροποποιήσει τον παραλήπτη, έναντι της μη τροποποιητικής έκδοσης χωρίς έκρηξη.
        ΜΗΝ ΑΝΑΚΑΛΥΨΕΤΕ ΟΤΙ ΔΕΝ ΕΠΙΣΤΡΕΨΟΥΝ ΤΗΝ ΙΔΙΑ ΑΞΙΑ, ΩΣ ΕΚΔΗΛΩΣΗ ΜΗ ΜΠΑΝΓΚ! Πολλοί
        επιστρέφουν χωρίς να χρειάζεται αλλαγή!
    array:
      title: Μια σειρά Νέων Γκότσας
      description: Η προεπιλεγμένη τιμή που δίνεται ως αντικείμενο είναι το ίδιο αντικείμενο
        για κάθε υποδοχή! Η μεταλλαγή μεταλλάζει την προεπιλογή για όλους. Η αρχική
        τιμή που δίνεται ως μπλοκ υπολογίζεται ξεχωριστά για κάθε υποδοχή. Χρησιμοποιήστε
        αυτό το για να δημιουργήσετε νέες λέξεις για κάθε ένα.
    hash:
      title: Κάνοντας ένα Hash από αυτό
      description: 'Κυρίως το ίδιο πρόβλημα (και λύση) με τους πίνακες. ΠΕΡΙΣΣΟΤΕΡΑ
        GOTCHAS: δημιουργεί ένα νέο αντικείμενο σε κάθε πρόσβαση στην κενή υποδοχή!
        Μπορεί να δημιουργήσει υπερβολικό αριθμό νέων αντικειμένων. ερείπια ελέγχου
        &quot;πραγματικών&quot; περιεχομένων ή μέτρησης (μηδενικός έλεγχος, μέγεθος,
        κλπ.).'
    rescue:
      title: Με Διάσωση, Ρίξτε μια Γραμμή, Θα Προσπαθώ να την Πιάσω!
      description: Στο Ruby, το throw and catch δεν είναι για εξαιρέσεις! Πρόκειται
        για προηγμένο έλεγχο ροής, για έξοδο από βαθιά φωλιά. Το Ruby χρησιμοποιεί αύξηση
        και διάσωση για εξαιρέσεις.
    to_str:
      title: to_s VS to_str
      description: '<span class="code-inline">to_s</span> ορίζεται σε κάθε αντικείμενο
        και πάντα θα επιστρέφει κάτι. <span class="code-inline">to_str</span> ορίζεται
        μόνο σε αντικείμενα που έχουν συμβολοσειρά. Για παράδειγμα, το <span class="code-inline">Symbol</span>
        έχει <span class="code-inline">to_str</span> αλλά το <span class="code-inline">Array</span>
        δεν το κάνει. Έτσι, μπορείτε να χρησιμοποιήσετε το <span class="code-inline">obj.respond_to?(:to_str)</span> αντί για κάτι σαν <span class="code-inline">obj.is_a?(String)</span>
        αν θέλετε να επωφεληθείτε από την πληκτρολόγηση πάπιας χωρίς να ανησυχείτε για
        το αν η τάξη με την οποία εργάζεστε είναι μια υποκατηγορία του <span class="code-inline">String</span>
        δεν.'
    missing:
      title: Πρέπει να συντονιστείτε με το method_missing και answer_to_missing;
      description: 'Όταν επιτακτικούς <span class="code-inline">method_missing,</span>
        θυμηθείτε να παρακάμψετε <span class="code-inline">respond_to_missing;</span>
        επισης. Όταν χρησιμοποιείτε τη μέθοδο method_missing για να έχετε ένα αντικείμενο
        να επιστρέψει κάτι σε μια κλήση μεθόδου, βεβαιωθείτε πάντοτε ότι επαναπροσδιορίσατε
        το answer_to_missing ;. Αν δεν το κάνετε, τίποτα δεν θα σπάσει με μια πρώτη
        ματιά, αλλά τελικά θα αντιμετωπίσετε προβλήματα. Εξετάστε αυτήν την κατηγορία:'
      respond_to: 'Πολλοί κώδικες (πολύτιμοι λίθοι ή δικοί σας) βασίζονται στο answer_to;
        (για έναν καλό λόγο). Χρειάζεται να διορθώσετε την απάντηση_εξέτασης; επισης:'
    exception:
      title: διάσωση από StandardError, όχι Εξαίρεση
      description: 'Μην διασώζετε την εξαίρεση, τη διάσωση του StandardError Πριν από
        τη ρητή διάσωση της Εξαίρεσης θα διασώσει ακόμη και τα μη ανακτήσιμα σφάλματα
        όπως SyntaxError, LoadError και Interrupt. Εάν παραλείψετε τον τύπο εξαίρεσης,
        τότε ο Ruby θα πιάσει μόνο το StandardError, το οποίο είναι πιθανόν αυτό που
        θέλετε:'
    private:
      title: Τα ιδιωτικά δεδομένα δεν είναι πραγματικά, και δεν είναι καθόλου w / class
        μεθόδους
      description: Υπάρχει ένας τρόπος για να κάνετε τις μεθόδους της τάξης ιδιωτικές
        στο Ruby, απλά πρέπει να περάσετε από κάποια στεφάνια. Err, εννοώ τη χρήση της
        <span class="code-inline">class << self</span> σύνταξης. Αυτή η ιδιαιτερότητα
        ωθεί ένα δείγμα singleton στην τάξη δημιουργώντας αποτελεσματικά μεθόδους τάξης.
    braces:
      title: Βραχίονες ενάντια στο φινίρισμα
      description: Η γενική σύμβαση είναι να χρησιμοποιείτε <span class="code-inline">do .. end</span> για μπλοκ πολλαπλών γραμμών και σγουράκια για μπλοκ μονής γραμμής,
        αλλά υπάρχει επίσης μια διαφορά μεταξύ των δύο που μπορούν να απεικονιστούν.
        Αυτό σημαίνει ότι το <span class="code-inline">{}</span> έχει υψηλότερο προβάδισμα
        από ό, <span class="code-inline">do .. end</span>, οπότε κρατήστε αυτό κατά
        νου όταν αποφασίζετε τι θέλετε να χρησιμοποιήσετε.
    module:
      title: 'τάξη Foo :: Bar, που ορίζεται έξω από το Module Foo, δεν θα δει μέσα στο
        Foo'
      description: Μπορείτε να σκεφτείτε κάθε εμφάνιση του <span class="code-inline">module
        Something</span> , <span class="code-inline">class Something</span> ή <span class="code-inline">def
        something</span> ως &quot;πύλη&quot; σε ένα νέο πεδίο. Όταν ο Ruby ψάχνει για τον
        ορισμό ενός ονόματος που έχει παραπεμφθεί, εξετάζει πρώτα το τρέχον πεδίο (τη
        μέθοδο, την κλάση ή την ενότητα) και αν δεν βρεθεί πού θα πάει πίσω από το καθένα
        που περιέχει &quot;πύλη&quot; και αναζήτηση το πεδίο εφαρμογής.
    credits: 'Κωδικός και άρθρα λήφθηκαν από πόρους:'
  meta_programming:
    title: Μεταπρογραμματισμός
    description: Το μεταπρογραμματισμό είναι η σύνταξη προγραμμάτων ηλεκτρονικών υπολογιστών
      που γράφουν ή χειρίζονται άλλα προγράμματα (ή τους ίδιους) ως δεδομένα τους ή
      που κάνουν μέρος του έργου κατά τη μεταγλώττιση που διαφορετικά θα γινόταν κατά
      το χρόνο εκτέλεσης. Σε πολλές περιπτώσεις, αυτό επιτρέπει στους προγραμματιστές
      να κάνουν περισσότερα κατά το ίδιο χρονικό διάστημα που θα χρειαζόντουσαν για
      να γράψουν ολόκληρο τον κώδικα με το χέρι, ή δίνει μεγαλύτερη ευελιξία στα προγράμματα
      για να χειριστούν αποτελεσματικά νέες καταστάσεις χωρίς αναδιπλασιασμό. Το μεταγραμματισμό
      εγγράφει κώδικα που γράφει τον κώδικα κατά τη διάρκεια του χρόνου εκτέλεσης για
      να διευκολύνει τη ζωή σας.
    dynamic_dispatch:
      title: Δυναμική αποστολή
      description: Σας επιτρέπει να στέλνουμε μηνύματα <span class="code-inline">subject.public_send
        (message, * arguments)</span>
    dynamic_method:
      title: Δυναμική μέθοδος
      description: 'Επιτρέπει τη δυναμική δημιουργία μεθόδων <span class="code-inline">define_method:
        method_name {block που γίνεται body method}</span>'
    ghost_methods:
      title: Μέθοδοι φάντασμα
      description: Πιάνοντας &quot;μεθόδους φάντασμα&quot; και προωθώντας τους σε μια
        άλλη μέθοδο Ενώ πιθανώς προσθέτοντας λογική γύρω από την κλήση. Χρησιμοποιεί
        τη <span class="code-inline">μέθοδο αποδοχής</span>
    dynamic_proxies:
      title: Δυναμικά πληρεξούσια
      description: 'Για παράδειγμα, μπορείτε να δώσετε φανταστικές μεθόδους χρησιμοποιώντας
        τη μέθοδο <span class="code-inline">method_missing</span> για να αναλύσετε το
        εισερχόμενο μήνυμα (π.χ. <span class="code-inline">get_name</span>, <span class="code-inline">get_age</span>
        ) και να μεταβιβάσετε σε άλλη μέθοδο όπως <span class="code-inline">get (:data_type)</span>
        όπου <span class="code-inline">:data_type</span> είναι <span class="code-inline">:name</span> ή <span class="code-inline">:age</span> .'
      more: Αν (μετά την ανάλυση) εντοπίσετε ένα ζήτημα απόδοσης με τη χρήση της μεθόδου
        <span class="code-inline">method_missing</span> μπορείτε να χρησιμοποιήσετε την
        τεχνική &quot;Δυναμική μέθοδος&quot; για να δημιουργήσετε μια πραγματική μέθοδο
        μετά την παραλαβή του μηνύματος από την `method_missing` την πρώτη φορά.
  solid_principles:
    good: Καλός!
    bad: Κακό!
    title: Στερεές αρχές
    description: Στον προγραμματισμό υπολογιστών, το SOLID (ατομική ευθύνη, ανοικτή
      κλειστή, υποκατάστατο Liskov, διαχωρισμός διεπαφών και αντιστροφή εξάρτησης) είναι
      ένα μνημονικό ακρωνύμιο που εισήγαγε ο Michael Feathers για τις &quot;Πρώτες Πέντε
      Αρχές&quot; που ο Robert C. Martin στις αρχές της δεκαετίας 2000 για πέντε βασικές
      αρχές αντικειμενοστρεφούς προγραμματισμού και σχεδίασης. Η πρόθεση είναι ότι αυτές
      οι αρχές, όταν εφαρμοστούν μαζί, θα κάνουν πιο πιθανό ότι ένας προγραμματιστής
      θα δημιουργήσει ένα σύστημα που είναι εύκολο να διατηρηθεί και να επεκταθεί με
      την πάροδο του χρόνου. Οι αρχές του SOLID είναι κατευθυντήριες οδηγίες που μπορούν
      να εφαρμοστούν κατά την επεξεργασία λογισμικού για την κατάργηση των μυρωδιών
      του κώδικα προκαλώντας τον προγραμματιστή να επαναπροσδιορίσει τον πηγαίο κώδικα
      του λογισμικού έως ότου είναι τόσο ευανάγνωστο και εκτάσιμο. Είναι μέρος μιας
      συνολικής στρατηγικής ευέλικτης και προσαρμοστικής ανάπτυξης λογισμικού.
    single:
      title: Αρχή της ενιαίας ευθύνης
      description: Η Αρχή της Ενιαίας Ευθύνης είναι η πιο αφηρημένη από τη δέσμη. Βοηθάει
        στην διατήρηση των τάξεων και των μεθόδων μικρών και συντηρητικών. Εκτός από
        τη διατήρηση μικρών και εστιασμένων τάξεων, διευκολύνεται επίσης η κατανόησή
        τους. Ένα παράδειγμα αυτού του γεγονότος μπορεί να είναι η προσθήκη υποστήριξης
        για την αποστολή μιας περίληψης ηλεκτρονικού ταχυδρομείου για τις προμήθειες
        ενός συγκεκριμένου ατόμου μετά από την επισήμανση μιας συναλλαγής που έχει υποστεί
        επεξεργασία. Το γεγονός ότι μπορούμε να εντοπίσουμε πολλούς λόγους αλλαγής σημάτων
        αποτελεί παραβίαση της αρχής της ενιαίας ευθύνης.
    open_close:
      title: Ανοικτή / κλειστή αρχή
      description: Η Αρχή Ανοικτού / Κλειστού αναφέρει ότι οι κλάσεις ή οι μέθοδοι θα
        πρέπει να είναι ανοικτές για επέκταση, αλλά κλειστές για τροποποίηση. Αυτό μας
        λέει ότι θα πρέπει να προσπαθήσουμε για αρθρωτά σχέδια που μας επιτρέπουν να
        αλλάξουμε τη συμπεριφορά του συστήματος χωρίς να κάνουμε αλλαγές στις ίδιες
        τις τάξεις. Αυτό επιτυγχάνεται γενικά με τη χρήση προτύπων όπως το σχέδιο στρατηγικής.
      after: Με αυτό το refactoring έχουμε κάνει δυνατή την προσθήκη νέων παραμέτρων
        χωρίς να αλλάξουμε κανέναν κωδικό. Οποιαδήποτε πρόσθετη συμπεριφορά θα απαιτήσει
        μόνο την προσθήκη νέου χειριστή. Αυτό κάνει το FileParser επαναχρησιμοποιήσιμο
        και σε πολλές περιπτώσεις θα μας κρατήσει σε συμμόρφωση με την Αρχή της Ενιαίας
        Ευθύνης καθώς και μας ενθαρρύνει να δημιουργήσουμε μικρότερες πιο εστιασμένες
        τάξεις.
    liskov:
      title: Αρχή αντικατάστασης του Liskov
      description: Η αρχή του Liskov τείνει να είναι το πιο δύσκολο να κατανοηθεί. Η
        αρχή ορίζει ότι θα πρέπει να μπορείτε να αντικαταστήσετε τυχόν παρουσίες μιας
        μητρικής τάξης με μια παρουσία ενός από τα παιδιά της χωρίς να δημιουργήσετε
        τυχόν απροσδόκητες ή λανθασμένες συμπεριφορές.
    segregation:
      title: Αρχή αναστροφής εξαρτήσεων
      description: 'Η αρχή ορίζει ότι ένας πελάτης δεν πρέπει να αναγκάζεται να εξαρτάται
        από μεθόδους που δεν χρησιμοποιεί. Σε αυτό το παράδειγμα, υπάρχουν κλάσεις υπολογιστών,
        προγραμματιστών και τεχνικών. Τόσο ο προγραμματιστής όσο και ο τεχνικός χρησιμοποιούν
        τον υπολογιστή με διαφορετικό τρόπο. Ο προγραμματιστής χρησιμοποιεί τον υπολογιστή
        για πληκτρολόγηση, αλλά ο τεχνικός γνωρίζει πώς να αλλάξει το σκληρό δίσκο του
        υπολογιστή. Ποια αρχή διαχωρισμού διασύνδεσης (ISP) επιβάλλει είναι ότι μια
        τάξη δεν πρέπει να εξαρτάται από τις μεθόδους που δεν χρησιμοποιεί. Στην περίπτωσή
        μας, ο προγραμματιστής συνδέεται άσκοπα με τη μέθοδο # change_hard_drive του
        υπολογιστή επειδή δεν το χρησιμοποιεί, αλλά οι αλλαγές κατάστασης που επιβάλλει
        αυτή η μέθοδος μπορούν να επηρεάσουν τον προγραμματιστή. Ας επαναπροσδιορίσουμε
        τον κώδικα για να υπακούσουμε στο LSP.'
      after: Μετά από αυτό το επανασχηματιστή ο Τεχνικός χρησιμοποιεί ένα διαφορετικό
        αντικείμενο από τον τύπο ComputerInternals που είναι απομονωμένο από την κατάσταση
        του Υπολογιστή. Η κατάσταση του αντικειμένου του υπολογιστή μπορεί να επηρεαστεί
        από τον προγραμματιστή, αλλά οι αλλαγές δεν θα επηρεάσουν τον τεχνικό με οποιονδήποτε
        τρόπο.
    di:
      title: Αρχή αναστροφής εξαρτήσεων
      description: Η Αρχή Εξέλιξης Εξάρτησης έχει να κάνει με αντικείμενα υψηλού επιπέδου
        (think business logic) που δεν εξαρτώνται από τις λεπτομέρειες υλοποίησης χαμηλού
        επιπέδου (think database querying και IO). Αυτό μπορεί να επιτευχθεί με δακτυλογράφηση
        και την αρχή της εξάρτησης από την εξάρτηση. Συχνά αυτό το πρότυπο χρησιμοποιείται
        για την επίτευξη της ανοιχτής / κλειστής αρχής που συζητήσαμε παραπάνω. Στην
        πραγματικότητα, μπορούμε να ξαναχρησιμοποιήσουμε το ίδιο παράδειγμα ως επίδειξη
        αυτής της αρχής. Τώρα υπάρχει μια κλάση μορφοποίησης, αλλά έχω το hardcoded
        στην κλάση Report, δημιουργώντας έτσι μια εξάρτηση από την αναφορά στο JSONFormatter.
        Δεδομένου ότι η αναφορά είναι μια πιο αφηρημένη έννοια (υψηλού επιπέδου) από
        την JSONFormatter, διασπάμε αποτελεσματικά το DIP.
      after: Με αυτόν τον τρόπο η αναφορά δεν εξαρτάται από το JSONFormatter και μπορεί
        να χρησιμοποιήσει οποιονδήποτε τύπο μορφοποιητή που έχει μια μέθοδο που ονομάζεται
        μορφή (αυτή είναι γνωστή ως πληκτρολόγηση πάπιας). Ένα άλλο πράγμα που πρέπει
        να σημειωθεί είναι ότι έχουμε χρησιμοποιήσει για άλλη μια φορά ένεση εξάρτησης
        για την επίλυση ενός προβλήματος. Αυτή η τεχνική είναι πολύ ισχυρή όταν ο στόχος
        μας είναι η αποσύνδεση αντικειμένων και παρόλο που έχει τα ίδια αρχικά με την
        αρχή της αντιστροφής εξάρτησης (ενάντια στο μοντέλο εγχύσεων εξάρτησης), είναι
        τελείως διαφορετικές έννοιες.
  threads:
    example: Παράδειγμα
    title: Νήματα
    description: 'Σημείωση σχετικά με τον παραλληλισμό και την ταυτότητα: Η κύρια διαφορά
      μεταξύ της χρήσης διαδικασιών έναντι των νημάτων είναι ο τρόπος με τον οποίο χειρίζεται
      η μνήμη. Σε υψηλό επίπεδο, επεξεργάζεται μνήμη αντιγραφής, ενώ τα νήματα μοιράζονται
      μνήμη. Αυτό καθιστά τη διαδικασία ωοτοκία πιο αργή από το νήμα αναπαραγωγής και
      οδηγεί σε διαδικασίες που καταναλώνουν περισσότερους πόρους μόλις τρέξει. Συνολικά,
      τα θέματα συνεπάγονται λιγότερα έξοδα από τις διαδικασίες. Αυτό το API Thread
      είναι ένα API Ruby. Έχω υπαινίξει ότι οι διαφορετικές υλοποιήσεις του Ruby έχουν
      διαφορετικές υποκείμενες συμπεριφορές σπειρώματος.'
    green:
      title: Πράσινα νήματα
      description: Το Ruby 1.9 αντικατέστησε τα πράσινα νήματα με φυσικά νήματα. Ωστόσο,
        το GIL εξακολουθεί να εμποδίζει τον παραλληλισμό. Τούτου λεχθέντος, η συνοχή
        έχει βελτιωθεί χάρη στον καλύτερο προγραμματισμό. Το νέο χρονοδιάγραμμα καθιστά
        πιο αποδοτικές τις αποφάσεις μεταγωγής περιβάλλοντος, ουσιαστικά μετακινώντας
        τους σε ξεχωριστό νήμα, γνωστό ως νήμα χρονοδιακόπτη.
    gil:
      title: GIL - Κλείδωμα παγκόσμιου ερμηνευτή
      description: Η μαγνητική τομογραφία έχει μια παγκόσμια κλειδαριά ερμηνείας (GIL).
        Είναι μια κλειδαριά γύρω από την εκτέλεση του κώδικα Ruby. Αυτό σημαίνει ότι
        σε ένα περιβάλλον πολλαπλών σπειρωμάτων, μόνο ένα νήμα μπορεί να εκτελέσει τον
        κώδικα Ruby οποιαδήποτε στιγμή. Έτσι εάν έχετε 8 νήματα που δουλεύουν δυναμικά
        σε μια 8-πυρήνα μηχανή, μόνο ένα νήμα και ένας πυρήνας θα είναι απασχολημένοι
        οποιαδήποτε στιγμή . Το GIL υπάρχει για να προστατεύσει τα εσωτερικά του Ruby
        από συνθήκες φυλής που θα μπορούσαν να καταστρέψουν τα δεδομένα. Υπάρχουν επιφυλάξεις
        και βελτιστοποιήσεις, αλλά αυτό είναι το βασικό.
      example: Αυτό το απλό γεγονός είναι αυτό που κάνει τα νήματα τόσο ισχυρά, αλλά
        και αυτά που τα καθιστούν δύσκολα να δουλέψουν. Έχω ήδη δώσει μια ιδέα για το
        γιατί τα νήματα είναι καλά. εδώ είναι ένα απλό πρόγραμμα για να απεικονίσει
        τη δυσκολία τους. Εδώ μπορείτε να δείτε ότι έχουμε <span class="code-inline">10
        * 10000</span> στοιχεία σε πίνακα. Σημειώστε ότι το διαφορετικό ρουμπίνι μπορεί
        να εμφανίσει ένα διαφορετικό αποτέλεσμα. Το GIL υπάρχει μόνο σε ρουμπίνι MRI.
    mutex:
      title: Mutex - Αμοιβαία Εκτέλεση
      description: Τα mutexes παρέχουν έναν μηχανισμό για πολλαπλά νήματα για τον συγχρονισμό
        πρόσβασης σε ένα κρίσιμο τμήμα του κώδικα. Με άλλα λόγια, βοηθούν να φέρουμε
        κάποια τάξη, και κάποιες εγγυήσεις, στον κόσμο του πολυ-σπειρωτού χάους. Το
        όνομα «mutex» είναι συντομογραφία για «αμοιβαίο αποκλεισμό». Αν τυλίξετε κάποια
        ενότητα του κώδικα σας με ένα mutex, εγγυάστε ότι δεν μπορούν να εισέλθουν ταυτόχρονα
        δύο ενότητες. Τα mutexes παρέχουν έναν μηχανισμό για πολλαπλά νήματα για τον
        συγχρονισμό πρόσβασης σε ένα κρίσιμο τμήμα του κώδικα. Βοηθά να φέρει κάποια
        τάξη και κάποια εγγύηση στον κόσμο του πολυ-σπειρωμένου χάους.
      example: Σε αυτό το πρόγραμμα, δεδομένου ότι οποιοδήποτε νήμα πρέπει να κλειδώσει
        το mutex προτού να μπορέσει να σπρώξει προς το Array, υπάρχει εγγύηση ότι δεν
        θα πραγματοποιηθούν ταυτόχρονα δύο σπειρώματα. Με άλλα λόγια, αυτή η λειτουργία
        δεν μπορεί πλέον να διακοπεί πριν ολοκληρωθεί. Μόλις ένα νήμα αρχίσει να σπρώχνει
        προς τον πίνακα, κανένα άλλο νήμα δεν θα μπορεί να εισάγει αυτό το τμήμα του
        κώδικα μέχρι να ολοκληρωθεί το πρώτο νήμα. Αυτή η λειτουργία είναι τώρα ασφαλής
        για τα νήματα. Εδώ μπορείτε να δείτε ότι έχουμε <span class="code-inline">10
        * 10000</span> στοιχεία σε πίνακα. Τώρα όλα είναι τα ίδια, λόγω του mutex. Ο
        mutex ορίζει τα ίδια όρια για το νήμα. Το πρώτο νήμα που αγγίζει αυτό το κομμάτι
        κώδικα θα κλειδώσει το mutex. τότε γίνεται ο ιδιοκτήτης αυτού του mutex. Μέχρι
        να ξεκλειδώσει το κύριο πηνίο το mutex, κανένα άλλο νήμα δεν μπορεί να το κλειδώσει.
    fibers:
      title: Ίνες
      description: Οι ίνες είναι πρωτόγονα για την εφαρμογή ελαφρού συνεταιρισμού συνάθροισης
        σε Ruby. Βασικά, είναι ένα μέσο για τη δημιουργία μπλοκ κώδικα που μπορούν να
        σταματήσουν και να επαναληφθούν, σαν σπειρώματα. Η κύρια διαφορά είναι ότι δεν
        έχουν προληφθεί ποτέ και ότι ο προγραμματισμός πρέπει να γίνει από τον προγραμματιστή
        και όχι από τον VM. Σε αντίθεση με άλλα μοντέλα ελαφρών μοντέλων αδράνειας,
        κάθε ίνα έρχεται με μια μικρή στοίβα των 4KB. Αυτό επιτρέπει την παύση της ίνας
        από βαθιά ενσωματωμένες κλήσεις λειτουργίας μέσα στο μπλοκ ινών.
    rails:
      title: Ασφάλεια σπειρωμάτων με ράγες
      description: Το πρόβλημα με αυτό είναι ότι δεν υπάρχει ένας απλός τρόπος να πούμε
        με απόλυτη βεβαιότητα αν μια εφαρμογή ως σύνολο είναι ασφαλής για τα νήματα.
      global_variables: Οι συνολικές μεταβλητές είναι παγκόσμιες. Αυτό σημαίνει ότι
        μοιράζονται μεταξύ των νημάτων. Αν δεν ήσασταν πεπεισμένος ότι δεν χρησιμοποιείτε
        τις μεταβλητές μέχρι τώρα, εδώ είναι ένας άλλος λόγος να μην τις αγγίξετε ποτέ.
        Εάν θέλετε πραγματικά να μοιραστείτε κάτι παγκοσμίως σε μια εφαρμογή, είναι
        πολύ πιθανό να εξυπηρετηθείτε καλύτερα από μια σταθερή (αλλά δείτε παρακάτω),
        ούτως ή άλλως.
      class_variables: Μεταβλητές κλάσης. Για τους σκοπούς μιας συζήτησης σχετικά με
        τα θέματα, οι μεταβλητές κλάσης δεν διαφέρουν πολύ από τις παγκόσμιες μεταβλητές.
        Μοιράζονται σε όλα τα θέματα με τον ίδιο τρόπο. Το πρόβλημα δεν αφορά τόσο τη
        χρήση μεταβλητών τάξης, αλλά και τη μετάλλαξή τους. Και αν δεν πρόκειται να
        μεταλλάξετε μια τάξη μεταβλητή, σε πολλές περιπτώσεις μια σταθερά είναι πάλι
        μια καλύτερη επιλογή.
      instance_variables: Μεταβλητές στιγμιότυπων κλάσης. Αλλά ίσως έχετε διαβάσει ότι
        θα πρέπει πάντα να χρησιμοποιείτε μεταβλητές τάξης τάξης αντί για μεταβλητές
        τάξης στο Ruby. Λοιπόν, ίσως πρέπει, αλλά είναι εξίσου προβληματικές για προγράμματα
        με σπείρωμα, όπως μεταβλητές κλάσης.
      memoization: 'Η απομνημόνευση από μόνη της δεν αποτελεί θέμα ασφάλειας νήματος.
        Συχνά χρησιμοποιείται για την αποθήκευση δεδομένων σε μεταβλητές κλάσης ή μεταβλητές
        κλασσικών στιγμιότυπων (δείτε τα προηγούμενα σημεία). Ο τελεστής <span class="code-inline">||
        =</span> είναι, στην πραγματικότητα, δύο πράξεις, οπότε υπάρχει πιθανός μετασχηματισμός
        περιβάλλοντος στο μέσον του, προκαλώντας μια κατάσταση κούρσας μεταξύ των νημάτων.
        Επομένως, ακόμα κι αν χρησιμοποιείτε μόνο μεταβλητές instance, μπορεί να καταλήξετε
        σε συνθήκες αγώνα με απομνημόνευση. Μην αναμνημονεύσετε μεταβλητές κλάσης ή
        μεταβλητές κλασσικών στιγμιότυπων. Αν πρέπει να θυμηθείτε κάτι σε επίπεδο κλάσης,
        χρησιμοποιήστε αντ &#39;αυτού τοπικές μεταβλητές νήματος (<span class="code-inline">Thread.current
        [: baz</span>). Να γνωρίζετε, ωστόσο, ότι εξακολουθεί να είναι μια παγκόσμια
        μεταβλητή.'
    config:
      title: Διαμορφώστε την ασφάλεια του νήματος !?
      description: Η κλήση αυτής της μεθόδου ορίζει τέσσερις επιλογές στη διαμόρφωση
        της εφαρμογής μας. Ας περάσουμε από κάθε επιλογή και να μιλήσουμε για το τι
        κάνει.
      frameworks: 'Πλαίσια προφόρτωσης: Η πρώτη επιλογή @preload_frameworks κάνει σχεδόν
        αυτό που λέει, αναγκάζει το πλαίσιο Rails να φορτωθεί ανυπόμονα στην εκκίνηση.
        Όταν αυτή η επιλογή δεν είναι ενεργοποιημένη, οι κλάσεις πλαισίων φορτώνονται
        λείο μέσω autoload. Σε περιβάλλοντα με πολλαπλά σπειρώματα, το πλαίσιο πρέπει
        να φορτωθεί με ανυπομονησία πριν από τη δημιουργία οποιωνδήποτε κλωστών λόγω
        προβλημάτων ασφαλείας με νήματα με αυτόματη μετακίνηση. Γνωρίζουμε ότι η φόρτωση
        του πλαισίου δεν είναι threadsafe, οπότε η στρατηγική είναι να φορτώσει όλα
        πριν από οποιαδήποτε θέματα είναι έτοιμα να χειριστούν τα αιτήματα.'
      cache: 'Κλάση προσωρινής αποθήκευσης: Η επιλογή @cache_classes ελέγχει εάν οι
        κατηγορίες επαναφορτώνουν ή όχι. Θυμηθείτε όταν κάνετε &quot;TDD&quot; στην
        αίτησή σας; Αλλάζετε έναν ελεγκτή και, στη συνέχεια, φορτώνετε ξανά τη σελίδα
        για να &quot;το δοκιμάσετε&quot; και να δείτε ότι τα πράγματα άλλαξαν; Ya, αυτό
        ελέγχει αυτή η επιλογή. Όταν αυτή η επιλογή είναι ψευδής, όπως και στην εξέλιξη,
        οι κλάσεις σας θα φορτωθούν ξανά όταν τροποποιηθούν. Χωρίς αυτήν την επιλογή,
        δεν θα μπορούσαμε να κάνουμε το &quot;F5DD&quot; μας (ναι, αυτό είναι το F5
        Driven Development). Στην παραγωγή, γνωρίζουμε ότι τα μαθήματα δεν πρόκειται
        να τροποποιηθούν με τη σειρά τους, οπότε η δουλειά για να καταλάβουμε αν θα
        ξαναφορτώσουμε τα μαθήματα απλώς σπαταλάει πόρους, οπότε είναι λογικό να μην
        επαναφορτωθούν οι ορισμοί των τάξεων.'
      di: 'Φόρτωση εξαρτήσεων: Αυτή η επιλογή, @dependency_loading, ελέγχει την φόρτωση
        του κώδικα όταν υπάρχουν ελλείψεις σταθερών. Για παράδειγμα, ένας ελεγκτής αναφέρει
        το μοντέλο χρήστη, αλλά η σταθερά χρήστη δεν έχει οριστεί. Σε αυτή την περίπτωση,
        εάν η @dependency_loading είναι αληθής, το Rails θα βρει το αρχείο που περιέχει
        τον χρήστη σταθερό και θα φορτώσει αυτό το αρχείο. Έχουμε ήδη μιλήσει για το
        πώς η φόρτωση του κώδικα δεν είναι ασφαλής για τα νήματα, οπότε η ιδέα εδώ είναι
        ότι πρέπει να φορτώσουμε το πλαίσιο, να φορτώσουμε όλοι τον κωδικό χρήστη και
        στη συνέχεια να απενεργοποιήσουμε τη φόρτωση εξάρτησης. Μόλις απενεργοποιηθεί
        η φόρτωση εξάρτησης, θα πρέπει να φορτωθεί ο κωδικός πλαισίου και ο κωδικός
        εφαρμογής και όλες οι ελλείπουσες σταθερές θα αυξήσουν μόνο μια εξαίρεση παρά
        την προσπάθεια φόρτωσης κώδικα. Εμείς δικαιολογούμε την απενεργοποίηση αυτής
        της επιλογής στην παραγωγή επειδή (όπως αναφέρθηκε προηγουμένως) η φόρτωση του
        κώδικα δεν είναι threadsafe, και αναμένουμε ότι θα έχει φορτωθεί όλος ο κώδικας
        πριν οποιαδήποτε θέματα μπορούν να χειριστούν τα αιτήματα.'
      concurrency: 'Επιτρέποντας ταυτόχρονο: Η επιλογή @allow_concurrency ελέγχει εάν
        το μεσαίο λογισμικό Rack :: Lock χρησιμοποιείται ή όχι στη στοίβα σας. Rack
        :: Lock κλειδώνει ένα mutex γύρω από το αίτημά σας. Η ιδέα είναι ότι αν έχετε
        κώδικα που δεν είναι threadsafe, αυτό το mutex θα εμποδίσει τα πολλαπλά threads
        να εκτελούν τον κωδικό ελεγκτή σας ταυτόχρονα. Όταν προστατεύετε το νήμα! έχει
        οριστεί, το ενδιάμεσο λογισμικό έχει αφαιρεθεί και ο κωδικός ελεγκτή μπορεί
        να εκτελεστεί παράλληλα.'
    credits: 'Κωδικός και άρθρα λήφθηκαν από πόρους:'
  ruby_meister:
    title: Γίνετε Ruby Meister
    description: Σε αυτή τη συζήτηση, θα εξετάσουμε το μακρύ ταξίδι από το να είσαι
      αρχάριος του Ruby στην επίτευξη πραγματικής μάστερ του Ruby και θα προσπαθήσουμε
      να το συντομεύσουμε λίγο για σας, μοιράζοντας κάποια σημαντική εικόνα. Ένας κύριος
      ρουμίστας έχει ένα μεγάλο θεωρητικό υπόβαθρο, βασίζεται σε μια εκτενή εργαλειοθήκη,
      έχει βαθιά κατανόηση των βασικών αξιών και αρχών του Ruby και πάντα τινάζει τις
      δεξιότητές τους. Ίσως να λέτε στον εαυτό σας &quot;Πω πω, αυτό είναι πολύ αόριστο!&quot;,
      Αλλά αν παρακολουθήσετε αυτή τη σύνοδο, σας υπόσχομαι ότι θα είστε διαφωτισμένοι,
      διασκεδασμένοι και θα το απολαύσετε απόλυτα! Ακούγεται καλό? Τα σπουδαία βιβλία
      θα είναι μέρος των πόρων που θα πρότεινα στους ανθρώπους να βελτιώσουν τις δεξιότητές
      τους.
    video: Το μακρύ ταξίδι στην κυριαρχία του Ruby από τον Bozhidar Batsov.
    computer_science_fundamentals:
      title: Βασικές αρχές της Πληροφορικής
      articles:
        - name: inside_machine
          title: 'Μέσα στο μηχάνημα: Εικονογραφημένη εισαγωγή σε μικροεπεξεργαστές και
            αρχιτεκτονική υπολογιστών'
          description: Οι υπολογιστές εκτελούν αναρίθμητες εργασίες που κυμαίνονται
            από την κρίσιμη για την ψυχαγωγία επιχείρηση, αλλά ανεξάρτητα από το πόσο
            διαφορετικά μπορεί να φαίνονται και να συμπεριφέρονται, είναι όλοι εκπληκτικά
            παρόμοιοι στη βασική λειτουργία. Μόλις καταλάβετε πώς λειτουργεί η μικροεπεξεργαστή
            ή η κεντρική μονάδα επεξεργασίας (CPU), θα έχετε μια σταθερή αντίληψη των
            θεμελιωδών εννοιών στην καρδιά όλων των σύγχρονων υπολογιστών.
        - name: code
          title: 'Κωδικός: Η κρυμμένη γλώσσα του υλικού και του λογισμικού του υπολογιστή'
          description: Τι κάνουν οι φανοί, η βρετανική εισβολή, οι μαύρες γάτες και
            οι τέντες με τους υπολογιστές; Στο CODE, μας δείχνουν τους έξυπνους τρόπους
            με τους οποίους χειριζόμαστε τη γλώσσα και επινοούμε νέα μέσα επικοινωνίας
            μεταξύ μας. Και μέσω του CODE, βλέπουμε πως αυτή η εφευρετικότητα και ο
            πολύ ανθρώπινος καταναγκασμός μας να επικοινωνήσουμε οδήγησαν τις τεχνολογικές
            καινοτομίες των τελευταίων δύο αιώνων.
        - name: concrete_math
          title: 'Σκυροδεματικά Μαθηματικά: Ένα Ίδρυμα Πληροφορικής'
          description: Αυτό το βιβλίο εισάγει τα μαθηματικά που υποστηρίζουν τον προηγμένο
            προγραμματισμό υπολογιστών και την ανάλυση αλγορίθμων. Ο πρωταρχικός στόχος
            των γνωστών συγγραφέων του είναι να προσφέρει μια σταθερή και σχετική βάση
            μαθηματικών δεξιοτήτων - τις δεξιότητες που απαιτούνται για την επίλυση
            σύνθετων προβλημάτων, την αξιολόγηση φρικτών ποσών και την ανακάλυψη λεπτών
            προτύπων στα δεδομένα. Είναι ένα αναπόφευκτο κείμενο και αναφορά όχι μόνο
            για τους επιστήμονες υπολογιστών - οι ίδιοι οι συγγραφείς βασίζονται σε
            αυτό! - αλλά για τους σοβαρούς χρήστες των μαθηματικών σε σχεδόν κάθε πειθαρχία.
        - name: sicp
          title: Δομή και ερμηνεία προγραμμάτων ηλεκτρονικών υπολογιστών
          description: 'Η διάρθρωση και η ερμηνεία των προγραμμάτων ηλεκτρονικών υπολογιστών
            είχαν δραματική επίδραση στα προγράμματα σπουδών των υπολογιστών κατά την
            τελευταία δεκαετία. Αυτή η πολυαναμενόμενη αναθεώρηση περιέχει αλλαγές σε
            όλο το κείμενο. Υπάρχουν νέες εφαρμογές των περισσότερων από τα σημαντικότερα
            συστήματα προγραμματισμού στο βιβλίο, συμπεριλαμβανομένων των διερμηνέων
            και των μεταγλωττιστών, και οι συγγραφείς έχουν ενσωματώσει πολλές μικρές
            αλλαγές που αντανακλούν την εμπειρία τους διδάσκοντας το μάθημα στο MIT
            από την πρώτη έκδοση. Έχει εισαχθεί ένα νέο θέμα το οποίο τονίζει τον κεντρικό
            ρόλο που διαδραματίζουν οι διαφορετικές προσεγγίσεις στην αντιμετώπιση του
            χρόνου στα υπολογιστικά μοντέλα: αντικείμενα με κατάσταση, παράλληλο προγραμματισμό,
            λειτουργικό προγραμματισμό και τεμπέλη αξιολόγηση και μη καθοριστικό προγραμματισμό.'
        - name: design_programms
          title: 'Πώς να σχεδιάσετε προγράμματα: Εισαγωγή στον προγραμματισμό και τον
            υπολογισμό'
          description: Αυτή η εισαγωγή στον προγραμματισμό τοποθετεί την επιστήμη των
            υπολογιστών στον πυρήνα μιας φιλελεύθερης εκπαίδευσης των τεχνών. Σε αντίθεση
            με άλλα εισαγωγικά βιβλία, επικεντρώνεται στη διαδικασία σχεδιασμού του
            προγράμματος. Αυτή η προσέγγιση ενθαρρύνει μια ποικιλία κριτικών δεξιοτήτων,
            αναλυτικής σκέψης, δημιουργικής σύνθεσης και προσοχής στη λεπτομέρεια -
            που είναι σημαντικές για όλους, όχι μόνο για τους μελλοντικούς προγραμματιστές
            υπολογιστών. Το βιβλίο εκθέτει τους αναγνώστες σε δύο θεμελιωδώς νέες ιδέες.
            Πρώτον, παρουσιάζει κατευθυντήριες γραμμές σχεδιασμού προγράμματος που δείχνουν
            στον αναγνώστη πώς να αναλύει μια δήλωση προβλήματος. πώς να διατυπώσουμε
            συνοπτικούς στόχους. πώς να δημιουργήσετε παραδείγματα. πώς να αναπτύξετε
            μια περίληψη της λύσης, με βάση την ανάλυση; πώς να τελειώσετε το πρόγραμμα?
            και πώς να δοκιμάσετε.
        - name: algorithm_manual
          title: Το Εγχειρίδιο Σχεδιασμού Αλγορίθμου
          description: Αυτή η πρόσφατα αναπτυγμένη και ενημερωμένη δεύτερη έκδοση του
            κλασικού κλασικού μοντέλου συνεχίζει να λαμβάνει το &quot;μυστήριο&quot;
            από το σχεδιασμό αλγορίθμων και την ανάλυση της αποτελεσματικότητας και
            της αποδοτικότητάς τους. Με την επέκταση της πρώτης έκδοσης, το βιβλίο χρησιμεύει
            τώρα ως το κύριο βιβλίο επιλογής για μαθήματα σχεδιασμού αλγορίθμων διατηρώντας
            παράλληλα την κατάστασή του ως κορυφαίου πρακτικού οδηγού αναφοράς στους
            αλγόριθμους για προγραμματιστές, ερευνητές και φοιτητές.
        - name: cormen
          title: Εισαγωγή στους αλγορίθμους, 3η έκδοση (The MIT Press)
          description: Ορισμένα βιβλία σχετικά με τους αλγόριθμους είναι αυστηρά αλλά
            ελλιπή. άλλοι καλύπτουν μάζες υλικού αλλά στερούνται αυστηρότητας. Η εισαγωγή
            στους Αλγόριθμους συνδυάζει μοναδικά την αυστηρότητα και την πληρότητα.
            Το βιβλίο καλύπτει ένα ευρύ φάσμα αλγορίθμων σε βάθος, αλλά κάνει το σχεδιασμό
            και την ανάλυσή τους προσιτό σε όλα τα επίπεδα των αναγνωστών. Κάθε κεφάλαιο
            είναι σχετικά αυτοτελές και μπορεί να χρησιμοποιηθεί ως μονάδα σπουδών.
            Οι αλγόριθμοι περιγράφονται στα Αγγλικά και σε έναν ψευδοκώδικα σχεδιασμένο
            για να είναι αναγνώσιμος από οποιονδήποτε έχει κάνει λίγο προγραμματισμό.
            Οι εξηγήσεις κρατήθηκαν στοιχειώδεις χωρίς να θυσιαστεί το βάθος της κάλυψης
            ή η μαθηματική αυστηρότητα.
        - name: compilers
          title: 'Συγγραφείς: αρχές, τεχνικές και εργαλεία (2η έκδοση)'
          description: 'Οι μεταγλωττιστές: Αρχές, Τεχνικές και Εργαλεία, γνωστά σε καθηγητές,
            φοιτητές και προγραμματιστές παγκοσμίως, όπως το βιβλίο &quot;Dragon Book&quot;,
            διατίθενται σε μια νέα έκδοση. Κάθε κεφάλαιο έχει αναθεωρηθεί πλήρως για
            να αντικατοπτρίζει τις εξελίξεις στην τεχνολογία λογισμικού, τις γλώσσες
            προγραμματισμού και την αρχιτεκτονική υπολογιστών που έχουν συμβεί από το
            1986 όταν δημοσιεύθηκε η τελευταία έκδοση. Οι συγγραφείς, αναγνωρίζοντας
            ότι λίγοι αναγνώστες θα συνεχίσουν να κατασκευάζουν έναν μεταγλωττιστή,
            διατηρούν την εστίασή τους στην ευρύτερη σειρά προβλημάτων που αντιμετωπίζει
            ο σχεδιασμός λογισμικού και η ανάπτυξη λογισμικού.'
        - name: c_lang
          title: Γ γλώσσα προγραμματισμού, 2η έκδοση
          description: Οι συγγραφείς παρουσιάζουν τον πλήρη οδηγό για τον πρότυπο προγραμματισμό
            γλωσσών C της ANSI. Γράφηκαν από τους προγραμματιστές του C, αυτή η νέα
            έκδοση βοηθάει τους αναγνώστες να συμβαδίζουν με το οριστικοποιημένο πρότυπο
            ANSI για το C, ενώ δείχνει πώς μπορούν να επωφεληθούν από την πλούσια δέσμη
            φορέων της C, την οικονομία της έκφρασης, τη βελτιωμένη ροή ελέγχου και
            τις δομές δεδομένων. Το 2 / E έχει ξαναγραφεί πλήρως με πρόσθετα παραδείγματα
            και σύνολα προβλημάτων για να διευκρινιστεί η εφαρμογή δύσκολων γλωσσικών
            δομών. Για χρόνια, οι προγραμματιστές C έχουν αφήσει την K &amp; R να τους
            καθοδηγήσει για την οικοδόμηση καλά δομημένων και αποδοτικών προγραμμάτων.
            Τώρα, αυτή η ίδια βοήθεια είναι διαθέσιμη σε όσους εργάζονται με τους μεταγλωτιστές
            ANSI. Περιλαμβάνει λεπτομερή κάλυψη της γλώσσας C συν το επίσημο εγχειρίδιο
            αναφοράς γλωσσών C για άμεση βοήθεια με τη σύνταξη συμβολισμό, δηλώσεις,
            αλλαγές ANSI, κανόνες εφαρμογής και ο κατάλογος συνεχίζεται.
    oop:
      title: Αντικειμενοστραφής προγραμματισμός
      articles:
        - name: growing
          title: Ανάπτυξη αντικειμενοστρεφούς λογισμικού, με καθοδήγηση από δοκιμές
          description: 'Η εξέλιξη με γνώμονα τις δοκιμές (TDD) είναι τώρα μια καθιερωμένη
            τεχνική για την ταχύτερη παροχή καλύτερου λογισμικού. Το TDD βασίζεται σε
            μια απλή ιδέα: Γράψτε τις δοκιμές για τον κώδικα πριν γράψετε τον ίδιο τον
            κώδικα. Ωστόσο, αυτή η &quot;απλή&quot; ιδέα απαιτεί ικανότητα και κρίση
            για να κάνει καλά. Τώρα υπάρχει ένας πρακτικός οδηγός για το TDD που σας
            μεταφέρει πέρα από τις βασικές έννοιες. Βασιζόμενοι σε μια δεκαετία εμπειρίας
            που δημιουργεί συστήματα πραγματικού κόσμου, δύο πρωτοπόροι της TDD δείχνουν
            πώς να επιτρέψουν στις δοκιμές να καθοδηγήσουν την ανάπτυξη και να «αναπτύξουν»
            λογισμικό που είναι συνεπές, αξιόπιστο και διατηρήσιμο.'
        - name: domain_driven
          title: 'Σχεδίαση που βασίζεται σε τομέα: Αντιμετώπιση της πολυπλοκότητας στην
            καρδιά του λογισμικού'
          description: Αυτό είναι ένα σοβαρό βιβλίο σχετικά με τη μοντελοποίηση τομέα
            στο σχεδιασμό λογισμικού. Η κοινωνία ανάπτυξης λογισμικού ζει από ένα κύμα
            υπερφυσικού χαρακτήρα σε ένα άλλο. OOP, πρότυπα, XP, TDD, CI / CD, BigData,
            DevOps - αυτό είναι μόνο για να αναφέρουμε μερικά. Αυτό το βιβλίο προέρχεται
            από την χρυσή εποχή του OOP. Ο συγγραφέας παραδέχεται ότι το παραδειγματικό
            προσανατολισμό δεν είναι το μόνο διαθέσιμο αλλά η προκατάληψη προς το OOP
            / OOD είναι προφανής (και δικαιολογημένη). Αυτό το βιβλίο αναφέρει πώς να
            κάνετε το μοντέλο των βασικών συστατικών λογισμικού &quot;με τον σωστό τρόπο&quot;.
    ruby:
      title: Ξέρεις ότι έκανες
      articles:
        - name: well_grounded
          title: Ο καλά γειωμένος ρουμπιστής
          description: Ο Καλά Γειτονικός Ρουβιστής, Δεύτερη Έκδοση απευθύνεται τόσο
            στους νεοφερμένους στους Ruby όσο και στους προγραμματιστές Ruby που θέλουν
            να εμβαθύνουν την κατανόησή τους στη γλώσσα. Αυτή η όμορφα γραμμένη και
            πλήρως αναθεωρημένη δεύτερη έκδοση περιλαμβάνει την κάλυψη των χαρακτηριστικών
            που είναι καινούργια στο Ruby 2.1, καθώς και την εκτεταμένη και ενημερωμένη
            κάλυψη πτυχών της γλώσσας που έχουν αλλάξει.
        - name: programming_ruby
          title: 'Προγραμματισμός Ruby: Ο πρακτικός οδηγός προγραμματιστών, δεύτερη
            έκδοση'
          description: 'Το Ruby είναι μια ολοένα και πιο δημοφιλής, πλήρως αντικειμενοστρεφής
            δυναμική γλώσσα προγραμματισμού, χαιρετισμένη από πολλούς ασκούμενους ως
            την ωραιότερη και πιο χρήσιμη γλώσσα που διατίθεται σήμερα. Όταν ο Ruby
            ξεσηκώθηκε για πρώτη φορά στη σκηνή του δυτικού κόσμου, οι πραγματικοί προγραμματιστές
            ήταν εκεί με το οριστικό εγχειρίδιο αναφοράς, Programming Ruby: The Pragmatic
            Programmer&#39;s Guide.'
        - name: ruby_programming
          title: 'Η Γλώσσα Προγραμματισμού Ruby: Όλα όσα πρέπει να ξέρετε'
          description: 'Αυτό το βιβλίο ξεκινά με ένα διδακτικό πρόγραμμα γρήγορης έναρξης
            στη γλώσσα και στη συνέχεια εξηγεί τη γλώσσα λεπτομερώς από κάτω προς τα
            επάνω: από τη λεξική και τη συντακτική δομή έως τα δεδομένα σε εκφράσεις
            και δηλώσεις και σε μεθόδους, μπλοκ, lambdas, κλεισίματα, ενότητες. Το βιβλίο
            περιλαμβάνει επίσης μια μακρά και εμπεριστατωμένη εισαγωγή στο πλούσιο API
            της πλατφόρμας Ruby, αποδεικνύοντας - με κώδικα παραδείγματος που σχολιάζει
            έντονα - τις εγκαταστάσεις της Ruby για επεξεργασία κειμένων, αριθμητικούς
            χειρισμούς, συλλογές, είσοδο / έξοδο, δικτύωση και ταυτόχρονη λειτουργία.
            Ένα ολόκληρο κεφάλαιο αφιερώνεται στις δυνατότητες μεταπρογραμματισμού του
            Ruby.'
  interview_questions:
    title: Ερωτήσεις συνέντευξης
    description: Αυτή η ενότητα διατηρεί συνδέσμους πόρων για την ανάγνωση και την προετοιμασία
      συνέντευξης
    list:
      - name: 'Toptal: Πώς να μισθώσετε ένα μεγάλο Ruby Developer'
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: 'Toptal: 21 Essential Ruby Interview Questions'
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: 'Hookops: 35 + Ruby and Rails Ερωτήσεις και απαντήσεις για συνέντευξη'
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: 'Educba: 15 πιο σημαντικές ερωτήσεις συνέντευξης Ruby και απάντηση'
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: 'Ruby Garage: Πώς να Συνέντευξη Ruby σας Σχετικά με Rails Προγραμματιστής'
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: 'RyanSobol: 15 ερωτήσεις που πρέπει να ρωτήσετε κατά τη διάρκεια μιας συνέντευξης Ruby'
        link: "https://gist.github.com/ryansobol/5252653"
      - name: 'Toptal: 9 Essential Ruby on Rails ερωτήσεις συνέντευξης'
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: Τι είναι τα Better Docs
    description: Αυτός ο ιστότοπος είναι το διαδικτυακό <a href="https://github.com/khusnetdinov/ruby.fundamental">γραφείο</a>
      προσαρμογής Github <a href="https://github.com/khusnetdinov/ruby.fundamental">Ruby.Fundamental</a>
      που συγκέντρωσε πολλά αστέρια και μεταφράστηκε στην κινεζική γλώσσα. Τα Better
      Docs σάς επιτρέπουν να βρείτε γρήγορα μια βέλτιστη πρακτική που συλλέχθηκε σε
      ένα αποθετήριο. Ακριβώς εσείς αυτό το repo σαν τον πόρο προετοιμασίας αναφοράς
      ή συνέντευξης.
    oss:
      title: Χάρη στο Open Source
      description: Τα καλύτερα Έγγραφα δημιουργήθηκαν ενώ εργαζόταν και ανακαλύφθηκε
        σχετικά με τις βέλτιστες πρακτικές και τις γνώσεις σχετικά με το ρουμπίνι, μια
        μηχανή ανοιχτού κώδικα για εφαρμογές ανάπτυξης ιστού γραμμένες σε Ruby.
      thanks: Αν η Better Docs σας βοήθησε με οποιονδήποτε τρόπο, σκεφτείτε να μας δώσετε
        ένα αστέρι στο <a href="https://github.com/howtohireme/ruby.fundamental">Github</a>
        (μας βοηθά να φτάσουμε σε περισσότερους προγραμματιστές) ή να συνεισφέρουμε
        στα έργα μας.
