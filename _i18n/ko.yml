head:
  title: BetterDocs
  metatags:
    description: 루비 예제 및 참고 자료를 사용한 기본 프로그래밍. 스레드, 솔리드 원리, 디자인 패턴, 데이터 구조, 알고리즘을 다룹니다.
    keywords: 더 나은 워드 프로세서, 루비, 기초, 루비 프로그래밍의 기초. 루비 잡기, 함수 프로그래밍, 메타 프로그래밍, 스레드,
      예제가있는 루비 솔리드 원리, 예제가있는 루비 디자인 패턴, 예제가있는 루비 알고리즘, 예제가있는 루비 데이터 구조.

content:
  menu:
    open: 메뉴 열기
    close: 메뉴 닫기
 
sidebar:
  - title: 알고리즘
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: 데이터 구조
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: 디자인 패턴
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: 기능적 프로그래밍
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: 인터뷰 질문들
    url: interview_questions
  - title: 메타 프로그래밍
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: 솔리드 원리
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: 루비 마이스터되기
    url: ruby_meister
  - title: 실
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:
  wiki: 위키 읽기
  credits: 크레딧
  page404:
    title: 페이지를 찾을 수 없음 :(
    description: 요청하신 페이지를 찾을 수 없습니다.
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: 알고리즘
    complexity:
      best: 베스트
      average: 평균
      worst: 가장 나쁜
    sorting:
      title: 정렬
      description: '정렬 알고리즘은 목록의 요소를 특정 순서로 배치하는 알고리즘입니다. 가장 많이 사용되는 주문은 숫자 순서와 사전 식
        순서입니다. 효율적인 정렬은 입력 데이터가 정렬 된 목록에 있어야하는 다른 알고리즘 (예 : 검색 및 병합 알고리즘)의 사용을 최적화하는
        데 중요합니다. 데이터를 표준화하고 인간이 읽을 수있는 결과물을 생성하는데도 종종 유용합니다.'
      bubble_sort:
        title: 버블 정렬
        description: 버블 정렬에는 삽입 정렬과 동일한 속성이 많이 있지만 오버 헤드가 약간 높습니다. 거의 정렬 된 데이터의 경우 버블
          정렬은 <span class="code-inline time">O(n)</span>을 필요로하지만 데이터를 적어도 2 회 통과해야합니다.
          반면 삽입 정렬은 1 패스와 비슷한 것을 필요로합니다.
      insertion_sort:
        title: 삽입 정렬
        description: <span class="code-inline">O(n<sup>2</sup>)</span> 최악의 경우 시간을
          갖는 기본 정렬 알고리즘 중 하나이지만 삽입 정렬은 데이터가 거의 정렬 될 때 (적응성이기 때문에) 또는 문제 크기가 작은 경우 (즉,
          오버 헤드가 적음). 이러한 이유로 병합 정렬이나 빠른 정렬과 같은 더 높은 오버 헤드 분할 및 정복 정렬 알고리즘의 경우 삽입 유형이
          종종 재귀 기본 케이스 (문제 크기가 작은 경우)로 사용되기도합니다.
      selection_sort:
        title: 선택 정렬
        description: 여기에 제시된 비교에서, 선택 정렬은 절대 사용해서는 안된다는 결론을 내릴 수 있습니다. 위의 네 가지 애니메이션이
          락 스텝 (lockstep)으로 실행됨에 유의하십시오. 따라서 런타임은 항상 2 차입니다. 그러나 선택 정렬에는 스왑 수를 최소화하는
          속성이 있습니다. 항목을 교환하는 비용이 높은 응용 프로그램에서는 선택 정렬이 매우 적합 할 수 있습니다.
      shell_sort:
        title: 셸 정렬
        description: 쉘 정렬의 최악의 경우 복잡성은 증가 순서에 따라 다릅니다. 여기서 사용되는 증분 1 4 13 40 121 ...에
          대해 시간 복잡도는 <span class="code-inline">O(n<sup><sup>3</sup>/<sub>2</sub></sup>
          )</span> 입니다. 다른 증분의 경우 시간 복잡도는 <span class="code-inline">O(n(<sup><sup>4</sup>/<sub>3</sub></sup>)</span>
          및 심지어 <span class="code-inline">O(n·lg <sub>2</sub>(n))</span>
          로 알려져 있습니다. 시간 복잡성에 대한 엄격한 상한선이나 최상의 증분 순서는 알려져 있지 않습니다. 셸 정렬은
          삽입 정렬을 기반으로하기 때문에 셸 정렬은 삽입 정렬의 적응 형 속성을 상속합니다. 셸 정렬은 각 증분에 대해 데이터를 한 번 통과해야하기
          때문에 적응은 극적이지는 않지만 중요합니다. 위에 표시된 증가 순서에는 <span class="code-inline">log<sub>3</sub>(n)</span>
          증분이 있으므로 거의 정렬 된 데이터의 시간 복잡도는 <span class="code-inline">O(n·log<sub>3</sub>(n))</span>
          입니다. 낮은 오버 헤드, 상대적으로 간단한 구현, 적응 형 속성 및 하위 2 차
          시간 복잡성 때문에 쉘 정렬은 정렬 할 데이터가 일부 응용 프로그램의 경우 <span class="code-inline">O(n・lg(n))</span>
          정렬 알고리즘 대신 실행 가능한 대체 알고리즘이 될 수 있습니다 별로 크지 않다.
      heap_sort:
        title: 햅번
        description: Heaport는 구현하기 쉽고, <span class="code-inline">O (n · lg (n))</span>
          내부 정렬을 수행하지만 안정적이지는 않습니다. 첫 번째 루프 인 <span class="code-inline">Θ (n)</span>
          &quot;heapify&quot;단계는 배열을 힙 순서로 놓습니다. 두 번째 루프, <span class="code-inline">O
          (n · lg (n))</span> &quot;정렬 감소&quot;단계는 반복적으로 최대 값을 추출하고 힙 순서를 복원합니다. 싱크
          함수는 명확성을 위해 재귀 적으로 작성됩니다. 따라서, 코드는 재귀 호출 스택을위한 <span class="code-inline">Θ
          (lg (n))</span> 공간을 필요로한다. 그러나 sink ()의 tail 재귀는 쉽게 반복으로 변환되어 <span class="code-inline">O
          (1)</span> 공간을 만듭니다. 두 단계 모두 약간 적응 적이지만, 특히 유용한 방식은 아닙니다. 거의 정렬 된 경우 heapify
          단계는 원래 순서를 파괴합니다. 반전 된 경우 heapify 단계는 배열이 힙 순서로 시작하기 때문에 가능한 한 빠릅니다. 그러나 정렬
          단계가 일반적입니다. 몇 가지 고유 한 키의 경우에는 속도 향상이 있지만 셸 정렬이나 3 방향 퀵 정렬만큼이나 다릅니다.
      merge_sort:
        title: Mergesort
        description: 'Merge 정렬은 매우 예측 가능합니다. 요소 당 <span class="code-inline">0.5lg(n)</span>
          와 <span class="code-inline">lg(n)</span> 사이의 비교와 요소 당 <span class="code-inline">lg
          (n)</span> 과 <span class="code-inline">1.5lg(n)</span>의 비교를 만듭니다. 최소 정렬은 이미 정렬 된 데이터에 대해 수행됩니다.
          최대 값은 임의의 데이터에 대해 평균적으로 달성됩니다. <span class="code-inline">Θ(n)</span>을
          사용하면 여분의 공간이 문제가되지 않는다면 병합 정렬이 탁월한 선택입니다. 구현이 간단하며 <span class="code-inline">O
          (n·lg(n))</span>의 안정적인 정렬 알고리즘입니다. 링크 된리스트를 정렬 할 때, 병합 정렬은 <span class="code-inline">Θ
          (</span> 재귀를위한 <span class="code-inline">lg(n)</span>의 여분의 공간 만 필요합니다.) 병합
          정렬은 안정성이 요구 될 때, 링크 된리스트를 정렬 할 때, 그리고 임의의 경우 액세스는 순차적 액세스 (예 : 테이프의 외부 정렬)보다
          훨씬 비쌉니다. 알고리즘의 마지막 단계에서 선형 시간의 현재 위치 병합 알고리즘이 있지만 값 비싸고 복잡합니다. 응용 프로그램의 복잡성이
          정당합니다 <span class="code-inline">Θ(n)</span> 여분의 공간을 사용할 수 없을 때 외부 정렬과 같은.'
      quick_sort:
        title: 퀵 소트
        description: 신중하게 구현하면 퀵 소트는 강력하고 오버 헤드가 적습니다. 안정적인 정렬이 필요하지 않을 때, quicksort는
          탁월한 범용 정렬입니다 - 그러나 3-way 파티셔닝 버전이 항상 대신 사용되어야합니다. 위에 표시된 2- 웨이 파티셔닝 코드는 최적의
          성능보다는 명확성을 위해 작성되었습니다. 그것은 가난한 지역성을 나타내며 비판적으로 고유 키가 거의 없을 때 <span class="code-inline">O
          (n<sup>2</sup>)</span> 시간을 나타낸다. 보다 효율적이고 강력한 2- 웨이 파티셔닝 방법은 Quicksort가
          Robert Sedgewick과 Jon Bentley가 Optimal에서 제공합니다. 강력한 파티셔닝은 피벗과 동일한 값이 많은 경우
          균형 잡힌 재귀를 생성하여 모든 입력에 대해 <span class="code-inline">O(n・lg(n))</span> 시간
          및 <span class="code-inline">O(lg(n))</span> 공간을 확률 적으로 보장합니다. 두 가지 하위 정렬을
          모두 재귀 적으로 수행하면 재귀가 균형을 이루지 않을 때 최악의 경우 재귀 스택에 <span class="code-inline">O
          (n)</span>의 추가 공간이 필요합니다. 이것은 발생할 가능성이 매우 낮지 만 작은 배열을 재귀 적으로 먼저 정렬하면 피할 수
          있습니다. 두 번째 하위 배열 정렬은 꼬리 재귀 호출이며 대신 반복으로 수행 할 수 있습니다. 이 최적화 알고리즘은 최악의 경우
          <span class="code-inline">O(lg(n))</span> 여분의 공간을 사용합니다.
      other: 다른 정렬 알고리즘
      additional: 추가 독서
    searching:
      title: 수색
      binary_search:
        title: 이진 검색
        description: 컴퓨터 과학에서, 반 간격 검색 또는 로그 검색이라고도하는 이진 검색은 정렬 된 배열 내에서 대상 값의 위치를 찾는
          검색 알고리즘입니다. 목표 값을 배열의 중간 요소와 비교합니다. 그것들이 동일하지 않으면, 표적이 거짓말을 할 수없는 절반이 제거되고
          성공할 때까지 나머지 절반이 계속 검색됩니다.
      knuth_moriss_pratt_search:
        title: 크 누스 - 모리스 - 프랫 검색
        description: 컴퓨터 과학에서, Knuth-Morris-Pratt 문자열 검색 알고리즘 (또는 KMP 알고리즘)은 불일치가 발생했을
          때 단어 자체가 충분을 구현한다는 관찰을 사용하여 주요 &quot;텍스트 문자열&quot;S 내의 &quot;단어&quot;W의 출현을
          검색합니다 정보를 사용하여 다음 일치 항목을 시작할 위치를 결정할 수 있으므로 이전에 일치하는 문자를 다시 검사하지 않아도됩니다.
      other:
        title: 기타 검색 알고리즘
        dijkstra: 다이크 스트라의 알고리즘
        kruskal: Kruskal의 알고리즘
        longest: 가장 길게 증가하는 서브 시퀀스
        telephone_number: 단어에 대한 전화 번호
    credits: 코드와 기사는 리소스에서 가져온 것입니다.
  data_structures:
    title: 데이터 구조
    description: 컴퓨터 과학에서 big O 표기법은 문제의 크기가 극도로 커짐에 따라 알고리즘의 처리 시간이 어떻게 변하는 것과 같이 알고리즘이
      입력 크기의 변화에 어떻게 반응하는지에 따라 알고리즘을 분류하는 데 사용됩니다. 분석 수 이론에서, 그것은 산술 함수의 점근선 크기를 큰 유한
      인수에서 취하는 값으로 대체하면서 &quot;오류 범람&quot;을 추정하는 데 사용됩니다. 유명한 예는 소수 정리의 나머지 항을 추정하는
      문제입니다.
    axioms:
      title: 데이터 구조의 기본적인 공리
      description: 공용 언어 런타임의 실행 시간 성능은 이제 가정 할 수있는 공리 집합에 의해 제공됩니다.
      fetch_store:
        title: 시간 가져 오기 및 저장
        description1: 메모리에서 객체에 대한 참조를 가져 오는 데 필요한 시간은 상수 <span class="code-inline">T_fetch</span>
          이며 객체에 대한 참조를 메모리에 저장하는 데 필요한 시간은 상수 <span class="code-inline">T_store</span>입니다.
        description2: Axiom에 따르면 할당 문에는 실행 시간 <span class="code-inline">T_fetch + T_store</span>가
          있습니다. 즉, 변수 x에서 객체 참조를 가져 오는 데 걸리는 시간은 <span class="code-inline">T_fetch</span>
          이고 객체 참조를 변수 y에 저장하는 데 걸리는 시간은 <span class="code-inline">T_store</span> 입니다.
        description3: 또한 실행 시간 <span class="code-inline">T_fetch + T_store</span>가 있습니다.
          왜 이런 경우인지 알아 보려면 상수 1이 값이 1 인 Fixnum 개체의
          이름을 지정합니다. 따라서 1이라는 객체에 대한 참조를 가져 오는 비용은 다른 객체에 대한 참조를 가져 오는 비용과 동일 할 것으로
          예상 할 수 있습니다.
      elementary_operations:
        title: 초등 연산 시간
        description1: 더하기, 빼기, 곱하기, 나누기 및 비교와 같은 기본 산술 연산을 수행하는 데 필요한 시간은 모두 상수입니다.
          이 시간은 각각 <span class="code-inline">T_ +, T_-, T_/, T_*, T_<</span>로 표시
          됩니다.
        description2: 우리는 <span class="code-inline">2 * T_fetch + T_ + + T_store</span>
          와 같은 명령문의 시간을 결정할 수 있습니다. 이는 변수 y와 1에서 두 개의 객체 참조를 가져와야하기 때문입니다. 더하기를 수행하여
          값이 합계 인 새 객체를 제공합니다. 변수 y에 새 객체에 대한 참조를 저장합니다.
        description3: 우리는 대안이 원래 진술과 정확히 동일한 실행 시간을 필요로한다고 가정 할 것이다.
      call_method:
        title: 호출 메소드 시간
        description1: 메소드를 호출하는 데 필요한 시간은 상수 <span class="code-inline">T_call</span>
          이며 메소드에서 리턴하는 데 필요한 시간은 상수입니다. <span class="code-inline">T_return</span> 매개
          변수 전달과 관련된 오버 헤드를 오브젝트 참조를 저장하는 시간과 동일하게 만드는 이유는 인수의 전달은 개념적으로 실제 매개 변수 값을
          메소드의 형식 매개 변수에 지정하는 것과 같습니다.
        description2: Axiom에 따르면, 명령문의 실행 시간은 <span class="code-inline">T_fetch + 2
          * T_store + T_call + T_f(x)</span> 입니다. 여기서 <span class="code-inline">T_f
          (x)</span> 는 입력 x에 대한 f 메소드의 실행 시간입니다. 두 저장소 중 첫 번째는 매개 변수 x가 f로 전달 되었기 때문입니다.
          두 번째 변수는 변수 y에 대입 될 때 발생합니다.
      calculating:
        title: 계산 시간
        description1: '배열 구독 작업 (예 : <span class="code-inline">a[i])</span>에 의해 암시
          된 주소 계산에 필요한 시간은 상수 <span class="code-inline">T_[]</span> 입니다. 이 시간에는 첨자
          표현식을 계산하는 시간이 포함되지 않으며 배열 요소에 액세스하는 시간도 포함되지 않습니다.'
        description2: 이것은 <span class="code-inline">3 * T_fetch</span> 입니다. 세 가지 피연산자
          가져 오기가 필요합니다. 첫 번째는 배열 객체에 대한 참조를 가져옵니다. 두 번째는 인덱스 객체 i에 대한 참조를 가져오고; 세 번째
          요소 <span class="code-inline">는</span> 배열 요소 <span class="code-inline">a[i]</span>에
          대한 참조를 가져옵니다.
      object:
        title: 객체 생성 시간
        description1: 클래스의 새 객체 인스턴스를 만드는 데 필요한 시간은 상수 <span class="code-inline">T_new</span>
          입니다. 이 시간에는 오브젝트를 초기화하는 데 걸리는 시간은 포함되지 않습니다. 공리를 적용함으로써 우리는 진술의 실행 시간을 결정할
          수 있습니다.
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> , 여기서 <span class="code-inline">T_fixnum_init</span>
          는 Fixnum 클래스의 initialize 메소드 실행 시간입니다.
      example:
        title: 예
        description: 이 섹션에서는 다음 간단한 산술 시리즈 합계를 계산하는 프로그램의 실행 시간 분석 인 공리 (Axioms)를 적용합니다.
    implementations:
      title: 이행
      stack:
        title: 스택
        description: '스택은 대기열의 형제입니다. 실제 스택 (예 : 종이)을 모방합니다. FILO (first-in-last-out)이므로
          항목이 스택에서 검색되면 추가 된 순서의 역순으로 반환됩니다. 다시 Ruby Array는 완벽한 컨테이너를 제공합니다. Queue와
          마찬가지로 링크 된 목록을 사용하여 구현할 수도 있습니다.'
        as_array: 배열로 스택
        as_linked_list: 연결된 목록으로 스택
      queue:
        title: 열
        description: '대기열은 실제 대기열을 모방 한 간단한 컨테이너 기반 구조입니다 (예 : 은행에서 대기 중). FIFO (선입
          선출)입니다. 즉, 대기열에서 항목을 검색하면 항목이 입력 된 순서대로 반환됩니다. Ruby 배열은 Queue 구현을 쉽게 수행 할
          수 있도록 해주는 메소드를 제공합니다.하지만 적절하게 이름을 지정하고 편의 클래스에 포함 시키면 구현되는 것을 볼 가치가 있으며, 다른
          구조는이 클래스에서 상속받을 수 있습니다. 링크 된 목록을 사용하여 대체 구현을 수행 할 수 있습니다.'
        as_array: 배열로 대기열
        as_linked_list: 연결된 목록으로 대기열
      deque:
        title: 과
        description: Deque는 양 끝에서 항목을 추가하고 제거 할 수있는 대기열입니다.
        as_array: 및 배열로서
        as_linked_list: 연결된 목록으로 Deque
      singly_linked_list:
        title: 단독으로 링크 된 목록
        description: 단일 링크 된 목록에는 노드의 행에서 다음 노드를 가리키는 &#39;다음&#39;필드뿐만 아니라 데이터 필드가있는
          노드가 포함됩니다. 단독 연결 목록에서 수행 할 수있는 작업에는 삽입, 삭제 및 순회가 있습니다.
      doubly_linked_list:
        title: 이중 연결된 목록
        description: 이중 연결 목록에서 각 목록 요소에는 두 개의 참조가 있습니다. 하나는 후속 제품에 대한 것이고 다른 하나는 이전
          제품에 대한 것입니다.
      ordered_list:
        title: 순서가 지정된 목록
        description: 정렬 된 목록은 항목의 순서가 중요한 목록입니다. 그러나 정렬 된 목록의 항목은 반드시 정렬되지는 않습니다. 결과적으로
          항목 순서를 변경하고 유효한 순서 목록을 유지할 수 있습니다.
        as_array: 정렬 된 목록을 배열로
      hash_table:
        title: 해시 테이블
        description: 해시 테이블은 검색 가능한 컨테이너입니다. 따라서 컨테이너에 객체를 넣고 컨테이너에서 객체를 찾고 컨테이너에서 객체를
          제거하는 메소드를 제공합니다.
      binary_tree:
        title: 이진 트리
        description: 이진 트리는 각 노드가 최대 두 개의 자식을 가질 수있는 트리입니다. 아이들은 왼쪽과 오른쪽으로 지정됩니다.
      binary_search_tree:
        title: 이진 검색 트리 &lt;
        description: '컴퓨터 과학에서 BST (주문형 또는 정렬 된 이진 트리라고도 함)는 컨테이너의 특정 유형, 즉 항목 (예 :
          숫자, 이름 등)을 메모리에 저장하는 데이터 구조입니다. 항목을 빠르게 검색, 추가 및 제거 할 수 있으며 항목의 동적 세트를 구현하거나
          키로 항목을 찾을 수있는 조회 테이블을 사용할 수 있습니다 (예 : 이름으로 전화 번호 찾기)'
      b_tree:
        title: B- 트리
        description: 컴퓨터 과학에서 B- 트리는 데이터 정렬을 유지하고 대수 시간의 검색, 순차 액세스, 삽입 및 삭제를 허용하는 자체
          균형 트리 구조입니다. B- 트리는 노드가 둘 이상의 자식을 가질 수 있다는 점에서 이진 검색 트리의 일반화입니다 (자체 균형 이진
          검색 트리와 달리 B- 트리는 큰 데이터 블록을 읽고 쓰는 시스템에 최적화되어 있습니다. 나무는 외부 메모리에 대한 데이터 구조의 좋은
          예이며 데이터베이스와 파일 시스템에서 일반적으로 사용됩니다.
      binary_heap:
        title: 이진 힙
        description: 2 진 힙은 배열을 사용하여 구현 된 힙 순서화 된 완전한 2 진 트리입니다. 힙에서는 가장 작은 키가 루트에서
          발견되고 루트는 항상 배열의 첫 번째 위치에서 발견되므로 가장 작은 키를 찾는 것이 2 진 힙에서 간단한 작업입니다.
      credits: 코드와 기사는 리소스에서 가져온 것입니다.
      source: 이 페이지는 Bruno R. Preiss의 &quot;Ruby에서의 객체 지향 디자인 패턴을 이용한 데이터 구조 및 알고리즘&quot;책의
        Ruby 코드를 포함합니다. Copyright (c) 2004 by Bruno R. Preiss, P.Eng. 판권 소유.
  design_patterns:
    title: 디자인 패턴
    creational:
      title: 창조적 인 패턴
      description: 소프트웨어 공학에서 창조적 디자인 패턴은 객체 생성 메커니즘을 다루는 디자인 패턴으로, 상황에 적합한 방식으로 객체를
        생성하려고합니다. 객체 생성의 기본 형태는 설계 문제를 야기하거나 설계를 복잡하게 만들 수 있습니다. 창조적 인 디자인 패턴은 어떻게 든이
        객체 생성을 제어함으로써이 문제를 해결합니다. 창조적 인 디자인 패턴은 두 개의 지배적 인 아이디어로 구성됩니다. 하나는 시스템이 사용하는
        구체적인 클래스에 대한 지식을 캡슐화하는 것입니다. 또 다른 것은 이러한 구체적인 클래스의 인스턴스가 생성되고 결합되는 방법을 숨기는 것입니다.
      abstract_factory:
        title: 추상 공장 패턴
        description: 추상 팩토리 패턴은 구체적인 클래스를 지정하지 않고 공통 주제를 가진 개별 팩토리 그룹을 캡슐화하는 방법을 제공합니다.
          일반적으로 클라이언트 소프트웨어는 추상 팩토리의 구체적인 구현을 생성 한 다음 팩토리의 일반 인터페이스를 사용하여 테마의 일부인 구체적인
          객체를 만듭니다. 클라이언트는 자신의 제품의 제네릭 인터페이스만을 사용하기 때문에 이들 내부 팩토리 각각에서 가져 오는 구체적인 오브젝트를
          알지 못합니다. 이 패턴은 객체 세트의 구현 세부 사항을 일반적인 사용법과 분리하고 객체 작성이 팩토리 인터페이스에 노출 된 메소드에서
          구현되므로 객체 합성에 의존합니다.
      builder:
        title: 작성자 패턴
        description: 빌더 패턴은 오브젝트 작성 소프트웨어 설계 패턴입니다. 추상적 인 팩토리 패턴과 다형성을 가능케하려는 팩토리 메소드
          패턴과는 달리, 빌더 패턴의 의도는 텔레 스코핑 생성자 안티 패턴에 대한 해결책을 찾는 것이다 [표창장 필요]. 텔레 스코핑 생성자
          방지 패턴은 객체 생성자 매개 변수 조합의 증가가 생성자의 지수 목록으로 연결될 때 발생합니다. 수많은 생성자를 사용하는 대신 빌더
          패턴은 단계별로 각 초기화 매개 변수를 수신 한 다음 작성된 결과 객체를 한 번에 리턴하는 다른 객체 인 빌더를 사용합니다.
      factory:
        title: 공장 패턴
        description: 클래스 기반 프로그래밍에서 팩토리 메서드 패턴은 팩터 리 메서드를 사용하여 생성 될 개체의 정확한 클래스를 지정하지
          않고 개체를 만드는 문제를 처리하는 생성 패턴입니다. 이는 생성자를 호출하는 대신 팩토리 메소드 (인터페이스에서 지정되고 하위 클래스로
          구현되거나 기본 클래스에서 구현되며 선택적으로 파생 클래스로 대체되는)를 호출하여 객체를 생성하여 수행됩니다.
      prototype:
        title: 프로토 타입 패턴
        description: 프로토 타입 패턴은 공장 라인을 따라 만들어진 패턴입니다. 프로토 타입의 트릭은 마스터 오브젝트를 복사하여 새 오브젝트를
          작성한다는 것입니다. 마스터 오브젝트와 사용자가 작성한 모든 후속 오브젝트가 변경 사항의 복사본으로 수명이 다할 때까지 변경하십시오.
      singleton:
        title: 싱글 톤 패턴
        description: 클래스가 하나의 인스턴스 만 갖고 있으며 전역 액세스 지점을 제공하는지 확인하십시오. 이는 시스템 전체에서 작업을
          조정하는 데 정확히 하나의 객체가 필요한 경우에 유용합니다. 이 개념은 때로는 하나의 객체 만 존재할 때보다 효율적으로 작동하거나 인스턴스
          생성을 특정 수의 객체로 제한하는 시스템으로 일반화됩니다.
      not_covered:
        title: '커버되지 않은 패턴 :'
        lazy: 게으른 초기화
        multiton: 멀티 톤
        pool: 개체 풀
        resource: 자원 획득은 초기화입니다.
    structural:
      title: 구조 패턴
      description: 소프트웨어 엔지니어링에서 구조 설계 패턴은 엔티티 간의 관계를 실현하는 간단한 방법을 식별하여 설계를 쉽게 수행 할
        수있는 설계 패턴입니다.
      adapter:
        title: 어댑터 패턴
        description: 소프트웨어 엔지니어링에서 어댑터 패턴은 기존 클래스의 인터페이스를 다른 인터페이스로 사용할 수있는 소프트웨어 디자인
          패턴입니다. 기존 클래스를 소스 코드를 수정하지 않고 다른 사용자와 함께 사용하는 데 자주 사용됩니다.
      composite:
        title: 복합 패턴
        description: 합성 디자인 패턴은 계층 적 트리 구조를 갖는 객체를 나타내는 데 사용되는 구조적 패턴입니다. 그것은 개별적인 잎
          노드와 많은 노드로 구성된 가지의 균일 한 처리를 허용합니다.
      decorator:
        title: 장식 패턴
        description: 객체 지향 프로그래밍에서 데코레이터 패턴 (Adapter 패턴과 공유되는 대체 명명법 인 Wrapper라고도 함)은
          정적 또는 동적으로 개별 객체에 동작을 추가 할 수있는 디자인 패턴으로 다른 객체의 동작에 영향을주지 않습니다 동일한 클래스의 객체
          데코레이터 패턴은 고유 책임 영역이있는 클래스간에 기능을 분리 할 수 있으므로 Single Responsibility Principle을
          준수하는 데 종종 유용합니다.
      facade:
        title: 외관 패턴
        description: Facade 디자인 패턴은 시스템이 매우 복잡하거나 이해하기 어려울 때 자주 사용됩니다. 시스템에 많은 상호 의존
          클래스가 있거나 소스 코드를 사용할 수 없기 때문입니다. 이 패턴은 대형 시스템의 복잡성을 숨기고 클라이언트에 대한 더 간단한 인터페이스를
          제공합니다. 일반적으로 클라이언트가 필요로하는 멤버 집합을 포함하는 단일 래퍼 클래스가 필요합니다. 이 구성원은 외관 클라이언트를 대신하여
          시스템에 액세스하고 구현 세부 사항을 숨 깁니다.
      flyweight:
        title: 플라이급 패턴
        description: 컴퓨터 프로그래밍에서 플라이 웨이트는 소프트웨어 디자인 패턴입니다. 플라이급은 가능한 한 많은 데이터를 다른 유사한
          객체와 공유하여 메모리 사용을 최소화하는 객체입니다. 간단한 반복 표현이 허용 할 수없는 양의 메모리를 사용하는 경우 많은 수의 객체를
          사용하는 방법입니다. 종종 객체 상태의 일부분을 공유 할 수 있으며,이를 외부 데이터 구조에 저장하고 플라이급 객체에 일시적으로 전달하는
          것이 일반적입니다.
      proxy:
        title: 프록시 패턴
        description: 가장 일반적인 형태의 프록시는 다른 것에 대한 인터페이스로서 기능하는 클래스입니다. 프록시는 네트워크 연결, 메모리의
          큰 개체, 파일 또는 복제가 비용이 많이 드는 또는 불가능한 다른 리소스와 인터페이스 할 수 있습니다. 간단히 말해서, 프록시는 백그라운드에서
          실제 제공 객체에 액세스하기 위해 클라이언트가 호출하는 래퍼 또는 에이전트 객체입니다. 프록시 사용은 단순히 실제 오브젝트로 전달하거나
          추가 논리를 제공 할 수 있습니다. 프록시에서 실제 객체에 대한 작업이 리소스를 많이 사용하는 경우 캐싱 또는 실제 객체에 대한 작업이
          호출되기 전에 사전 조건을 확인하는 등의 추가 기능을 제공 할 수 있습니다. 클라이언트의 경우 프록시 객체 사용은 실제 객체 사용과
          비슷합니다. 두 인터페이스 모두 동일한 인터페이스를 구현하기 때문입니다.
      protection_proxy:
        title: 보호 프록시
        description: 보호 프록시. MNC에서 일하고 있습니까? 그렇다면 공개 전자 메일, 소셜 네트워킹, 데이터 저장소 등과 같은 일종의
          웹 사이트에 대한 액세스를 제한하여 인터넷을 제공하는 프록시 서버를 잘 알고있을 수도 있습니다. 관리는 일부 콘텐츠를 차단하는 것이
          더 낫다고 느끼고 업무 관련 웹 페이지 만 제공하십시오. 프록시 서버가 해당 작업을 수행합니다. 이것은 프록시 디자인 패턴의 한 유형입니다.
      virtual_proxy:
        title: 가상 프록시
        description: 가상 프록시. 복잡하거나 무거운 객체 대신에 스켈레톤 표현을 사용하십시오. 기본 이미지의 크기가 크면 가상 프록시
          객체를 사용하여 이미지를 표현하고 주문형 객체는 실제 객체를로드합니다. 실제 오브젝트는 인스턴스화 측면에서 비용이 많이 들며 실제 필요없이
          실제 오브젝트를 사용하지 않을 것입니다. 필요성이 발생할 때까지 우리는 가상 프록시를 사용할 것입니다.
      remote_proxy:
        title: 원격 프록시
        description: 원격 프록시. 분산 객체 통신에서 로컬 객체는 원격 객체 (다른 주소 공간에 속한 객체)를 나타냅니다. 로컬 오브젝트는
          리모트 오브젝트의 프록시이며, 로컬 오브젝트의 메소드 호출은 리모트 오브젝트의 리모트 메소드 호출의 결과가됩니다. ATM 구현을 생각해
          보면 원격 서버에있는 은행 정보에 대한 프록시 객체를 보유하게됩니다.
      not_covered:
        title: '커버되지 않은 패턴 :'
        callback: 주석 달기 콜백
        bridge: 다리
        data_bus: 데이터 버스
        role: 역할 객체
    behavioral:
      title: 행동 패턴
      description: 소프트웨어 공학에서 행동 설계 패턴은 객체 간의 공통 통신 패턴을 식별하고 이러한 패턴을 실현하는 설계 패턴입니다.
        이렇게함으로써, 이러한 패턴은 이러한 의사 소통을 수행함에있어 융통성을 증가시킵니다.
      chain_of_responsobility:
        title: 책임 패턴의 연쇄
        description: 객체 지향 설계에서, 책임 체인 패턴은 명령 객체의 소스와 일련의 처리 객체로 구성된 설계 패턴입니다. 각 처리
          객체에는 처리 할 수있는 명령 객체의 유형을 정의하는 논리가 포함됩니다. 나머지는 체인의 다음 처리 객체로 전달됩니다. 이 체인의 끝에
          새로운 처리 객체를 추가하는 메커니즘도 있습니다.
      command:
        title: 명령 패턴
        description: 명령 패턴은 나중에 메서드를 호출하는 데 필요한 정보를 저장하는 데 사용되는 비헤이비어 디자인 패턴입니다. 이 명령은
          객체에 래핑 된 액션 집합 일뿐입니다. 루비를 사용하면 Procs를 사용하여 별도의 객체를 만들 필요없이 동일한 작업을 수행 할 수
          있습니다. 이것은 작업이 간단하고 상태 정보를 저장할 필요가없는 경우에 좋은 옵션입니다. 그렇지 않으면 명령 클래스가 더 나은 옵션입니다.
      interpreter:
        title: 통역사 양식
        description: 컴퓨터 프로그래밍에서 인터프리터 패턴은 언어의 문장을 평가하는 방법을 지정하는 디자인 패턴입니다. 기본 개념은 특수한
          컴퓨터 언어로 각 기호 (터미널 또는 비 터미널)에 대한 클래스를 만드는 것입니다. 언어의 문장 구문 트리는 복합 패턴의 인스턴스이며
          클라이언트의 문장을 평가 (해석)하는 데 사용됩니다.
      iterator:
        title: 반복자 패턴
        description: 반복자 디자인 패턴은 컨테이너가 실제로 요소를 나타내는 방법을 노출시키지 않고 컨테이너 내의 요소에 순차적으로 액세스
          할 수 있도록합니다. 이터레이터는 컨테이너 내에 캡슐화 된 요소에 액세스 할 수있는 이동 가능한 포인터로 생각할 수 있습니다.
      external_iterator:
        title: 외부 반복자 패턴
        description: '외부 반복자 : 반복 논리는 별도의 클래스에 포함됩니다. 반복 클래스는 인덱싱을 허용하는 한 여러 객체 유형을
          처리하도록 일반화 될 수 있습니다. 실제 반복을 수행하려면 추가 클래스가 필요하지만 반복을 제어 할 수 있기 때문에 유연성이 향상됩니다.
          반복되는 요소는 순서에 관계없이 반복됩니다.'
      internal_iterator:
        title: 내부 반복자 패턴
        description: '내부 반복자 : 모든 반복 논리는 집계 객체 내부에서 발생합니다. 코드 블록을 사용하여 로직을 집계에 전달한 다음
          집계를 통해 각 요소에 대한 블록을 호출합니다.'
      mediator:
        title: 조정자 패턴
        description: 일반적으로 프로그램은 많은 수의 클래스로 구성됩니다. 따라서 논리와 계산은이 클래스들에 분산되어 있습니다. 그러나
          유지 보수 및 / 또는 리팩토링 중 프로그램에서 더 많은 클래스가 개발되면 이러한 클래스 간의 통신 문제가 더욱 복잡해질 수 있습니다.
          이로 인해 프로그램을 읽고 유지하기가 더 어려워집니다. 또한, 변경은 여러 다른 클래스의 코드에 영향을 줄 수 있으므로 프로그램을 변경하기가
          어려워 질 수 있습니다. 조정자 패턴을 사용하면 개체 간의 통신이 조정자 개체로 캡슐화됩니다. 객체는 더 이상 서로 직접 통신하지 않지만
          대신 중재자를 통해 통신합니다. 이렇게하면 통신하는 오브젝트 간의 종속성이 줄어들어 결합이 낮아집니다.
      momento:
        title: 패턴의 순간
        description: momento 패턴은 세 가지 객체로 구현됩니다. 생성자, 관리인 및 순간입니다. 발신자는 내부 상태가있는 개체입니다.
          관리인은 제작자에게 뭔가를 할 것이지만 변경을 취소 할 수 있기를 원합니다. 관리인은 먼저 창작자에게 순간 물건을 물어 봅니다. 그런
          다음 어떤 작업 (또는 일련의 작업)을 수행 할지를 결정합니다. 연산 이전의 상태로 되돌아 가기 위해, 그것은 momento 객체를
          송신자에게 반환합니다. momento 오브젝트 자체는 불투명 한 오브젝트 (관리인이 변경할 수 없거나 변경해서는 안되는 오브젝트)입니다.
          이 패턴을 사용할 때 발신자가 다른 객체 또는 자원을 변경할 수있는 경우주의를 기울여야합니다. 즉, 모멘트 패턴은 단일 객체에서 작동합니다.
      observer:
        title: 옵저버 패턴
        description: 관찰자 패턴은 주체라고하는 개체가 관찰자라고하는 해당 종속 개체의 목록을 유지하고 대개 해당 메서드 중 하나를 호출하여
          상태 변경을 자동으로 알리는 소프트웨어 디자인 패턴입니다. 주로 분산 이벤트 처리 시스템을 구현하는 데 사용됩니다. Observer
          패턴은 친숙한 MVC (Model-View-Controller) 아키텍처 패턴의 핵심 부분이기도합니다. 옵저버 패턴은 거의 모든 GUI
          툴킷을 포함하여 수많은 프로그래밍 라이브러리와 시스템에서 구현됩니다.
      state:
        title: 상태 패턴
        description: 상태 패턴은 객체 지향적 방식으로 상태 머신을 구현하는 행동 소프트웨어 디자인 패턴입니다. 상태 패턴을 사용하면
          각 개별 상태를 상태 패턴 인터페이스의 파생 클래스로 구현하고 패턴의 수퍼 클래스에서 정의한 메서드를 호출하여 상태 전환을 구현하여
          상태 시스템을 구현할 수 있습니다.
      strategy:
        title: 전략 패턴
        description: 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있습니다. 전략은 Gamma 외의
          영향력있는 책 Design Patterns에 포함 된 패턴 중 하나입니다. 이는 패턴을 사용하여 소프트웨어 설계를 설명하는 개념을 대중화했습니다.
          예를 들어 들어오는 데이터에 대해 유효성 검사를 수행하는 클래스는 데이터 유형, 데이터 소스, 사용자 선택 또는 다른 식별 요소를 기반으로
          유효성 검사 알고리즘을 선택하기 위해 전략 패턴을 사용할 수 있습니다. 이러한 요소는 런타임까지 각 경우에 대해 알 수 없으며 근본적으로
          다른 유효성 검사가 수행되어야 할 수도 있습니다. 유효성 검사 대상과 별도로 캡슐화 된 유효성 검사 전략은 코드 중복없이 시스템의 다른
          영역 (또는 다른 시스템)의 다른 유효성 검사 대상 객체가 사용할 수 있습니다.
      template:
        title: 템플릿 방식 패턴
        description: 객체 지향 프로그래밍에서는 먼저 알고리즘 설계의 기본 단계를 제공하는 클래스가 만들어집니다. 이러한 단계는 추상
          메소드를 사용하여 구현됩니다. 나중에, 서브 클래스는 추상적 인 메소드를 변경하여 실제 액션을 구현합니다. 따라서 일반적인 알고리즘은
          한 곳에서 저장되지만 구체적인 단계는 하위 클래스에 의해 변경 될 수 있습니다.
      visitor:
        title: 방문객 패턴
        description: 객체 지향 프로그래밍 및 소프트웨어 엔지니어링에서 방문자 디자인 패턴은 알고리즘이 작동하는 객체 구조에서 알고리즘을
          분리하는 방법입니다. 이러한 분리의 실질적인 결과는 이러한 구조를 수정하지 않고 기존의 객체 구조에 새로운 작업을 추가 할 수 있다는
          것입니다. 그것은 개폐 원칙을 따르는 한 가지 방법입니다. 본질적으로, 방문자는 클래스 자체를 수정하지 않고 클래스의 패밀리에 새로운
          가상 함수를 추가 할 수 있습니다. 대신, 가상 함수의 모든 적절한 특수화를 구현하는 방문자 클래스를 작성합니다. 방문자는 인스턴스
          참조를 입력으로 사용하고 이중 디스패치를 통해 목표를 구현합니다.
      not_covered:
        title: '커버되지 않은 패턴 :'
        hierarchical: 계층 적 방문자
      credits: 코드와 기사는 리소스에서 가져온 것입니다.
  functional_programming:
    title: 기능적 프로그래밍
    description: 기능적 스타일로 언어를 사용하면 아래 나열된 몇 가지 주요 기능에 액세스 할 수 있습니다.
    axioms:
      immutable: '변경할 수없는 값 : 일단 &quot;변수&quot;가 설정되면 변경할 수 없습니다. Ruby에서는 상수와 같은 변수를
        효과적으로 처리해야한다는 것을 의미합니다.'
      side_effects: '부작용 없음 : 주어진 값이 전달되면 함수는 항상 동일한 결과를 반환해야합니다. 이것은 불변의 가치를 갖는 것과
        관련이 있습니다. 함수는 결과를 반환하는 접선 인 부작용을 일으킬 수 있으므로 값을 가져 와서 변경할 수 없습니다.'
      pure_functions: '고차 함수 : 함수를 인수로 허용하거나 함수를 반환 값으로 사용하는 함수입니다. 이것은 틀림없이 어떤 함수 언어의
        가장 중요한 기능 중 하나입니다.'
      applying: 'Currying : 고차 함수에 의해 사용 가능하며, currying은 여러 인수를 취하는 함수를 하나의 인수를 취하는
        함수로 변환하는 것입니다. 이것은 다중 인수 함수를 인수를 덜 취한 함수로 변환하는 부분 함수 응용 프로그램과 함께 사용됩니다.'
      recursion: '재귀 : 내부에서 함수를 호출하여 루핑. 변경할 수있는 데이터에 액세스 할 수없는 경우 재귀를 사용하여 데이터를 구성하고
        체인을 구성합니다. 이는 루핑이 기능 개념이 아니기 때문에, 주어진 시간에 루프의 상태를 저장하기 위해 변수를 전달해야하기 때문입니다.'
      lazy: '지연 평가 또는 지연 평가 : 실제로 필요한 시점까지 값 처리 지연. 예를 들어, 지연 평가가 활성화 된 피보나치 수 목록을 생성
        한 코드가있는 경우 결과의 값 중 하나가 펑션과 같은 다른 함수에 필요할 때까지 실제로 처리 및 계산되지 않습니다.'
    pure_functions:
      title: 순수 함수
      description: 이 함수는 인수를 사용하여 결과 만 계산한다는 것을 알 수 있습니다.
    closures:
      title: 마감
      description: Lambda는 또한 클로저를 강제하므로 객체간에 컨텍스트를 유지할 수 있습니다.
    applying:
      title: 부분 적용 및 운반
      description: 먼저이 두 개의 서로 다른 응용 프로그램 기능이 무엇인지 이해해 봅시다. 부분 함수 응용 프로그램은 더 많은 인수를
        사용하는 함수를 다시 얻으려면 몇 가지 인수로 함수를 호출합니다. Currying은 n 개의 인수를 취하고 하나의 인수를 취하는 n 개의
        함수로 분할하는 함수를 사용합니다.
      proc: 이 두 가지가 각각 어떤 기능을 수행하는지 명확하게 이해하기 위해 Proc를 예로 들어 봅니다.
      partial: 이 함수를 부분적으로 적용하면 첫 번째 두 개의 인수를 전달하면 다음 중첩 된 Procs가 반환됩니다.
      curry: <span class="code-inline">.curry</span> 는 카레 proc를 반환합니다. 선택적 arity 인수가
        제공되면 인수의 수를 판별합니다. 카레 proc는 몇 가지 인수를받습니다. 충분한 수의 인수가 제공되면 제공된 인수를 원래 proc로 전달하고
        결과를 리턴합니다. 그렇지 않으면, 나머지 인수를 취하는 다른 카레 proc를 리턴합니다.
  gotchas:
    title: 잡았다
    description1: 대부분의 Ruby on Rails 초보자는 프레임 워크에 흥분하고 언어에 대한 지식 없이도 응용 프로그램을 제작하기 시작합니다.
      이것이 바로 RoR의 마법입니다.
    description2: 어느 시점에서 일이 심각해지기 시작합니다. Ruby on Rails의 더러운 비밀을 탐색하는 데는 시간과 노력이 필요하고,
      다른 사람들은 언어에 대해 거의 알지 못하는 선임 개발자가되어 버렸습니다.
    description3: 어쨌든 조만간 초보자 나 숙련 된 프로그래머, 우리 모두는 소위 하드 코어 디버깅을 위해 우리 사이트에서 숨기는 작은
      언어의 미묘한 부분 인 Ruby Gotchas를 사용합니다.
    description4: 다음은 개발자가 알아야 할 인기있는 Ruby 잡기 및 호기심 목록입니다. 각각의 경우에 혼란 스럽거나 오류가 발생하기
      쉬운 코드의 예가 있습니다.
    description5: 그들은 좋은 습관과 함께 모여서, 당신이 단순한 (그러나 찾기가 어렵다) 실수를 피하고 당신의 (그리고 당신의 코드 관리자의)
      삶을 단순화시킵니다.
    surprising:
      title: 루비는 놀랄 수 있습니다.
      description: Ruby는 &quot;프로그래머의 행복을 극대화하도록 설계되었지만&quot; &quot;가장 놀랄만하지 않은 원칙&quot;을
        가지고 있지만 여전히 문제가 있습니다. 이 프리젠 테이션은 초보자의 사소한 잡다한 것에서 더 진보되고 혼란스러운 것에 이르기까지 진행될
        것입니다.
    quotes:
      title: 이걸 인용하지 말고 ...
      description: 문자열 보간법 ( <span class="code-inline">\ n</span> 과 같은 특수 문자 포함)은 <span
        class="code-inline">&#39;단일&#39;</span> 따옴표로 실패합니다. 따옴표는 <span class="code-inline">&quot;이중&quot;</span>
        따옴표가 필요합니다. 문자열 보간을 사용하는 대부분의 언어 에서처럼. 그것을 피하기 위해 실용적이 될 때마다 복식을 사용하십시오.
    twue:
      title: 그것은 twue 다! 그것은 twue 다!
      description: <span class="code-inline">false</span> 와 <span class="code-inline">nil</span>의
        두 가지만 입니다. 그 밖의 모든 것은 진실입니다. 심지어 <span class="code-inline">0</span> (C에서 거짓), <span
        class="code-inline">&quot;&quot;</span> (JS에서 거짓), <span class="code-inline">[]</span>
        등. C, JS 등의 사람들을 여행합니다. 이들 중 일부는 거짓입니다.
    symbols_and_strings:
      title: 상상을 품거나 상징적으로 그를 묶어 라.
      description: '<span class="code-inline">Symbol != String/span> . 같은 경우에도 인쇄. args에 사용할
        것을 기억하십시오. 이상적으로 말하자면, 어느 쪽을 택하든, 어떤 방법으로 기대하는 것을 사용하십시오 : &quot;당신이 받아들이는 것에서
        자유주의적이고, 보내는 것에서 보수적이십시오.&quot; 포스텔의 법.'
    string_or_nothing:
      title: 문자열 ... 아니면 아무것도!
    constants:
      title: 상수가 없습니다.
      description: 대문자는 Ruby에서 상수를 의미합니다. 상수를 변경하십시오. 너 경고 받았어! BFD. Fixnums의 경우 동결조차도
        작동하지 않습니다. 배열 (일종의) 및 대부분의 다른 객체에서 작동합니다 ... 그는 미리 말했습니다.
    equals:
      title: 일부는 다른 것보다 더 평등합니다.
      description: <span class="code-inline">==</span> 는 보통 같은 값인 <span class="code-inline">.eql?</span>
        값과 클래스입니다 (1은 Fixnum, 1.0은 Float) <span class="code-inline">.equal?</span> 같은 대상입니다.
        실제로는 훨씬 더 털이 있습니다.
    operations:
      title: "&gt; ===! = ==!"
      description: <span class="code-inline">===</span> 는 case 문과 마찬가지로 &quot;case equality&quot;입니다.
        더 나은 이름이있을 수 있습니다 <span class="code-inline">.describes?</span> , 또는 과부하 <span
        class="code-inline">.includes?</span> . 다시 말하지만 실제로는 훨씬 더 털이 있습니다. Object 클래스의
        문서를 참조하십시오. 언어에서 사람을 얻습니다. <span class="code-inline">===</span> 는 객체 ID 또는 동일한
        값과 클래스입니다.
    priority:
      title: 그리고! = &amp;&amp;, 또는! = ||
      description: '<span class="code-inline">&amp;&amp;</span> 는 <span class="code-inline">=</span>
        보다 우선 순위가 높기 때문에 <span class="code-inline">x = true && false</span>
        는 <span class="code-inline">x = (true && false)</span>를 의미 하며 우선 순위가
        낮기 때문에 <span class="code-inline">x = true andfalse</span> 는 <span class="code-inline">(x = true) and false</span>
        를 의미 합니다. 루비 스타일 가이드 : <span class="code-inline">&&,
        ||</span> 사용 부울 표현식의 경우, <span class="code-inline">and, or</span> 제어 흐름의 경우.'
    sensitive:
      title: 너무 민감하지 마!
      description: 공백을 구분하지 않습니까? 언제나! 파서 (Parser)는이 표현식을 하나의 arg로 생각하지만 <span class="code-inline">(1,
        2)</span> 는 유효한 Ruby 표현이 아닙니다! (모두 1 개의 인수로 잘 작동합니다.)
      usage: '여러 개의 인수가있는 경우 : <br/> - 싫어, 문제 없어. <br/> - 부모님 / 외의 공간, OK. <br/> - 팸과
        우주, 안돼!'
      methods: '<span class="code-inline">method / num</span> 은 끝이없는 정규식이나 문자열입니다! 루비는
        당신이이 방법에 대해 논쟁을하고 있다고 생각합니다. 일반 원칙 : BALANCED 공백을 사용하십시오. 양쪽 또는 둘 다.'
      arguments: '<span class="code-inline">one -2</span> 는 Ruby가 당신이 방법 1에 <span class="code-inline">-2</span>
        인자를 준다고 생각하게 만듭니다. <span class="code-inline">+2</span> 또는 <span class="code-inline">*
        2</span> 와 동일합니다. 다시 말하지만 : BALANCED 공백 문자, 양쪽 또는 둘 다 사용하지 마십시오.'
      stubby: "&quot;Stabby&quot;lambdas (1.9+) 괄호는 선택 사항입니다. 부모가없는 인수 뒤에는 공백이 있어야합니다.
        부모님 뒤의 공간, OK. 다시 부모님 앞 공간! 업데이트 : 2.0에서 수정되었습니다!"
    onto:
      title: "@에!"
      description: '노출 된 값이 임시 로컬 변수가됩니다! 해결책 : <span class="code-inline">@!</span>
        (또는 &quot;self.&quot;또는 <span class="code-inline">attr_writer, attr_accessor</span>를
        사용 하십시오.) Java / C ++에서 사람들을 얻으십시오
        . Python ( &quot;self&quot;도 필요합니다)이 아닙니다. &quot;당신은 그 변수를 계속 사용합니다. 나는 당신이
        생각하는 것을 의미하지 않는다고 생각합니다.&quot; Inigo Montoya가 아닙니다.'
    variables:
      title: 밖으로보십시오, 그것은 @@입니다!
      description: 빈칸 채우는 게 뭐야? 우리는 부모의 <span class="code-inline">@@ 값</span> 을 확인하기
        전에 변경하지 않았으며, Child는 전혀 변경하지 않았습니다! 아니면 우리? <span class="code-inline">@@ 변수</span>
        는 하위 클래스와 공유됩니다 - 존재하는 것이 아니라 변수 자체! 자녀의 <span class="code-inline">@@ 값을</span>
        선언하면 부모가 변경되고 부모의 변경된 Child&#39;s.ut를 포함하여 @@!
    initialize:
      title: init (ialize)를 사용하거나 사용하지 않고
      description: 부모의 초기화는 자식이없는 경우에만 자동으로 실행됩니다. 그렇지 않으면 부모님을 불러서 도망쳐 야합니다.
    superman:
      title: 수퍼맨 대 보이지 않는 남자
      description: 인수 없음의 목록 <span class="code-inline">super</span> 빈 괄호를 <span class="code-inline">super</span>
        명시 적 인수에있어 어떠한 인수를 보낼에 그 인수를 전송, 무엇을 사용 보냅니다 <span class="code-inline">super().</span>
    regexp:
      title: 언제 끝날까요? (또는 시작 하시겠습니까?)
      description: '표준 정규식에서 <span class="code-inlne">^</span> 는 시작이고 <span class="code-inline">$</span>
        는 전체 문자열의 끝입니다. 루비의 정규 표현식은 기본적으로 여러 줄로되어 있기 때문에 : <span class="code-inline">^</span>
        는 시작이고 <span class="code-inline">$</span> 는 임의의 줄의 끝입니다! <span class="code-inline">\
        A</span> 는 시작이고 <span class="code-inline">\ Z</span> 는 전체 문자열의 끝입니다. (또는 \ z에
        개행을 포함 시키면 ... 또 하나의 잡았다!)'
    any:
      title: 점점?
      description: '<span class="code-inline">.any?</span> &quot;어떤 요소?&quot;라는 뜻이 아닙니다!
        블록으로 : &quot;블록을 사실대로 만들까요?&quot;. 없이 : &quot;어떤 진리일까요?&quot; 암시적인 블록을 가짐 :
        <span class="code-inline">{ | element | element }</span> .'
    undef:
      title: "(Un) Def Leppard"
      description: '반복자에 전달 된 블록에서 선언 된 변수 (예 : 시간 또는 각각)는 각 반복의 상단에서 정의되지 않습니다! 반복자는
        블록을 반복적으로 호출하므로 각 호출 후에 vars가 다시 범위를 벗어납니다. 내장 루핑 구문 (예 : while 또는 for)은 정상입니다.
        (또는 블록 앞에 vars를 선언하십시오.)'
    freeze:
      title: 프리즈 (Ar) 레이
      description: 배열 (또는 해시)을 고정하면 포함 된 항목이 아닌 고정시킵니다. 문자열은 제자리에서 수정할 수 있습니다. 이렇게하면
        고정 된 문자열 배열에서 지정된 슬롯을 수정할 수 있습니다.
    one_is_one:
      title: 1은 1 ... 그리고 이제까지 더 많을 것입니다!
      description: 'Fixnum을 새로운 값으로 변경하면 새 오브젝트를 의미합니다. 그들은 제자리에서 수정할 수 없습니다! 따라서 Fixnum의
        고정 배열을 수정할 수 없습니다. (Fixnums와 Integers는 시도 할 데모 방법이 없습니다). BTW : Fixnum의 <span
        class="code-inline">object_id</span> 는 <span class="code-inline">value * 2 + 1.</span>입니다'
    bang:
      title: "(~!에!)! ==?"
      description: Bang은이 방법을 위험한 것으로 표시합니다. 왜? 종종 리시버를 수정할 수 있으며, non-modding non-bang
        버전과 비교할 수 있습니다. NON-BANG 버전과 동일한 값을 반환하지 마십시오! 변경이 필요하지 않으면 많은 사람들이 반환하지 않습니다!
    array:
      title: 새로운 Gotchas의 배열
      description: object로 지정된 기본값은 각 슬롯에 대해 동일한 객체입니다! 하나를 돌연변이시키는 것은 모두에 대한 기본값을 변형시킵니다.
        블록으로 주어지는 초기 값은 각 슬롯에 대해 개별적으로 평가됩니다. 이것을 사용하여 각각에 대해 새 vars를 만듭니다.
    hash:
      title: 그것의 해시 만들기
      description: '배열과 거의 동일한 문제 (및 솔루션). MORE GOTCHAS : 빈 슬롯에 액세스 할 때 새로운 객체를 만듭니다!
        과도한 수의 새로운 객체를 생성 할 수 있습니다. 폐물 &quot;진짜&quot;내용 또는 카운트 (nil-checking, .size,
        등등).'
    rescue:
      title: 나를 구하라, 선을 던져라, 나는 그것을 잡으려고 노력할 것이다!
      description: Ruby에서 throw 및 catch는 예외가 아닙니다! 그들은 깊이있는 중첩을 종료하기 위해 고급 흐름 제어입니다.
        루비는 예외에 대한 인상 및 구조를 사용합니다.
    to_str:
      title: to_s VS to_str
      description: '<span class="code-inline">to_s</span> 는 모든 객체에 정의되며 항상 무언가를 반환합니다.
        <span class="code-inline">to_str</span> 은 문자열과 같은 객체에서만 정의됩니다. 예를 들어, <span
        class="code-inline">Symbol</span> 에는 <span class="code-inline">to_str</span>이
        있지만 <span class="code-inline">Array</span> 에는 없습니다. 따라서 작업중인 클래스가 <span class="code-inline">String</span>
        의 하위 클래스인지 또는 <span class="code-inline">String</span> 클래스의 하위 클래스인지에 대한 염려없이
        오리 유형을 활용하려는 경우 <span class="code-inline">obj.is_a? (String)</span> 와 같은 대신
        <span class="code-inline">obj.respond_to?(:to_str)</span> 를 사용할 수 있습니다 <span
        class="code-inline">String</span> 아니.'
    missing:
      title: method_missing 및 respond_to_missing을 조정해야합니까?
      description: <span class="code-inline">method_missing</span>을 재정의 할 때는 <span class="code-inline">respond_to_missing</span>
        을 재정의 해야합니다 게다가. method_missing을 사용하여 메소드
        호출시 객체가 무엇인가를 반환하도록 할 때는 항상 respond_to_missing?을 다시 정의해야합니다. 당신이 그것을하지 않으면,
        언뜻 보면 아무것도 깨지지 않을 것이지만, 결국 당신은 곤경에 처하게 될 것입니다. 다음 클래스를 고려하십시오.
      respond_to: 'respond_to에 의존하는 코드 (보석 또는 본인)가 많이 있습니까? (좋은 이유로). respond_to_missing에
        패치를 적용해야합니까? 게다가:'
    exception:
      title: 예외가 아닌 StandardError에서 구조하기
      description: 구출하지 마라 Exception, rescue StandardError Before 명시 적으로 구출하기 예외는 SyntaxError,
        LoadError, Interrupt와 같은 정상적으로 복구 할 수없는 오류조차도 구출 할 것이다. Exception 타입 한정자를 생략하면
        Ruby는 StandardError 만 잡아낼 수 있습니다.
    private:
      title: 개인 데이터는 실제로는 아니며 클래스 메소드와는 전혀 관련이 없습니다.
      description: 루비에서 클래스 메소드를 비공개로 만드는 방법이 있습니다. 오류, 나는 <span class="code-inline">class << self</span> 구문을 사용하는 것을 의미합니다. 이러한 이상한 점은 인스턴스 싱글 톤을 클래스에 푸시하여 클래스 메소드를
        효과적으로 생성합니다.
    braces:
      title: 중괄호 대 do-end
      description: 일반적인 규칙은 단일 행 블록에 대해 다중 행 블록 및 중괄호에 대해 <span class="code-inline">do
        .. end</span> 를 사용 하는 것이지만 그림에서 설명 할 수있는 두
        개 사이에도 차이가 있습니다. 즉, <span class="code-inline">{}</span> 은 <span class="code-inline">do
        .. end</span> 보다 우선 순위가 높으므로 사용하려는 것을 결정할 때이를 명심하십시오.
    module:
      title: '모듈 Foo 밖에서 정의 된 Foo :: Bar 클래스는 Foo 내부에서 볼 수 없습니다.'
      description: 당신은 <span class="code-inline">module Something</span> 의 각 외관을 생각할 수 있습니다. <span
        class="code-inline">class Something</span> , <span class="code-inline">def something</span> 또는
        뭔가 를 새로운 범위의 &quot;게이트웨이&quot;로 정의하십시오. 루비가
        참조 된 이름의 정의를 검색 할 때, 현재 스코프 (메소드, 클래스 또는 모듈)를 먼저보고, &quot;게이트웨이&quot;와 검색을 포함하고있는
        곳으로 되돌아 갈 곳을 찾지 못한다면 범위.
    credits: 코드와 기사는 리소스에서 가져온 것입니다.
  meta_programming:
    title: 메타 프로그래밍
    description: 메타 프로그래밍은 다른 프로그램 (또는 그 자체)을 데이터로 쓰거나 조작하는 컴퓨터 프로그램을 작성하거나 그렇지 않으면
      런타임에 수행 될 컴파일 시간에 작업의 일부를 수행하는 컴퓨터 프로그램을 작성하는 것입니다. 대부분의 경우 프로그래머는 모든 코드를 수동으로
      작성하는 데 소요되는 시간과 동일한 시간 내에 더 많은 작업을 수행 할 수 있으며 재 컴파일없이 새로운 상황을 효율적으로 처리 할 수있는 유연성을
      프로그램에 제공합니다. 메타 프로그래밍은 런타임 동안 코드를 작성하여 사용자의 삶을 편하게 해주는 코드를 작성하는 것입니다.
    dynamic_dispatch:
      title: 다이나믹 디스패치
      description: <span class="code-inline">subject.public_send (message, * arguments)
        메시지</span> 를 보낼 수 있습니다.
    dynamic_method:
      title: 동적 방법
      description: '<span class="code-inline">define_method : method_name {메소드 본문이되는
        블록}</span>'
    ghost_methods:
      title: 고스트 메소드
      description: '&quot;고스트 메소드&quot;잡기 및 다른 메소드로 전달 가능하다. <span class="code-inline">method_missing</span>
        활용'
    dynamic_proxies:
      title: 동적 프록시
      description: '예를 들어 <span class="code-inline">method_missing</span> 을 사용하여 들어오는
        메시지 (예 : <span class="code-inline">get_name</span> , <span class="code-inline">get_age</span>
        )를 구문 분석하고 <span class="code-inline">get (: data_type)</span> 과 같은 다른 메소드로 위임
        할 <span class="code-inline">수 있습니다.</span> 여기서 <span class="code-inline">data_type</span>
        은 <span class="code-inline">name</span> 또는 <span class="code-inline">: age</span>
        입니다.'
      more: (분석 후) <span class="code-inline">method_missing</span> 을 사용하여 성능 문제를 발견하면
        처음에 &#39;method_missing&#39;에 의해 메시지가 수신 된 후에 &#39;동적 메소드&#39;기술을 활용하여 실제 메소드를
        생성 할 수 있습니다.
  solid_principles:
    good: 좋은!
    bad: 나쁜!
    title: 확실한 원칙
    description: 컴퓨터 프로그래밍에서 SOLID (단일 책임, Open-closed, Liskov 대체, 인터페이스 분리 및 종속성 반전)는
      Michael Feathers가 Robert C. Martin이 2000 년 초에 이름을 붙인 &quot;First Five Principles&quot;에
      대해 소개 한 니모닉 약어입니다 객체 지향 프로그래밍 및 디자인의 5 가지 기본 원칙 이 원칙을 함께 적용하면 프로그래머가 유지 보수 및 확장이
      용이 한 시스템을 더 많이 만들 수있게됩니다. SOLID의 원칙은 프로그래머가 읽기 쉽고 확장 할 수있을 때까지 소프트웨어의 소스 코드를 리팩터링하여
      코드 냄새를 제거하기 위해 소프트웨어 작업을하는 동안 적용 할 수있는 지침입니다. 이것은 민첩하고 적응력있는 소프트웨어 개발의 전체 전략의
      일부입니다.
    single:
      title: 단일 책임 원칙
      description: Single Responsibility Principle이 가장 추상적이다. 클래스와 메소드를 작고 유지할 수 있도록
        도와줍니다. 수업을 작고 집중시키는 것 외에도 이해하기가 더 쉽습니다.이 예는 거래를 처리 한 후 특정 사람의 수수료 요약을 이메일로 보내기위한
        지원을 추가하는 것일 수 있습니다. 변경해야 할 여러 이유를 식별 할 수 있다는 사실은 Single Responsibility Principle의
        위반입니다.
    open_close:
      title: 개방 / 폐쇄 원칙
      description: Open / Closed Principle은 클래스 나 메소드가 확장을 위해 열려 있어야하지만 수정을 위해 닫혀 있어야한다고
        명시합니다. 이것은 클래스 자체를 수정하지 않고 시스템의 동작을 변경할 수있는 모듈 식 디자인을 위해 노력해야한다는 것을 말해줍니다. 이것은
        일반적으로 전략 패턴과 같은 패턴의 사용을 통해 달성됩니다.
      after: 이 리팩터링을 통해 코드를 변경하지 않고 새 파서를 추가 할 수있었습니다. 추가 동작을 수행하려면 새 처리기 만 추가하면됩니다.
        이것은 우리의 FileParser를 재사용 가능하게 만들고, 많은 경우에 더 작은 집중된 클래스를 생성하도록 독려함으로써 Single Responsibility
        Principle을 준수하도록합니다.
    liskov:
      title: 리 스콥의 대체 원리
      description: Liskov의 원리는 이해하기가 가장 어렵습니다. 이 원칙은 부모 클래스의 인스턴스를 예상치 못한 또는 잘못된 동작을
        만들지 않고 해당 인스턴스 중 하나의 인스턴스로 대체 할 수 있어야한다고 규정합니다.
    segregation:
      title: 의존성 반전 원리
      description: '원칙은 클라이언트가 사용하지 않는 방법에 의존하도록 강요되어서는 안된다는 것을 나타냅니다. 이 예제에는 Computer,
        Programmer 및 Technician 클래스가 있습니다. 프로그래머와 기술자 모두 컴퓨터를 다른 방식으로 사용합니다. 프로그래머는
        컴퓨터를 사용하여 입력하지만 기술자는 컴퓨터 하드 드라이브를 변경하는 방법을 알고 있습니다. 인터페이스 분리 원리 (ISP)가 시행하는
        것은 한 클래스가 사용하지 않는 메소드에 의존해서는 안된다는 것입니다. 이 경우 Programmer는 불필요하게 Computer # change_hard_drive
        메소드에 연결되지만 사용하지 않기 때문에이 메소드가 적용하는 상태 변경은 프로그래머에게 영향을 줄 수 있습니다. LSP를 따르도록 코드를
        리팩토링 해 봅시다.'
      after: 이 리팩터링 후 기술자는 컴퓨터 상태와 분리 된 ComputerInternals 유형의 다른 객체를 사용합니다. 컴퓨터 개체의
        상태는 프로그래머의 영향을받을 수 있지만 변경 사항은 어떤 식 으로든 기술자에게 영향을 미치지 않습니다.
    di:
      title: 의존성 반전 원리
      description: 종속성 반전 원리는 하위 수준 (데이터베이스 쿼리 및 IO 생각) 구현 세부 사항에 의존하지 않는 상위 수준 (비즈니스
        논리 생각) 개체와 관련이 있습니다. 이것은 오리 타이핑 및 종속성 반전 원리를 사용하여 수행 할 수 있습니다. 종종이 패턴은 앞서 논의한
        개방 / 폐쇄 원칙을 달성하는 데 사용됩니다. 사실, 우리는 심지어이 원리의 시위와 같은 예를 재사용 할 수 있습니다. 이제 formatter
        클래스가 있지만 Report 클래스에서이 클래스를 하드 코드하여 Report에서 JSONFormatter에 대한 종속성을 만듭니다. 보고서는
        JSONFormatter보다 추상적 (상위) 개념이기 때문에 DIP을 효과적으로 파기하고 있습니다.
      after: 이렇게하면 JSONFormatter에 의존하지 않고 format이라는 메소드가있는 모든 유형의 포맷터를 사용할 수 있습니다 (오리
        입력이라고 함). 또 하나주의해야 할 점은 문제를 해결하기 위해 의존성 주입을 사용했다는 것입니다. 이 기법은 객체의 분리를 목표로하고
        종속성 반전 원리 (종속성 주입 패턴)와 동일한 이니셜을 가지고 있어도 완전히 다른 개념입니다.
  threads:
    example: 예
    title: 실
    description: '병렬성과 동시성에 대한주의 사항 : 프로세스와 스레드를 사용하는 것의 가장 큰 차이점은 메모리가 처리되는 방식입니다.
      높은 수준에서 스레드는 메모리를 공유하는 반면 프로세스는 메모리를 복사합니다. 이렇게하면 프로세스가 스레드 생성보다 느리게 생성되고 프로세스가
      실행되면 더 많은 리소스를 소비하게됩니다. 전반적으로 스레드는 프로세스보다 오버 헤드가 적습니다. 이 스레드 API는 Ruby API입니다.
      다른 Ruby 구현에는 다른 기본 스레딩 비헤이비어가 있다는 암시를했습니다.'
    green:
      title: 녹색 실
      description: Ruby 1.9는 녹색 스레드를 원시 스레드로 대체했습니다. 그러나 GIL은 여전히 병렬 처리를 방해합니다. 즉, 더
        나은 스케줄링을 통해 동시성이 개선되었다는 것입니다. 새로운 스케줄은 컨텍스트 스위치 결정을 본질적으로 타이머 스레드라고하는 별도의 고유
        스레드로 이동시킴으로써 컨텍스트 전환 결정을보다 효율적으로 만듭니다.
    gil:
      title: GIL - 글로벌 인터프리터 잠금
      description: MRI에는 전역 통역사 잠금 장치 (GIL)가 있습니다. Ruby 코드 실행을 둘러싼 잠금 장치입니다. 즉, 멀티 스레드
        컨텍스트에서는 한 번에 하나의 스레드 만 Ruby 코드를 실행할 수 있습니다. 따라서 8 코어 시스템에서 8 개의 스레드가 바쁘게 작동하는
        경우 특정 시점에 하나의 스레드와 하나의 코어 만 사용 중입니다. . GIL은 데이터를 손상시킬 수있는 경쟁 조건으로부터 Ruby 내부를
        보호하기 위해 존재합니다. 주의 사항과 최적화가 있지만 이것은 요지입니다.
      example: 이 단순한 사실은 스레드를 매우 강력하게 만드는 것, 그리고 스레드로 작업하기가 어렵게 만드는 것입니다. 나는 스레드가 좋은
        이유에 대한 아이디어를 이미 제공했습니다. 여기에 그들의 어려움을 설명하는 간단한 프로그램이 있습니다. 여기서 우리는 배열에 <span
        class="code-inline">10 * 10000 개의</span> 요소가 있음을 알 수 있습니다. 다른 루비는 다른 결과를 나타낼
        수 있습니다. GIL은 MRI 루비에만 존재합니다.
    mutex:
      title: 뮤텍스 - 상호 실행
      description: 뮤텍스는 다중 스레드가 코드의 중요한 부분에 대한 액세스를 동기화하는 메커니즘을 제공합니다. 다른 말로하면, 그들은
        다중 스레드 혼돈의 세계에 어떤 질서와 보장을 가져 오는 것을 돕는다. &#39;뮤텍스&#39;라는 이름은 &#39;상호 배타&#39;의
        줄임말이다. 뮤텍스로 코드의 일부 섹션을 래핑하는 경우 두 스레드가 동시에 해당 섹션에 들어갈 수 없다는 것을 보장합니다. 뮤텍스는 다중
        스레드가 코드의 중요한 부분에 대한 액세스를 동기화하는 메커니즘을 제공합니다. 멀티 스레딩 카오스의 세계에 어떤 주문과 보증을 제공하는
        데 도움이됩니다.
      example: 이 프로그램에서는 모든 스레드가 뮤텍스를 잠그기 전에 배열에 푸시해야하므로 두 스레드가 동시에이 작업을 수행하지 않을 것이라는
        보장이 있습니다. 즉,이 작업을 완료하기 전에 더 이상 중단 할 수 없습니다. 한 스레드가 배열로 밀어 넣기를 시작하면 첫 번째 스레드가
        완료 될 때까지 다른 스레드가 그 코드 부분을 입력 할 수 없습니다. 이 작업은 이제 스레드로부터 안전합니다. 여기서 우리는 배열에 <span
        class="code-inline">10 * 10000 개의</span> 요소가 있음을 알 수 있습니다. 뮤텍스 때문에 모든 것이 동일합니다.
        뮤텍스는 스레드에 대해 동일한 경계를 설정합니다. 이 코드 비트에 도달하는 첫 번째 스레드는 뮤텍스를 잠급니다. 그런 다음이 뮤텍스의 소유자가됩니다.
        소유 스레드가 뮤텍스를 잠금 해제 할 때까지 다른 스레드는이를 잠글 수 없습니다.
    fibers:
      title: 섬유
      description: 파이버는 Ruby에서 경량의 협업 동시성을 구현하기위한 기본 요소입니다. 기본적으로 스레드와 마찬가지로 일시 중지 및
        다시 시작될 수있는 코드 블록을 만드는 방법입니다. 가장 큰 차이점은 VM은 선점되지 않으며 스케줄러는 VM이 아닌 프로그래머가 수행해야한다는
        것입니다. 다른 스택리스 경량 동시성 모델과는 달리, 각 파이버는 4KB의 작은 스택을 제공합니다. 이렇게하면 파이버 블록 내에서 깊게
        중첩 된 함수 호출로 인해 파이버가 일시 중지 될 수 있습니다.
    rails:
      title: 레일 스레드 안전
      description: 이 문제는 앱 전체가 스레드로부터 안전한지 여부를 절대적인 확실성으로 말할 수있는 간단한 방법이 없다는 것입니다.
      global_variables: 전역 변수는 전역 변수입니다. 즉, 스레드간에 공유됩니다. 지금까지 전역 변수를 사용하지 않는다고 확신하지
        못했다면 절대 건드리지 않는 또 다른 이유가 있습니다. 어쨌든 앱에서 전 세계에 걸쳐 무언가를 공유하고 싶다면 상상할 수 있습니다 (아래
        참조).
      class_variables: 클래스 변수. 스레드에 대한 설명을 위해 클래스 변수는 전역 변수와 크게 다르지 않습니다. 그들은 같은 방식으로
        쓰레드를 통해 공유됩니다. 문제는 클래스 변수를 사용하는 것이 아니라 변이시키는 것입니다. 그리고 클래스 변수를 돌연변이시키지 않으려는
        경우, 많은 경우 상수가 다시 좋은 선택입니다.
      instance_variables: 클래스 인스턴스 변수. 그러나 Ruby에서 클래스 변수 대신 클래스 인스턴스 변수를 항상 사용해야한다는
        내용을 읽었을 것입니다. 글쎄, 어쩌면해야 할 수도 있지만, 클래스 변수처럼 쓰레 디드 프로그램에 대해서도 문제가있다.
      memoization: 'Memoization 자체는 스레드 안전 문제가 아닙니다. 이것은 종종 클래스 변수 나 클래스 인스턴스 변수에 데이터를
        저장하는 데 사용됩니다 (이전 부분 참조). <span class="code-inline">|| =</span> 연산자는 실제로 두 개의
        연산이므로 중간에 잠재적 인 컨텍스트 전환이 발생하여 스레드간에 경쟁 조건이 발생합니다. 따라서 인스턴스 변수 만 사용하더라도 메모 작성을
        통해 경쟁 조건이 종료 될 수 있습니다. 클래스 변수 나 클래스 인스턴스 변수를 메모하지 마십시오. 클래스 수준에서 무언가를 메모해야하는
        경우 스레드 로컬 변수 (<span class="code-inline">Thread.current[:baz]</span>)를 대신
        사용하십시오. 하지만 여전히 글로벌 변수라는 사실을 알고 있어야합니다.'
    config:
      title: threadsafe를 구성하십시오!?
      description: 이 메소드를 호출하면 앱 구성에 네 가지 옵션이 설정됩니다. 각 옵션을 살펴보고 그것이하는 일에 대해 이야기하겠습니다.
      frameworks: 'Preloading Frameworks : @preload_frameworks의 첫 번째 옵션은 부팅 할 때 Rails
        프레임 워크를 열심히로드하도록합니다. 이 옵션을 사용하지 않으면 프레임 워크 클래스가 자동로드를 통해 느리게로드됩니다. 멀티 스레드 환경에서는
        자동로드의 스레드 안전성 문제로 인해 스레드를 작성하기 전에 프레임 워크를 열심히로드해야합니다. 프레임 워크를 로딩하는 것은 threadsafe가
        아니므로, 쓰레드가 요청을 처리 할 준비가되기 전에 모든 것을로드하는 것이 전략입니다.'
      cache: '클래스 캐싱 : @cache_classes 옵션은 클래스를 다시로드할지 여부를 제어합니다. 응용 프로그램에서 &quot;TDD&quot;를
        할 때를 기억하십니까? 컨트롤러를 수정 한 다음 페이지를 다시로드하여 &quot;테스트&quot;하고 변경 사항을 확인하십시오. 예, 이것이이
        옵션이 제어하는 것입니다. 이 옵션을 false로 설정하면 개발 과정에서 클래스가 수정 될 때 다시로드됩니다. 이 옵션이 없으면 &quot;F5DD&quot;를
        수행 할 수 없습니다 (예, F5 주도 개발). 프로덕션에서는 클래스가 즉시 수정되지 않으므로 클래스를 다시로드할지 여부를 파악하는 작업만으로
        리소스를 낭비하는 것이므로 클래스 정의를 다시로드하지 않는 것이 좋습니다.'
      di: 'Dependency loading : @dependency_loading은 상수가 누락되면 코드 로딩을 제어합니다. 예를 들어 컨트롤러는
        사용자 모델을 참조하지만 사용자 상수는 정의되지 않습니다. 이 경우 @dependency_loading이 true이면 Rails는 User
        상수가 들어있는 파일을 찾아 해당 파일을로드합니다. 우리는 코드 로딩이 쓰레드에 안전하지 않은 방법에 대해 이미 이야기했다. 따라서 여기서는
        프레임 워크를로드하고 모든 사용자 코드를로드 한 다음 종속로드를 비활성화해야한다는 아이디어가있다. 의존성로드가 비활성화되면 프레임 워크
        코드와 응용 프로그램 코드가로드되어야하며 누락 된 상수는 코드로드를 시도하지 않고 예외를 발생시킵니다. 앞에서 언급했듯이 코드 로딩은 threadsafe가
        아니므로 모든 스레드가 요청을 처리하기 전에 모든 코드를로드해야하기 때문에 프로덕션에서이 옵션을 사용하지 않도록 설정할 수 있습니다.'
      concurrency: '동시성 허용 : @allow_concurrency 옵션은 스택에서 Rack :: Lock 미들웨어가 사용되는지 여부를
        제어합니다. Rack :: Lock은 요청 주위에 뮤텍스를 래핑합니다. 스레드 세이프가 아닌 코드가 있다면이 뮤텍스는 여러 스레드가 동시에
        컨트롤러 코드를 실행하지 못하도록하는 것입니다. threadsafe 할 때! 이 미들웨어가 제거되고 컨트롤러 코드가 병렬로 실행될 수 있습니다.'
    credits: 코드와 기사는 리소스에서 가져온 것입니다.
  ruby_meister:
    title: 루비 마이스터되기
    description: 이 강연에서 우리는 Ruby 초보자가되는 것에서부터 진정한 Ruby 숙달을 달성하기까지의 긴 여정을 살펴보고 몇 가지 중요한
      통찰력을 공유하여 조금만 줄이려고 노력할 것입니다. Master Rubyist는 훌륭한 이론적 기초를 가지고 있으며 광범위한 도구 상자를 사용하고
      Ruby의 핵심 가치와 원칙을 깊이 이해하고 있으며 항상 기술을 연마하고 있습니다. 아마도 당신은 스스로를 &quot;와우, 이것은 매우 모호합니다!&quot;라고
      말하고있는 것입니다. 그러나이 세션에 참석한다면 저는 여러분이 깨우침을 받고, 즐겁게 지낼 것이고, 당신은 완전히 그것을 즐기겠다고 약속합니다!
      좋은 데? 훌륭한 책은 사람들에게 자신의 기술을 높이기 위해 제안 할 자원의 일부가 될 것입니다.
    video: Bozhidar Batsov의 Ruby Mastery에 대한 긴 여행.
    computer_science_fundamentals:
      title: 컴퓨터 과학 기초
      articles:
        - name: inside_machine
          title: '머신 내부 : 마이크로 프로세서 및 컴퓨터 아키텍처에 대한 소개'
          description: 컴퓨터는 비즈니스에서 레크리에이션에 이르기까지 수많은 작업을 수행하지만 모양과 동작이 어떻게 다르게되어 있더라도
            기본 기능에서는 모두 놀랍도록 비슷합니다. 마이크로 프로세서 또는 CPU (Central Processing Unit)가 어떻게
            작동하는지 이해하면 모든 현대 컴퓨팅의 핵심 인 기본 개념을 확실하게 파악할 수 있습니다.
        - name: code
          title: '코드 : 컴퓨터 하드웨어 및 소프트웨어의 숨겨진 언어'
          description: 손전등, 영국 침략, 검은 고양이, 시소 등은 컴퓨터와 어떤 관련이 있습니까? CODE에서 우리는 언어를 조작하고
            서로 의사 소통 할 수있는 새로운 방법을 고안하는 독창적 인 방법을 보여줍니다. 그리고 CODE를 통해 우리는이 독창성과 의사 소통에
            대한 인간의 강박이 지난 두 세기의 기술 혁신을 어떻게 주도했는지를 봅니다.
        - name: concrete_math
          title: '구체적인 수학 : 컴퓨터 과학의 기초'
          description: 이 책은 고급 컴퓨터 프로그래밍과 알고리즘 분석을 지원하는 수학을 소개합니다. 잘 알려진 저자의 주된 목표는
            복잡한 문제를 해결하고, 끔찍한 총액을 평가하고, 데이터의 미묘한 패턴을 발견하는 데 필요한 기술 인 견고하고 적절한 수학 기술의
            기반을 제공하는 것입니다. 그것은 컴퓨터 과학자들에게 필수적인 텍스트 및 참조 일뿐만 아니라 저자들 스스로가 많이 의존하고 있습니다.
            그러나 사실상 모든 분야에서 수학을 중요하게 생각하는 사용자에게 적합합니다.
        - name: sicp
          title: 컴퓨터 프로그램의 구조와 해석
          description: 컴퓨터 프로그램의 구조와 해석은 지난 10 년 동안 컴퓨터 과학 교과 과정에 극적인 영향을 미쳤습니다. 이 대망의
            개정판에는 본문 전체의 변경 내용이 포함되어 있습니다. 인터프리터와 컴파일러를 비롯한 대부분의 주요 프로그래밍 시스템에 대한 새로운
            구현이 있었으며 저자는 초판 발행 이후 MIT의 코스를 가르치는 경험을 반영하는 작은 변화를 많이 포함 시켰습니다. 동시 모델링,
            동시 프로그래밍, 함수 프로그래밍, 게으른 평가 및 비 결정적 프로그래밍과 같은 전산 모델에서 시간 처리에 대한 다양한 접근 방식의
            중심 역할을 강조하는 새로운 테마가 도입되었습니다.
        - name: design_programms
          title: '프로그램 설계 방법 : 프로그래밍 및 컴퓨팅 소개'
          description: 프로그래밍에 대한 소개는 컴퓨터 과학을 교양 교육의 핵심에 자리 잡게합니다. 다른 입문서와 달리, 그것은 프로그램
            설계 과정에 중점을 둡니다. 이 접근법은 미래의 컴퓨터 프로그래머뿐만 아니라 모든 사람에게 중요한 중요한 읽기, 분석적 사고, 창의적인
            합성 및 세부 사항에 대한 관심 등 다양한 기술을 향상시킵니다. 이 책은 독자들에게 두 가지 근본적으로 새로운 아이디어를 제공합니다.
            첫째, 독자가 문제 진술을 분석하는 방법을 보여주는 프로그램 설계 지침을 제시합니다. 간결한 목표를 수립하는 방법; 예제를 만드는
            방법; 분석에 기초하여 솔루션 개요를 어떻게 개발할 것인가? 프로그램을 끝내는 방법; 및 테스트 방법.
        - name: algorithm_manual
          title: 알고리즘 설계 매뉴얼
          description: 이번에 새롭게 확장되고 업데이트 된 베스트 셀러 클래식의 두 번째 에디션은 알고리즘 설계에서 &quot;신비&quot;를
            취하고 효능 및 효율성을 분석합니다. 첫 번째 버전으로 확장되어이 책은 알고리즘 설계 과정의 주요 교과서 역할을하면서 프로그래머,
            연구원 및 학생을위한 최고의 실용 참조 안내서 역할을합니다.
        - name: cormen
          title: 알고리즘 소개, 제 3 판 (The MIT Press)
          description: 알고리즘에 대한 일부 책은 엄격하지만 불완전합니다. 다른 것들은 물질의 질량을 커버하지만 엄격함이 부족합니다.
            알고리즘 소개는 엄격함과 포괄 성을 고유하게 결합합니다. 이 책은 광범위한 알고리즘을 심층적으로 다루지 만 모든 레벨의 독자가 액세스
            할 수 있도록 설계 및 분석합니다. 각 장은 비교적 독립적이며 학습 단위로 사용할 수 있습니다. 알고리즘은 영어로 설명되고 의사
            코드는 약간의 프로그래밍을 수행 한 사람이 읽을 수 있도록 설계되었습니다. 설명은 적용 범위 또는 수학적 정확성을 희생시키지 않으면
            서 기본으로 유지되었습니다.
        - name: compilers
          title: '컴파일러 : Principles, Techniques, and Tools (2 판)'
          description: '컴파일러 : 교수, 학생 및 개발자가 &quot;드래곤 북&quot;으로 알고있는 원리, 기술 및 도구는 새
            버전에서 사용할 수 있습니다. 모든 장은 1986 년 이후 발행 된 소프트웨어 엔지니어링, 프로그래밍 언어 및 컴퓨터 아키텍처의
            개발을 반영하여 완전히 개정되었습니다. 필자는 컴파일러를 만들 독자가 거의 없을 것이며 소프트웨어 설계 및 소프트웨어 개발에 직면
            한 광범위한 문제에 초점을 맞추고 있습니다.'
        - name: c_lang
          title: C 프로그래밍 언어, 2nd Edition
          description: 저자는 ANSI 표준 C 언어 프로그래밍에 대한 전체 안내서를 제공합니다. C 개발자가 작성한이 새로운 버전은
            독자가 C에 대한 최종 ANSI 표준을 따라 가면서 C의 풍부한 연산자 집합, 표현의 경제, 개선 된 제어 흐름 및 데이터 구조를
            활용하는 방법을 보여줍니다. 2 / E는 어려운 언어 구조의 구현을 명확히하기위한 추가 예제와 문제 세트로 완전히 다시 작성되었습니다.
            수년 동안 C 프로그래머는 K &amp; R이 구조화되고 효율적인 프로그램을 작성하도록 안내했습니다. 이제이 같은 도움말을 ANSI
            컴파일러로 작업하는 사람들이 사용할 수 있습니다. 구문 표기법, 선언, ANSI 변경 사항, 범위 규칙 및 도움말 목록을 한 눈에
            볼 수 있도록 C 언어 및 공식 C 언어 참조 설명서에 대한 자세한 내용이 포함되어 있습니다.
    oop:
      title: 객체 지향 프로그래밍
      articles:
        - name: growing
          title: 증가하는 객체 지향 소프트웨어, 테스트 지침
          description: 'TDD (Test-Driven Development)는 이제 더 나은 소프트웨어를보다 빠르게 제공하기위한 확립
            된 기술입니다. TDD는 간단한 아이디어를 기반으로합니다 : 코드 자체를 작성하기 전에 코드에 대한 테스트를 작성하십시오. 그러나이
            &quot;단순한&quot;아이디어는 잘하기 위해 기술과 판단을 필요로합니다. 이제 기본 개념을 뛰어 넘는 TDD에 대한 실용적인
            가이드가 있습니다. 실제 시스템을 구축 한 10 년의 경험을 바탕으로 두 명의 TDD 개척자는 테스트가 일관성 있고 안정적이며 유지
            보수가 가능한 개발 및 &quot;성장&quot;하는 소프트웨어를 안내하는 방법을 보여줍니다.'
        - name: domain_driven
          title: '도메인 중심 디자인 : 소프트웨어의 핵심 요소 인 복잡성 해결'
          description: 이것은 소프트웨어 디자인에서 도메인 모델링에 관한 중요한 책입니다. 소프트웨어 개발 사회는 과대 선전에서 또
            다른 선전에 이르기까지 다양합니다. OOP, 패턴, XP, TDD, CI / CD, BigData, DevOps 등이 있습니다.
            이 책은 OOP의 황금 시대에서 유래했습니다. 저자는 객체 지향 패러다임 만이 유일한 것이 아니라 OOP / OOD에 대한 편견이
            명백하고 (정당한) 것을 인정한다. 이 책은 핵심 소프트웨어 구성 요소의 모델링을 &quot;올바른 방법&quot;으로 수행하는
            방법에 대해 설명합니다.
    ruby:
      title: 너를 알고있어.
      articles:
        - name: well_grounded
          title: 잘 훈련 된 루비스트
          description: Well-Grounded Rubyist, Second Edition은 Ruby에 대한 새로운 이해와 언어에 대한
            이해를 깊게하는 Ruby 프로그래머를 대상으로합니다. 이 아름답게 쓰여지고 완전히 개정 된 두 번째 에디션에는 Ruby 2.1의
            새로운 기능과 변경된 언어 측면의 확장 된 업데이트 된 내용이 포함되어 있습니다.
        - name: programming_ruby
          title: '루비 프로그래밍 : Pragmatic Programmers Guide, Second Edition'
          description: '루비는 점점 더 대중적이면서도 완벽하게 객체 지향적 인 동적 프로그래밍 언어입니다. 많은 실무자들이 오늘날
            가장 유용하고 유용한 언어로 환영 받고 있습니다. Ruby가 서구 세계에서 처음으로 파문을 일으켰을 때 Pragmatic Programmers는
            확실한 참조 설명서 인 Programming Ruby : The Pragmatic Programmer &#39;s Guide와 함께있었습니다.'
        - name: ruby_programming
          title: 'Ruby 프로그래밍 언어 : 알아야 할 모든 것'
          description: 이 책은 언어에 대한 빠른 시작 자습서로 시작하여 어휘 및 구문 구조에서 데이터 유형, 표현식, 명령문, 메소드,
            블록, 람다, 클로저, 클래스 및 클래스에 이르기까지 세부적으로 언어를 자세히 설명합니다. 모듈. 이 책에는 또한 루비 플랫폼의
            풍부한 API에 대한 길고도 철저한 소개가 포함되어 있으며, 텍스트 처리, 숫자 조작, 콜렉션, 입출력, 네트워킹 및 동시성에 대한
            Ruby의 기능을 설명합니다. 전체 장은 Ruby의 메타 프로그래밍 기능에 전념합니다.
  interview_questions:
    title: 인터뷰 질문들
    description: 이 섹션에서는 읽기 및 인터뷰 준비를위한 리소스 링크를 유지합니다.
    list:
      - name: 'Toptal : 위대한 루비 개발자를 고용하는 법'
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: '토탈 : 21 가지 루비 인터뷰 질문'
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: 'Hookops : 35+ Ruby and Rails 인터뷰 질문 및 답변'
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: 'Educba : 15 가지 가장 중요한 Ruby 인터뷰 질문 및 답변'
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: 'Ruby Garage : Ruby on Rails 개발자 인터뷰 방법'
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: 'RyanSobol : Ruby 인터뷰에서 묻는 15 가지 질문'
        link: "https://gist.github.com/ryansobol/5252653"
      - name: 'Toptal : 9 Ruby on Rails 인터뷰 질문'
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: 더 나은 문서 도구 란 무엇인가?
    description: 이 웹 사이트는 웹 적응 Github 저장소 <a href="https://github.com/khusnetdinov/ruby.fundamental">Ruby</a>
      입니다. 많은 별을 수집하고 중국어로 번역되었습니다. 더 나은 문서 도구를 사용하면 하나의 저장소에서 수집 된 많은 우수 사례를 신속하게 찾을
      수 있습니다. 이 레포는 참조 또는 인터뷰 준비 리소스와 같습니다.
    oss:
      title: 오픈 소스에 감사드립니다.
      description: Ruby로 작성된 웹 개발 응용 프로그램의 오픈 소스 엔지니어링 인 Ruby에 대한 모범 사례와 지식을 확인하고 작업하는
        동안 Better Docs가 만들어졌습니다.
      thanks: Better Docs가 어떤 방식 으로든 도움이 되었다면 <a href="https://github.com/howtohireme/ruby.fundamental">Github에</a>
        별을 부여하는 것 (더 많은 개발자에게 다가 갈 수 있음)을 주거나 프로젝트에 기여하는 것에 대해 생각해보십시오.
