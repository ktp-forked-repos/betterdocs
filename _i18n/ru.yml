head:
  title: "Ruby Fundamental"
  metatags:
    description: "Основы Ruby с примерами и полезными ссылками. Вы прочтете про потоки, принцип SOLID, паттерны проектирования, структуры данных, алгоритмы."
    keywords: "Ruby, Fundamental, Ruby programming fundamental. Ruby gotchas, Functional programming, Metaprogramming, Threads, Ruby solid princinle with examples, Ruby design patterns with examples, Ruby algorithms with examples, Ruby data structures with examples."

content:
  menu:
    open: "Открыть меню"
    close: "Закрыть меню"

sidebar:
  - title: "Алгоритмы"
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: "Структуры Данных"
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: "Шаблоны проектирования"
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: "Функциональное программирование"
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: "Готчи"
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: "Вопросы на интервью"
    url: interview_questions
  - title: "Метапрограммирование"
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: "СОЛИД"
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: "Станьте специалистом в Руби"
    url: ruby_meister
  - title: "Потоки"
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:
  wiki: "Читать wiki"
  credits: "Credits"
  page404:
    title: "Страница не найдена :("
    description: "Запрошенная страница не найдена."
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: "Алгоритмы"
    complexity:
      best: "Лучшие"
      average: "Средние"
      worst: "Наихудшие"
    sorting:
      title: "Сортировка"
      description: "Алгоритм сортировки - это алгоритм, который помещает элементы списка в определенном порядке. Наиболее часто используемые сортировки - это сортировка по порядковому номеру и по лексикографическому порядку. Эффективная сортировка важна для оптимизации использования других алгоритмов (таких как алгоритмы поиска и слияния), которые требуют ввода входных данных в отсортированные списки. Алгоритм сортировки также часто полезен для канонификации данных и для получения удобочитаемой информации."
      bubble_sort:
        title: "Пузырьковая сортировка"
        description: "Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма)."
      insertion_sort:
        title: "Сортировка методом вставок"
        description: "Алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов"
      selection_sort:
        title: "Сортировка методом выбора (наименьшего или наибольшего элемента)"
        description: "Из приведенного здесь сравнения можно сделать вывод, что сортировка не должна использоваться. Алгоритм сортировки никоим образом не адаптируется к данным (обратите внимание, что четыре анимации выше работают в режиме блокировки), поэтому время выполнения алгоритма всегда квадратично. Однако сортировка выбором имеет свойство минимизировать количество свопов. В приложениях, где стоимость подкачки элементов высока, сортировка методом выбора может быть очень хорошим выбором."
      shell_sort:
        title: "Сортировка (методом) Шелла"
        description: "Алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется сортировка расчёской."
      heap_sort:
        title: "Пирамидальная сортировка"
        description:
          "В основе пирамидальной сортировки лежит специальный тип бинарного дерева, называемый пирамидой; значение корня в любом поддереве такого дерева больше, чем значение каждого из его потомков. Непосредственные потомки каждого узла не упорядочены, поэтому иногда левый непосредственный потомок оказывается больше правого, а иногда наоборот. Пирамида представляет собой полное дерево, в котором заполнение нового уровня начинается только после того, как предыдущий уровень заполнен целиком, а все узлы на одном уровне заполняются слева направо.
          Сортировка начинается с построения пирамиды. При этом максимальный элемент списка оказывается в вершине дерева: ведь потомки вершины обязательно должны быть меньше. Затем корень записывается последним элементом списка, а пирамида с удаленным максимальным элементом переформировывается. В результате в корне оказывается второй по величине элемент, он копируется в список, и процедура повторяется пока все элементы не окажутся возвращенными в список."
      merge_sort:
        title: "Сортировка методом слияния"
        description: "Алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи."
      quick_sort:
        title: "Быстрая сортировка"
        description:
          "QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного, в том числе, своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. Любопытный факт: улучшение самого неэффективного прямого метода сортировки дало в результате один из наиболее эффективных улучшенных методов.
          Общая идея алгоритма состоит в следующем:
          Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см.ниже).
          Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного», «равные» и «большие».
          Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
          На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.
          Хоар разработал этот метод применительно к машинному переводу; словарь хранился на магнитной ленте, и сортировка слов обрабатываемого текста позволяла получить их переводы за один прогон ленты, без перемотки её назад. Алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой русско-английского разговорника."
      other: "Другие алгоритмы сортировок"
      additional: "Дополнительное чтение"
    searching:
      title: "Поиск"
      binary_search:
        title: "Двоичный [дихотомический] поиск"
        description: "В информатике двоичный поиск, также известный как поиск с половинным интервалом или логарифмический поиск, представляет собой алгоритм поиска, который находит положение целевого значения в отсортированном массиве. Он сравнивает целевое значение с средним элементом массива; если они неравны, половина, в которой цель не может лежать, устраняется, и поиск продолжается на оставшейся половине до тех пор, пока он не будет успешен."
      knuth_moriss_pratt_search:
        title: "Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)"
        description: "Алгоритм представляет собой поиск образца (подстроки) в строке."
      other:
        title: "Другие поисковые алгоритмы"
        dijkstra: "Алгори́тм Дейкстры"
        kruskal: "Алгоритм Краскала"
        longest: "Наибольшая возрастающая подпоследовательность"
        telephone_number: "Номер телефона для слов"
    credits: "Код и статьи были взяты из ресурсов:"
  data_structures:
    title: "Структуры данных"
    description: "В информатике большая нотация O используется для классификации алгоритмов тем, как они реагируют на изменения размера ввода, например, как изменяется время обработки алгоритма, поскольку размер проблемы становится чрезвычайно большим. В аналитической теории чисел она используется для оценки «допущенной ошибки» при замене асимптотического размера арифметической функции на значение, которое оно принимает при большом конечном аргументе. Известным примером является задача оценки остаточного члена в теореме о простых числах."
    axioms:
      title: "Основные аксиомы структур данных"
      description: "Производительность времени выполнения общей языковой среды задается набором аксиом, которые мы теперь будем теоретически допускать."
      fetch_store:
        title: "Время получения и хранения"
        description1: "Время, необходимое для получения ссылки на объект из памяти, является константой <span class=\"code-inline\">T_fetch</span>, а время, необходимое для хранения ссылки на объект в памяти, является константой, <span class=\"code-inline\">T_store</span>"
        description2: "Согласно аксиоме, оператор присваивания имеет время выполнения <span class=\"code-inline\">T_fetch + T_store</span>. То есть, время, затраченное на получение ссылки на объект из переменной x, является <span class=\"code-inline\">T_fetch</span>, и время, затраченное на сохранение этой ссылки объекта в переменной y, является <span class=\"code-inline\">T_store</span>."
        description3: "Также имеет время выполнения <span class=\"code-inline\">T_fetch + T_store </span>. Чтобы понять, почему это должно быть так, считайте, что константа <span class=\"code-inline\"> 1 </span> обозначает объект Fixnum со значением один. Поэтому мы можем ожидать, что стоимость получения ссылки на объект с именем 1 будет такой же, как и выборка ссылки на любой другой объект."
      elementary_operations:
        title: "Время элементарных арифметических операций"
        description1: "Время, необходимое для выполнения элементарных арифметических операций, таких как сложение, вычитание, умножение, деление и сравнение, являются постоянными. Эти времена обозначаются символом <span class =\"code-inline\">T_+, T_-, T_/, T_*, T_<</span>, соответственно."
        description2: "Мы можем определить время выражения, например: <span class =\"code-inline\"> 2 * T_fetch + T_ + + T_store </span>. Это связано с тем, что нам нужно получить две ссылки на объекты из переменных y и 1; выполнить добавление, дающее новый объект, значение которого представляет собой сумму; и сохраните ссылку на новый объект в переменной y."
        description3: "Будем предполагать, что альтернатива требует точно такого же времени работы, что и исходное утверждение."
      call_method:
        title: "Время вызова метода"
        description1: "Время, требуемое для вызова метода, является константой, <span class =\"code-inline\"> T_call </span>, а время, необходимое для возврата из метода, является константой, <span class =\"code-inline\"> T_return </span> Обоснование для того, чтобы накладные расходы, связанные с передачей параметра, совпадали с временем хранения ссылки на объект, заключается в том, что передача аргумента концептуально совпадает с назначением фактического значения параметра формальному параметр метода."
        description2: "Согласно аксиоме, время выполнения оператора будет <span class =\"code-inline\"> T_fetch + 2 * T_store + T_call + T_f (x) </span>, где <span class = \"code-inline\"> T_f (x) </span> - время работы метода f для ввода x. Первое из двух хранилищ связано с передачей параметра x методу f; вторая возникает из присваивания переменной y."
      calculating:
        title: "Время вычисления"
        description1: "Время, требуемое для вычисления адреса, подразумеваемого операцией подписки на массив, например, <span class =\"code-inline\"> a [i] </span>, является константой, <span class =\"code-inline\"> T _ [] </span>. Это время не включает время вычисления выражения подстроки и не включает время доступа к элементу массива."
        description2: "Это <span class = \"code-inline\"> 3 * T_fetch </span>. Требуются три выборки операндов: первый для получения ссылки на объект массива a; второй - для получения ссылки на индексный объект i; и третий для получения ссылки на элемент массива <span class =\"code-inline\"> a [i] </span>."
      object:
        title: "Время создания объекта"
        description1: "Время, необходимое для создания экземпляра нового объекта класса, является константой, <span class =\"code-inline\"> T_new </span>. Это время не включает время, затрачиваемое на инициализацию объекта. Применяя аксиомы, мы можем определить, что время выполнения выражения."
        description2: "<span class =\"code-inline\"> T_new + T_fetch + 2 * T_store + T_call + T_fixnum_init, </span> где <span class =\"code-inline\"> T_fixnum_init </span> - это время выполнения метода инициализации класса Fixnum."
      example:
        title: "Пример"
        description: "В этом разделе мы применяем аксиомы, анализируя время выполнения программы для вычисления следующего простого суммирования арифметических рядов."
    implementations:
      title: "Реализация"
      stack:
        title: "Стек"
        description: "Стек является дочерним элементом очереди. Он имитирует реальный стек (например, бумаги). Это FILO (first-in-last-out), так что, когда элементы извлекаются из стека, они возвращаются в обратном порядке, в котором они были добавлены. Опять же, массивы в Руби обеспечивают идеальный контейнер. Как и в случае с очередью, он также может быть реализован с использованием связанного списка."
        as_array: "Стек как массив"
        as_linked_list: "Стек как связанный список"
      queue:
        title: "Очередь"
        description: "Очередь - это простая структура на основе контейнера, которая имитирует реальную очередь (например, ожидание в строке в банке). Это FIFO (first-in-first-out), что означает, что при извлечении элементов из очереди они возвращаются в том порядке, в котором они были введены. Массивы в руби предоставляют методы, которые делают реализацию очереди тривиально простой, но с их именем, соответствующим образом и содержащимся в классе удобства, стоит того, чтобы увидеть, что они реализованы, и потому что другие структуры наследуют от этого. Альтернативная реализация может быть выполнена с использованием связанного списка."
        as_array: "Очередь как массив"
        as_linked_list: "Очередь как связанный список"
      deque:
        title: "Очередь с двусторонним доступом"
        description: "Очередь с двусторонним доступом - это очередь, которая позволяет добавлять и удалять элементы с обоих концов."
        as_array: "Очередь с двусторонним доступом как массив"
        as_linked_list: "Очередь с двусторонним доступом как связанный список"
      singly_linked_list:
        title: "Однонаправленный список"
        description: "Отдельно связанные элементы содержат узлы, у которых есть поле данных, а также поле «next», которое указывает на следующий элемент в строке списке. Операции, которые могут выполняться в таких списках, включают в себя вставку, удаление и обход."
      doubly_linked_list:
        title: "Двунаправленный список"
        description: "В данном виде списка каждый элемент содержит две ссылки: одну для ее преемника и одну для своего предшественника."
      ordered_list:
        title: "Упорядоченный список"
        description: "Упорядоченный список - это список, в котором каждый элемент имеет свой порядковый номер. Однако элементы в упорядоченных списках необязательно сортируются. Следовательно, можно изменить порядок позиций и по-прежнему иметь действительный упорядоченный список."
        as_array: "Упорядоченный список как массив"
      hash_table:
        title: "Хеш-таблица"
        description: "Хэш-таблица является контейнером для поиска. Таким образом, он предоставляет методы для помещения объекта в контейнер, поиска объекта в контейнере и удаления объекта из контейнера."
      binary_tree:
        title: "Двоичное дерево"
        description: "Двоичное дерево - это дерево, в котором каждый узел может иметь максимум двух детей. Дети назначаются слева и справа."
      binary_search_tree:
        title: "Двоичное дерево поиска"
        description: "В информатике двоичные деревья поиска (BST), иногда называемые упорядоченными или отсортированными двоичными деревьями, представляют собой особый тип контейнеров: структуры данных, которые хранят «элементы» (например, числа, имена и т. Д.) В памяти. Они позволяют быстро находить, добавлять и удалять элементы и могут использоваться для реализации либо динамических наборов элементов, либо поисковых таблиц, которые позволяют находить элемент по его ключу (например, найти номер телефона человека по имени)"
      b_tree:
        title: "В-дерево"
        description: "В информатике B-дерево представляет собой структуру дерева с балансировкой, которая сортирует данные и позволяет осуществлять поиск, последовательный доступ, вставки и удаления в логарифмическом времени. B-дерево - это обобщение двоичного дерева поиска, в котором узел может иметь более двух дочерних элементов (в отличие от самоустанавливающихся двоичных деревьев поиска, B-дерево оптимизировано для систем, которые читают и записывают большие блоки данных. B-деревья - хороший пример структуры данных для внешней памяти. Он обычно используется в базах данных и файловых системах."
      binary_heap:
        title: "Двоичная куча"
        description: "Бинарная куча представляет собой кучное упорядоченное двоичное дерево, которое реализуется с использованием массива. В куче самый маленький ключ находится в корне, и поскольку корень всегда находится в первой позиции массива, поиск наименьшего ключа - это тривиальная операция в двоичной куче."
      credits: "Код и статьи были взяты из ресурсов:"
      source: "Эта страница содержит код Ruby из книги \"Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby\" by Bruno R. Preiss. Copyright (c) 2004 by Bruno R. Preiss, P.Eng. All rights reserved."
  design_patterns:
    title: "Шаблоны проектирования"
    creational:
      title: "Создание шаблонов"
      description: "В разработке программного обеспечения шаблоны разработки - это шаблоны проектирования, которые касаются механизмов создания объектов, пытаясь создать объекты в соответствии с ситуацией. Основная форма создания объекта может привести к проблемам проектирования или сложности с дизайном. Создание шаблонов проектирования решает эту проблему, как-то контролируя создание этого объекта. Творческие шаблоны проектирования состоят из двух доминирующих идей. Одним из них является инкапсуляция знаний о том, какие конкретные классы использует система. Другой скрывает, как экземпляры этих конкретных классов создаются и объединяются."
      abstract_factory:
        title: "Шаблон проектирования Абстрактная фабрика"
        description: "Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс. Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов."
      builder:
        title: "Шаблон проектирования Строитель"
        description: "Строитель (англ. Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта. Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления."
      factory:
        title: "Шаблон Фабричный метод"
        description: "Фабричный метод (англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне."
      prototype:
        title: "Шаблон Прототип"
        description: "Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации."
      singleton:
        title: "Шаблон проектирования Одиночка"
        description: "Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа."
      not_covered:
        title: "Не рассмотренные шаблоны:"
        lazy: "Ленивая инициализация"
        multiton: "Пул одиночек"
        pool: "Объектный пул"
        resource: "Получение ресурса есть инициализация"
    structural:
      title: "Структурные шаблоны проектирования"
      description: "Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками решения определенных проблем в определенных ситуациях."
      adapter:
        title: "Шаблон Адаптер"
        description: "Адаптер — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс."
      composite:
        title: "Шаблон Компоновщик"
        description: "Компоновщик — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым."
      decorator:
        title: "Шаблон Декоратор"
        description: "Декоратор — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности."
      facade:
        title: "Шаблон Фасад"
        description: "Фасад — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы."
      flyweight:
        title: "Шаблон Приспособленец"
        description: "Приспособленец — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым."
      proxy:
        title: "Заместитель"
        description: "Заместитель — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера)."
      protection_proxy:
        title: "Защищающий заместитель"
        description: "Защищающий заместитель. Может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права"
      virtual_proxy:
        title: "Виртуальный заместитель"
        description: "Виртуальный заместитель обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание,"
      remote_proxy:
        title: "Удалённый заместитель"
        description: "Удалённый заместитель. Обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»"
      not_covered:
        title: "Не рассмотренные шаблоны:"
        callback: "Колбек с аннотацией / описанием"
        bridge: "Мост"
        data_bus: "Шина"
        role: "Объект роли"
    behavioral:
      title: "Поведенческие паттерны проектирования"
      description: "Поведенческие шаблоны проектирования определяют общие закономерности связей между объектами, реализующими данные паттерны. Следование этим шаблонам уменьшает связность системы и облегчает коммуникацию между объектами, что улучшает гибкость программного продукта."
      chain_of_responsobility:
        title: "Шаблон Цепочка Обязанностей (Chain Of Responsibilities)"
        description: "Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи."
      command:
        title: "Шаблон Команда"
        description: "Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций."
      interpreter:
        title: "Шаблон Интерпретатор"
        description: "Интерпретатор — поведенческий шаблон проектирования, решающий часто встречающуюся, но подверженную изменениям, задачу. "
      iterator:
        title: "Шаблон Итератор"
        description: "Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления."
      external_iterator:
        title: "Шаблон Внешний Итератор"
        description: "Внешний Итератор: Итерационная логика содержится в отдельном классе. Итерационный класс может быть выделен отдельно, что бы иметь возможность обрабатывать несколько типов объектов до тех пор пока они поддерживают индексы. Это требует того, что бы отдельный класс проводил реальный обход, но они позволяют добиться большей гибкости, потому что вы можете контролировать обход, какие элементы обходить и в какой последовательности."
      internal_iterator:
        title: "Шаблон Внутренний Итератор"
        description: "Внутренний итератор: вся логика итерации происходит внутри совокупного объекта. Используйте блок кода, что бы передать вашу логику в агрегатор, которы затем вызывает блок для каждого из его элементов."
      mediator:
        title: "Шаблон Посредник"
        description: "Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник."
        title: "Шаблон Снимок"
        description: "Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации."
      momento:
        title: "Шаблон Хранитель"
        description: "Шаблон Хранитель реализуется тремя объектами: \"Создателем\" (originator), \"Опекуном\" (caretaker) и \"Хранителем\" (memento). Создатель это некоторый объект, который имеет внутреннее состояние. Опекун будет произвоить некоторые действия с создателем, но с возможностью отката изменений. Опекун сначала запрашивает у Создателя объект Хранителя. Затем выполняет действие (или набор действий), которое он собирался выполнить. Что бы откатиться обратно к состоянию до выполненных действий, он возвращает объект Хранителя объекту Создателя. Объект Хранителя сам по себе является непрозрачным (т.е. таким, который Опекун не может или не должен изменять). Когда используется этот паттерн, нужно быть осторожным, если Создатель может изменять другие объекты или ресурсы - паттерн Хранитель оперирует на одном объекте."
      observer:
        title: "Шаблон Наблюдатель"
        description: "Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах."
      state:
        title: "Шаблон Состояние"
        description: "Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта."
      strategy:
        title: "Шаблон Стратегия"
        description: "Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы."
      template:
        title: "Шаблон Шаблонный метод"
        description: "Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры."
      visitor:
        title: "Шаблон Посетитель"
        description: "Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться."
      not_covered:
        title: "Не рассмотренные шаблоны:"
        hierarchical: "Hierarchical visitor"
      credits: "Код и статьи были взяты из ресурсов:"
  functional_programming:
    title: "Функциональное программирование"
    description: "Использование языка в функциональном стиле подразумевает, что у вас есть доступ к нескольким ключевым определениям, перечисленным ниже:"
    axioms:
      immutable: "Неизменяемые значения: после установки «переменной» его нельзя изменить. В Ruby это означает, что вам необходимо обрабатывать переменные, так как константы."
      side_effects: "Никаких побочных эффектов: при передаче заданного значения функция всегда должна возвращать одно и тоже значение. Это идет рука об руку с неизменными значениями; функция никогда не может принять значение и изменить его, так как это приведет к побочному эффекту, касающемуся возврата результата."
      pure_functions: "Функции более высокого порядка: это функции, которые позволяют использовать функции в качестве аргументов или использовать функции в качестве возвращаемого значения. Это, возможно, одна из самых важных функций любого функционального языка."
      applying: "Карирование: включена в высокоуровневые функции, превращает функцию, которая принимает несколько аргументов, в функцию, которая принимает один аргумент. Это идет рука об руку с частичным вызовом функции, который трансформирует функцию с несколькими аргументами в функцию, которая принимает меньшее количество аргументов, чем она принимала изначально"
      recursion: "Рекурсия: цикл, вызывая функцию изнутри. Когда у вас нет доступа к изменяемым данным, рекурсия используется для построения и построения цепочки данных. Это связано с тем, что цикл не является функциональной концепцией, так как он требует передачи переменных для хранения состояния цикла в данный момент времени."
      lazy: "Ленивое выполнение или отсроченное выполнение: отсрочка обработки значений до момента, когда это действительно необходимо. Если, например, у вас есть код, который сгенерировал список чисел Фибоначчи с включенной ленивой оценкой, это фактически не обрабатывалось бы и не вычислялось до тех пор, пока одно из значений в результате не потребовалось бы другой функции, такой как puts."
    pure_functions:
      title: "Чистые функции"
      description: "Вы можете видеть, что эта функция вычисляет результат только с использованием своих аргументов."
    closures:
      title: "Замыкания"
      description: "Лямбда также обеспечивает замыкание и, таким образом, сохраняет свой контекст между объектами."
    applying:
      title: "Частичное применение функции и каррирование"
      description: "Давайте сначала поймем, каковы эти два разных применения функций. Частичное применение функции — процесс фиксации числа аргументов, который создает другую функцию с меньшим количеством аргументов. Каррирование — разделение функции, принимающей несколько аргументов, на N функций, принимающих один аргумент."
      proc: "Для того, что бы дать вам более четкую идею того, что каждая из этих двух вещей делает с функцией, давайте возьмем пример с Proc."
      partial: "Частичное применение этой функции должно вернуть, если мы передадим первые два аргумента, следующие "
      curry: "<span class=\"code-inline\">.curry</span> возвращает каррированный proc. Если передан опциональный аргумент arity, он определяет количество аргументов. Каррированный proc получает некоторые аргументы. Если предоставлен необходимое количество аргументов, она передает предоставленные аргументы оригинальной proc и возвращает результат. В противном случае, возвращает еще одну каррированную proc, которая принимает оставшиеся аргументы."
  gotchas:
    title: "Находки"
    description1: "Большинство новичков в Ruby on Rails радуются простотой фреймворка и начинают создавать приложения без какого-либо знания языка. И это волшебство RoR."
    description2: "В какой-то момент все начинает становиться серьезным. Некоторым требуется время и усилия, чтобы исследовать грязные секреты Ruby on Rails, в то время как другие замалчиваются и становятся старшими разработчиками с почти нулевым знанием языка."
    description3: "Во всяком случае, рано или поздно, начинающие или опытные программисты, мы все сталкиваемся с так называемыми Ruby Gotchas (находками в Руби)- теми небольшими языковыми тонкостями, которые скрываются от нашего сайта часами хардкорной отладки."
    description4: "Вот список популярных Руби-находок и любопытных штук которые должны знать разработчики. Для каждого случая есть пример запутывающего и / или подверженного ошибкам кода."
    description5: "Они сочетаются с хорошими практиками, которые не позволят вам сделать простые (но трудные для поиска) ошибки и упростить вашу жизнь (и ваш поддерживающий код)."
    surprising:
      title: "Руби может быть удивить"
      description: "Хотя «спроектированный для максимизации счастья программиста», с «принципом наименьшего сюрприза», Ruby все еще имеет ловушки. Эта презентация будет проходить от тривиальных ошибок которые допускают новички, до более продвинутых и запутанных ошибок."
    quotes:
      title: "Не цитируйте меня по этому поводу, но ..."
      description: "Строковая интерполяция (включая специальные символы, такие как <span class=\"code-inline\">\\n</span>) завершается с помощью <span class=\"code-inline\">\"single\"</span> для этого требуются кавычки <span class =\"code-inline\">\"double\"</span>. Точно так же, как на большинстве языков со строчной интерполяцией. Чтобы избежать этого, используйте каждый раз, когда это целесообразно."
    twue:
      title: "Это пвавда! Это пвавда!"
      description: "Только две вещи ложны: <span class=\"code-inline\">false</span> и <span class=\"code-inline\">nil</span>. Все остальное - truthy, даже <span class=\"code-inline\">0</span> (false в C), <span class=\"code-inline\">\"\"</span> (false в JS), <span class=\"code-inline\">[]</span>, итд. Это приводит к ошибкам людей из C, JS, итд., гдe некоторые из этих выражений равны false."
    symbols_and_strings:
      title: "Повесьте его чучело, символически."
      description: "<span class=\"code-inline\">Symbol != String</span>. Даже если при выводе получается одинаковое значение. Помните что используется в аргументах. В идеальном случае принимайте оба и используйте только то, что принимает метод: \"Будь либерален к тому, что принимаешь, и требователен к тому, что отсылаешь.\" правило Джона Постела."
    string_or_nothing:
      title: "Строка ... или ничего!"
    constants:
      title: "Строки не..."
      description: "Запись переменной в верхнем регистре в Ruby означает константу. Попробуйте изменить константу. Оооо, у тебя есть ПРЕДУПРЕЖДЕНИЕ! Для Fixnums даже замораживание не работает. Оно работает для массивов (или что-то в этом роде) и большинства других объектов ... предвещал он."
    equals:
      title: "Некоторые из них более равны, чем другие"
      description: "<span class=\"code-inline\">==</span> - простое сравнение по значению, <span class=\"code-inline\">.eql?</span> - по значению и классу (1 это Fixnum, 1.0 это Float), <span class=\"code-inline\">.equal?</span> - проверка на идентичность объектов. hairier. Это действительно довольно запутанно."
    operations:
      title: ">=== != ==!"
      description: "<span class=\"code-inline\">===</span> это \"case equality\", используется в case выражениях. Более подходящее название могло бы быть <span class=\"code-inline\">.describes?</span>, или перегрузка <span class=\"code-inline\">.includes?</span>. И снова, это довольно запутанно; смотрите документацию класса Object. Это сбивает с толку людей из других языков, в которых <span class=\"code-inline\">===</span> является сравнением идентичности либо по значению и классу."
    priority:
      title: "and != &&, or != ||"
      description: "<span class=\"code-inline\">&&</span> имеет более высокий приоритет, чем <span class=\"code-inline\">=</span>, таким образом <span class=\"code-inline\">x = true && false</span> означает <span class=\"code-inline\">x = (true && false)</span>. У <span class=\"code-inline\">and</span> же наоборот приоритет более низкий, поэтому <span class=\"code-inline\">x = true and false</span> означает <span class=\"code-inline\">(x = true) and false</span>. В соответствии с Ruby Style Guide: Используйте <span class=\"code-inline\">&&, ||</span> для логических выражений, <span class=\"code-inline\">and, or</span> для управлением выполнения."
    sensitive:
      title: "Не будьте так чувствительны!"
      description: "Не чувствителен к пробелам? НЕ ВСЕГДА! Парсер считает это выражением, как передача аргумента, но <span class=\"code-inline\">(1, 2)</span> не является валидным выражением в Ruby! (Все работает для 1 аргумента)."
      usage: >
        With multiple args:
        <br/>
        - Нет скобок, нет проблем.
        <br/>
        - Пробелы внутри скобок, OK.
        <br/>
        - Скобки и пробелы, НЕТ!
      methods: "<span class=\"code-inline\">method /num</span> это неоконченное регулярное выражение или строка! Ruby считает, что вы передаете аргумент в метод. Общий принцип: используйте пробелы СБАЛАНСИРОВАННО; с обеих сторон или ни с одной."
      arguments: "<span class=\"code-inline\">one -2</span> заставляет руби думать, что вы передаете аргумент <span class=\"code-inline\">-2</span> в метод one. Тоже самое для <span class=\"code-inline\">+2</span> и даже для <span class=\"code-inline\">*2</span>. И снова: используйте пробелы СБАЛАНСИРОВАННО; с обеих сторон или ни с одной."
      stubby: "\"Stabby\" lambdas (1.9+) Скобки опциональны, пробел перед и после аргументов, OK. Пробел после скобок, OK. И снова, пробел перед скобками, НЕТ! ОБНОВЛЕНИЕ: Исправлено в 2.0!"
    onto:
      title: "Положись на свою @!"
      description: "Простые переменные становятся временными локальными переменными! Решение: помните про <span class=\"code-inline\">@!</span> (Или \"self.\". Или используйте <span class=\"code-inline\">attr_writer,  attr_accessor</span>.) Необычно для людей из Java / C++, и не сильно Python (который также требует \"self.\"). \"Вы все еще используете эту переменную. А я думаю, что она значит совсем не то, что вы думаете.\". Не Иниго Монтойя."
    variables:
      title: "Берегись, это @@!"
      description: "Похоже, что заполняешь пустое? Мы не меняли ни значение родительского <span class=\"code-inline\">@@value</span> перед проверкой, ни значение дочернего класса! Или все-таки меняли? <span class=\"code-inline\">@@variables</span> являются общими для подклассов - не их существование, а переменные сами по себе! Определение <span class=\"code-inline\">@@value</span> в дочернем классе изменило это значение в родительском, и инкремент родительского изменил значение в дочернем. Что ж. это @@!"
    initialize:
      title: "С init(ialize) или без него"
      description: "Родительский initialize выполняется автоматически только если он есть в дочернем классе. И родительски должен быть вызван для его выполнения."
    superman:
      title: "Супермен против человека - невидимки"
      description: "<span class=\"code-inline\">super</span> без списка аргументов передает свои получиенные аргументы, <span class=\"code-inline\">super</span> с определенными аргументами передает только их. Что бы вызвать его БЕЗ аргументов используйте пустые скобки: <span class=\"code-inline\">super()</span>."
    regexp:
      title: "Когда это закончится? (Или начнётся?)"
      description: "В стандарте регулярных выражений: <span class=\"code-inlne\">^</span> это начало строки, и <span class=\"code-inline\">$</span> - это конец всей строки. Регулярные выражения в Ruby по умолчанию многостроковые, так что: <span class=\"code-inline\">^</span> - это начало, и <span class=\"code-inline\">$</span> - это конец любой строки! <span class=\"code-inline\">\\A</span> - это начало, и <span class=\"code-inline\">\\Z</span> - это конец всей строки (Или \\z для включения новой строки… Что является другой находкой!)"
    any:
      title: "получая любой (.any?)"
      description: "<span class=\"code-inline\">.any?</span> не значит \"любой элемент?\"! С блоком это: \"сделай что-нибудь, что бы блок вернул true?\". Без блока: \" какое-либо значение верно?\" Имеет неявный блок: <span class=\"code-inline\">{ |element| element }</span>."
    undef:
      title: "(Un)Def Леопард"
      description: "Переменные объявленные в блоках, передаваемых итераторам (например, times или each), не определены в каждой итерации! Итераторы вызывают блок неоднократно, таким образом переменны находятся вне области выполнения после каждого вызова. Для встроенных конструкций циклов (например, while или for) - это OK. (или делайте определения переменных до определения блоков.)"
    freeze:
      title: "Заморозь массив"
      description: "Заморжавивание массива (или хэша) замораживает его, но не то что он содержит. Строки могут быть модифицированы на месте. Таким образом, вы можете модифицировать заданную ячейку в замороженном массиве строк."
    one_is_one:
      title: "1 это 1 … и даже более того должно быть!"
      description: "Изменение Fixnum до нового значения возвращает новый объект. Они не могут быть изменены по месту! Так что, вы не можете модифицировать замороженный массив чисел. (Fixnums и Integers не имеют bang-методов, что бы попытаться это продемонстрировать). Кстати: Fixnum <span class=\"code-inline\">object_id</span> - это <span class=\"code-inline\">value * 2 + 1</span>"
    bang:
      title: "(to! || ! to!) == ?"
      description: "Восклицательный знак (Метка Bang) у метода обозначает, что он опасен. Почему? Часто может изменить получателя этого метода, по сравнению с не изменяющей версией без восклицательного знака. НЕ ПОЛАГАЙТЕСЬ НА ТО, ЧТО ОНИ ВЕРНУТ ТОЖЕ САМОЕ, ЧТО И ВЕРСИЯ БЕЗ ВОСКЛИЦАТЕЛЬНОГО ЗНАКА! Многие возвращают nil, если нет необходимости в изменении!"
    array:
      title: "Массив новых находок"
      description: "Значение по умолчанию, заданное как объект, является одним и тем же объектом для каждого слота! Мутирование одного мутирует значение по умолчанию для всех. Начальное значение, заданное как блок, оценивается отдельно для каждого слота. Используйте это, чтобы создать новые переменные для каждого."
    hash:
      title: "Сделайте хеш из этого"
      description: "В основном та же проблема (и решение), что и массивы. Больше находок: создает новый объект при доступе к пустому слоту! Может создать чрезмерное количество новых объектов; это портит проверку \"реального\" содержимого или количеств (nil-checking, .size, итд)."
    rescue:
      title: "Спаси Меня, Выброси Строку, Я попробую перехватить это!"
      description: "В Ruby, throw и catch - НЕ для исключений! Они для продвинутого управления выполнением, для выхода из глубокой вложенности. Ruby использует raise и rescue для исключений."
    to_str:
      title: "to_s против to_str"
      description: "<span class=\"code-inline\">to_s</span> определяется на каждом объекте и всегда будет что-то возвращать. <span class=\"code-inline\">to_str</span> определяется только для объектов, которые похожи на строки. Например, <span class=\"code-inline\">Symbol</span> имеет <span class=\"code-inline\">to_str</span>, но <span class=\"code-inline\">Array</span> - нет. Таким образом, вы можете использовать <span class=\"code-inline\">obj.respond_to?(:to_str)</span> вместо чего-то такого <span class=\"code-inline\">obj.is_a?(String)</span>, если вы хотите воспользоваться преимуществами duck типизации, не волнуясь о том, является ли класс, с которым вы работаете, подклассом <span class=\"code-inline\">String</span> или нет."
    missing:
      title: "Необходимость координации method_missing и respond_to_missing?"
      description: "Когда переопределяете <span class=\"code-inline\">method_missing</span>, не забывайте также переопределить <span class=\"code-inline\">respond_to_missing?</span>. Когда вы используете method_missing, для того что бы объект возвращал что-либо при вызове метода, всегда удостоверяйтесь, что вы также переопределили respond_to_missing?. Если вы этого не сделаете, с первого взгляда кажется, что ничего не сломается, но со временем вы столкнетесь с проблемами. Рассмотрим этот класс:"
      respond_to: "Большое количество кода (в гемах или вашего собственного) полагается на respond_to? (вполне оправданно). Нужно ли вам поменять respond_to_missing? также:"
    exception:
      title: "Cпасайте от StandardError, а не от Exception"
      description: "Не перехватывайте Exception, сперва перехватите StandardError. Явный перехват Exception также перехватит ошибки, которые в обычных условиях невозможно исправить, такие как SyntaxError, LoadError и Interrupt. Если вы опустите тип Exception, то Ruby будет перехватывать только StandardError, что, вероятнее всего, вы и хотите:"
    private:
      title: "Не совсем приватные данные, и совсем не приватные методы класса"
      description: "Есть способ сделать методы класса частными в Ruby, вы просто должны выполнить все условия. Эм, Я имею в виду, используйте <span class=\"code-inline\">class << self</span>. Эта странность проталкивает экземпляр синглтона в класс, эффективно создавая методы класса.."
    braces:
      title: "Фигурные скобки против do-end"
      description: "По общей конвенции используйте <span class=\"code-inline\">do .. end</span> для многострочных блоков, и фигурные скобки для однострочных блоков, но здесь также присутствует разница между ними, которая может быть продемонстрирована. Это означает, что <span class=\"code-inline\">{}</span> имеют более высокий приоритет чем <span class=\"code-inline\">do .. end</span>, так что держите это в уме, когда решаете, что вы хотите использовать."
    module:
      title: "Класс Foo::Bar, определенный снаружи модуля Foo, не видит внутренностей Foo"
      description: "Вы можете рассматривать каждый из <span class=\"code-inline\">module Something</span>, <span class=\"code-inline\">class Something</span> или <span class=\"code-inline\">def something</span> как \"вход\" в новое окружение. Когда Ruby ищет определение имени, на которое была ссылка, он сначала ищет в текущем окружении (метод, класс или модуль), и если оно не найдено, то он пойдет назад через каждый внешний \"вход\", и будет искать в окружении там."
    credits: "Код и статьи были взяты из ресурсов:"
  meta_programming:
    title: "Метапрограммирование"
    description: "Метапрограммирование - это запись компьютерных программ, которые пишут или управляют другими программами (или самими собой) в качестве их данных или выполняют часть работы во время компиляции, которая в противном случае была бы выполнена во время выполнения. Во многих случаях это позволяет программистам делать больше за такое же количество времени, сколько потребуется, чтобы написать весь код вручную или предоставить программам большую гибкость для эффективного управления новыми ситуациями без перекомпиляции. Метапрограммирование - это код, который пишет код во время выполнения, чтобы сделать вашу жизнь проще."
    dynamic_dispatch:
      title: "Динамическая отправка"
      description: "Позволяет отправлять сообщения <span class=\"code-inline\">subject.public_send(message, *arguments)</span>"
    dynamic_method:
      title: "Динамический метод"
      description: "Позволяет динамически создавать методы <span class=\"code-inline\">define_method :method_name { block that becomes method body }</span>"
    ghost_methods:
      title: "Призрачные методы"
      description: "Catching \"Ghost Methods\" and forwarding them onto another method Whilst possibly adding logic around the call. Utilises <span class=\"code-inline\">method_missing</span>"
    dynamic_proxies:
      title: "Динамические прокси"
      description: "Например, Вы можете предоставить воображаемые методы, используя <span class=\"code-inline\">method_missing</span>, что бы распознать входящее сообщение (например <span class=\"code-inline\">get_name</span>, <span class=\"code-inline\">get_age</span>) и делегировать другому методу, такому как <span class=\"code-inline\">get(:data_type)</span> где <span class=\"code-inline\">:data_type</span> это <span class=\"code-inline\">:name</span> или <span class=\"code-inline\">:age</span>."
      more: "Если (после анализа) Вы обнаружите проблему с производительностью при использовании <span class=\"code-inline\">method_missing</span> Вы можете применить технику \"Динамического метода\", что бы создать реальный метод после того, как сообщение было получено в `method_missing` в первый раз.."
  solid_principles:
    good: "Хорошо!"
    bad: "Плохо!"
    title: "Solid принципы"
    description: "В информатике, SOLID (single responsibility, Open-closed, Liskov substitution, interface segregation, and dependency inversion) является мнемоническим акронимом, введенным Майклом Персоном для «первых пяти принципов», названного Робертом К. Мартином в начале 2000-х годов, что соответствует пяти основным принципам объектно-ориентированного программирования и дизайна. Цель состоит в том, что эти принципы, когда они применяются вместе, сделают более вероятным, что программист создаст систему, которую легко поддерживать и продлевать с течением времени. Принципы SOLID - это рекомендации, которые могут применяться при работе с программным обеспечением для удаления запахов кода, заставляя программиста реорганизовать исходный код программного обеспечения, пока он не будет разборчивым и расширяемым. Он является частью общей стратегии гибкого и адаптивного программного обеспечения."
    single:
      title: "Принцип единственности ответственности"
      description: "Принцип единственности ответственности является наиболее абстрактным из группы. Принцип помогает сохранять классы и методы небольшими и поддерживаемыми. В дополнение к тому, что классы невелики и сосредоточены, они также упрощают их понимание. Примером этого может быть добавление поддержки для отправки сводки электронной почты комиссий конкретного человека после маркировки обработанной сделки. Тот факт, что мы можем идентифицировать несколько причин для изменения сигналов, является нарушением принципа единой ответственности."
    open_close:
      title: "Принцип открытости/закрытости"
      description: "Принцип открытости/закрытости утверждает, что классы или методы должны быть открыты для расширения, но закрыты для модификации. Это говорит нам, что мы должны стремиться к модульным конструкциям, которые позволяют нам изменять поведение системы без внесения изменений в сами классы. Обычно это достигается за счет использования шаблонов, таких как шаблон стратегия."
      after: "Благодаря этому рефакторингу мы добавили новые синтаксические анализаторы без изменения кода. Любое дополнительное поведение потребует добавления нового обработчика. Это делает наш парсер файлов многоразовым и во многих случаях будет держать нас в соответствии с принципом единой ответственности, а также поощрять нас создавать более мелкие более целенаправленные классы."
    liskov:
      title: "Принцип подстановки Лисков"
      description: "Принцип подстановки Лисков, как правило, самый трудный для понимания. Принцип гласит, что вы можете заменить любые экземпляры родительского класса экземпляром одного из его дочерних элементов без каких-либо неожиданных или неправильных действий."
    segregation:
      title: "Принцип разделения интерфейса"
      description: "Принцип гласит, что клиент не должен зависеть от методов, которые он не использует. В этом примере есть классы компьютеров, программистов и техников. Оба программиста и техника используют компьютер по-другому. Программист использует компьютер для ввода текста, но техник знает, как сменить жесткий диск компьютера. Принцип разделения интерфейса (ISP) предусматривает, что один класс не должен зависеть от методов, которые он не использует. В нашем случае программист необязательно связан с методом Computer # change_hard_drive, потому что он его не использует, но состояние, которое этот метод обеспечивает, может повлиять на программиста. Давайте реорганизуем код, чтобы подчиняться LSP."
      after: "После этого рефактора Technician использует другой объект из типа ComputerInternals, который изолирован от состояния компьютера. На состояние объекта Computer может влиять программист, но изменения не повлияют на Техника каким-либо образом."
    di:
      title: "Принцип инверсии зависимостей"
      description: "Принцип инверсии зависимостей связан с объектами высокого уровня (думать бизнес-логики), не зависящими от деталей реализации низкоуровневых запросов и запросов ввода-вывода. Это может быть достигнуто с помощью утиной печати и принципа инверсии зависимостей. Часто этот шаблон используется для достижения принципа открытости/закрытости, о котором мы говорили выше. Фактически, мы можем даже повторить тот же пример, что и демонстрация этого принципа. Теперь есть класс форматирования, но я его жестко закодировал в классе Report, создав таким образом зависимость от отчета к JSONFormatter. Поскольку отчет является более абстрактной (высокоуровневой) концепцией, чем JSONFormatter, мы эффективно нарушение DIP."
      after: "Таким образом, отчет не зависит от JSONFormatter и может использовать любой тип форматирования, который имеет метод, называемый format (это называется утиным типом). Еще одно замечание заключается в том, что мы снова использовали инъекцию зависимостей для решения проблемы. Этот метод является очень мощным, когда наша цель заключается в развязывании объектов, и хотя он имеет те же инициалы, что и принцип инверсии зависимостей (vs зависимость от инъекций), это совершенно разные понятия."
  threads:
    example: "Пример"
    title: "Потоки"
    description: "Замечание о параллелизме и конкуренции: основное отличие между процессами и потоками заключается в том, как обрабатывается память. На высоком уровне процессы копируют память, а потоки обмениваются памятью. Это заставляет процесс нереститься медленнее, чем размножение нити, и приводит к тому, что процессы запускают больше ресурсов. В целом, потоки несут меньше затрат, чем процессы. Этот API-интерфейс является API-интерфейсом Ruby. Различные реализации Ruby имеют разные основные потоковые поведения."
    green:
      title: "Зелёные потоки"
      description: "Актуально в Ruby до версии 1.9. Это потоки выполнения, управление которыми вместо операционной системы выполняет виртуальная машина (ВМ). Зелёные потоки эмулируют многопоточную среду, не полагаясь на возможности ОС по реализации легковесных потоков. Управление ими происходит в пользовательском пространстве, а не пространстве ядра, что позволяет им работать в условиях отсутствия поддержки встроенных потоков.."
    gil:
      title: "GIL - глобальная блокировка интерпретатора."
      description: "MRI содержит глобальную блокировку интерпретатора (GIL). Это означает, что в многопоточном контексте только один поток может выполнять Ruby-код в любой момент времени. Поэтому, если у вас есть 8 потоков, работающих на 8-ядерном компьютере, только один поток и одно ядро будут заняты в любой момент времени. GIL существует для защиты внутренних компонентов Ruby от состояний гонки, которые могут испортить данные. Тут есть оговорки и оптимизации, но это основная суть."
      example: "Этот простой факт - это то, что делает потоки настолько мощными, а также то, что затрудняет их работу. Я уже дал вам представление о том, почему потоки хороши, вот простая программа, иллюстрирующая их трудность. Здесь вы можете видеть, что у нас есть <span class=\"code-inline\">10 * 10000</span> \"элементов в массиве\". Обратите внимание, что разные интерпретаторы Ruby могут показать различный результат. GIL существует только в MRI ruby."
    mutex:
      title: "Мьютекс - взаимное исключение"
      description: "Мьютексы предоставляют механизм для синхронизации доступа нескольких потоков к критической части кода. Другими словами, они помогают привнести некоторый порядок и некоторую стабильность в мир многопоточного хаоса. Название \"Мьютекс\" - это сокарщение от \"mutual execution\" (пер. \"взаимное исполнение\"). Если вы обернете некоторую секцию вашего кода в мьютекс, Вы получите гарантию того, что два потока не получат доступа к этой секции одновременно. Мьютексы предоставляют механизм доступа нескольких потоков к критической части кода."
      example: "В этой программе, поскольку каждый поток должен заблокировать мьютекс прежде чем добавлять элемент в Массив, есть гарантия того, что два потока не будут выполнять эту операцию одновременно. Другими словами, эта операция не может больше быть прервана до ее завершения. Когда один поток начинает добавлять элемент в массив, ни один другой поток не будет иметь возможности, начать выполнять эту часть кода до тех пор, пока первые не закончил. Эта операция теперь является потокобезопасной. Здесь вы можете видеть, что мы имеем <span class=\"code-inline\">10 * 10000</span> элементов в массиве. Теперь все также, благодаря мьютексу. Мьютекс устанавливает те же ограничения на поток. Первы поток, который достигнет выполнения первого бита кода, заблокирует мьютекс. Он теперь являетс владельцем мьютекса. До тех пор пока владеющий поток не разблокирует мьютекс, ни один другой поток не может заблокировать его."
    fibers:
      title: "Фиберы"
      description: "Фиберы - это примитивы для реализации облегченного совместного параллелизма в Ruby. По сути они означают создание блоков кода, которые могут быть приостановлены и запущены, так же как и потоки. Основное отличие в том, что они никогда не выгружаются, и в том, что планирование выполнения должно быть выполнено программистом, а не ВМ. В отличии от других облегченных моделей параллельности, каждый фибер идет с небольшим стэком в 4Кб. Это позволяет приостановить фибер через вызов глубоко вложенных функций внутри блока фибера."
    rails:
      title: "Rails - потоковая безопасность в фреймворке."
      description: "Проблема заключается в том, что нет простого способа сказать с абсолютной уверенностью, соблюдает ли приложение в целом потоковую безопасность. "
      global_variables: "Глобальные переменные глобальны. Это означает, что они разделены между потоками. Если вы не были уверены в том, что не используете глобальные переменные к настоящему времени, вот еще одна причина не трогать их. Если вы действительно хотите поделиться чем-то глобально через приложение, вы, скорее всего, лучше используйте константу (но см. Ниже)."
      class_variables: "Переменные класса. В целях обсуждения потоков, переменные класса не сильно отличаются от глобальных переменных. Они одинаково распределяются между потоками. Проблема заключается не столько в использовании переменных класса, сколько в их мутировании. И если вы не собираетесь мутировать переменную класса, во многих случаях константа снова является лучшим выбором."
      instance_variables: "Переменные экземпляра класса. Но, возможно, вы прочитали, что всегда должны использовать переменные экземпляра класса вместо переменных класса в Ruby. Ну, может быть, вам следует, но они так же проблематичны для поточных программ, как переменные класса."
      memoization: "Мемоизация (запоминание, от англ. memoization (англ.) в программировании) — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ. Перед вызовом функции проверяется, вызывалась ли функция ранее:
        если не вызывалась, функция вызывается и результат её выполнения сохраняется;
        если вызывалась, используется сохранённый результат."
    config:
      title: "config.threadsafe!: что это делает?"
      description: "Вызов этого метода устанавливает 4 настройки в нашем приложении. Давайте пройдем через каждую настройку и поговорим о том, что она делает"
      frameworks: "Предзагрузка фреймворков: Первая настройка @preload_frameworks делает именно то, что можно понять из ее названия, она заставляет Rails фреймворк быть загруженным при старте. Когда эта настройка включена, классы фреймворка лениво загружаются с помощью автозагрузки. В многопоточных окружениях, фреймворк должен быть загружен до того, как созданы какие-либо потоки, по причине проблем с потокобезопасностью в автозагрузке. Мы знаем, что загрузка фреймворка не потокобезопасна, так что стратегия в том, что бы загрузить его полностью до того, как какие-либо потоки будут готовы для обработки запросов"
      cache: "Кэшированные классы: настройка @cache_classes управляет тем, будут или нет классы перезагружены. Помните, когда вы делаете \"TDD\" в вашем приложении? Вы модифицируете контроллер, затем перезагружаете страницу, чтобы \"протестировать\" ее, и видите изменения? Да, это именно то, что контролирует эта настройка. Когда эта настройка установлена в false, как в development окружении, ваши классы будут перезагружены при модификации. Без этой настройки, мы не имели бы возможности делать \"F5DD\" (да, это F5 driven development). В продакшене, мы знаем, что классы не будут модифицированы на лету, поэтому делать работу по определению, нужно или нет презагружать класс, является пустой тратой ресурсов, так что имеет смысл никогда не перезагружать определения классов."
      di: "Загрузка зависимостей: Эта настройка, @dependency_loading, контролирует загрузку кода, когда встречаются неопределенные константы. Например, контроллер ссылается на модель User, но константа User не определена. В этом случае, если @dependency_loading - true, Rails найдет файл который содержит константу User и загрузит его. Мы уже говорили о том, насколько потокобезопасна загрузка, так что идея тут в том, что мы должны загрузить фреймворк, затем загрузить весь пользовательский код, затем отключить загрузку зависимостей. Когда загрузка зависимостей отключена, код фреймворка и код приложения должны быть загружены, и любая неопределенная константа просто выбросит исключения вместо попытки загрузить код. Мы обосновываем отключение этой настройки в продакшене тем, что (как мы упоминали ранее) подгрузка кода не потокобезопасна, и мы ожидаем, что весь код будет загружен до того, как какие-либо потоки могут обработать запрос."
      concurrency: "Возможность параллельности: настройка @allow_concurrency контролирует использования Rack::Lock middleware в вашем стеке. Rack::Lock оборачивает ваш запрос в мьютекс. Идея этого в том, что если у вас есть не потокобезопасный код, этот мьютекс этот мьютекс не позволит нескольким потокам выполнить код вашего контроллера в одно и то же время. Когда threadsafe! установлено, это middleware отключено, и код контроллера может быть выполнен параллельно."
    credits: "Код и статьи были взяты из ресурсов:"
  ruby_meister:
    title: "Станьте специалистом в Руби"
    description: "В этом разговоре мы рассмотрим долгий путь от новичка до  мастера в Ruby и попытаемся немного его сократить, разделив важную информацию. Мастер имеет отличную теоретическую основу, опирается на обширный набор инструментов, имеет глубокое понимание основных ценностей и принципов Ruby и всегда оттачивает навыки. Возможно, вы говорите себе: «Ух ты, это довольно расплывчато!», но если вы посетите эту сессию, я обещаю, что вы будете просветлены и вам понравится! Звучит хорошо?"
    video: "Долгое путешествие к Ruby мастерству от Божидара Бацова."
    computer_science_fundamentals:
      title: "Основы информатики"
      articles:
        - name: "inside_machine"
          title: "Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture"
          description: "Компьютеры выполняют бесчисленное количество задач, начиная от критически важных для бизнеса и заканчивая рекреационными, но независимо от того, как иначе они могут выглядеть и вести себя, все они удивительно похожи по основной функции. Как только вы поймете, как работает микропроцессор или центральный процессор (CPU), вы получите четкое представление о фундаментальных концепциях, лежавших в основе всех современных вычислительных систем."
          link: "https://www.amazon.com/Inside-Machine-Introduction-Microprocessors-Architecture-ebook/dp/B004OEJO0A"
        - name: "code"
          title: "Code: The Hidden Language of Computer Hardware and Software"
          description: "Какое отношение имеют фонарики, британское вторжение, черные кошки и прозрачки к компьютерам? В CODE они показывают нам гениальные способы манипулирования языком и изобретать новые средства общения друг с другом. И через КОД мы видим, как эта изобретательность и наше человеческое принуждение к общению привели к технологическим инновациям последних двух столетий."
          link: "https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319"
        - name: "concrete_math"
          title: "Concrete Mathematics: A Foundation for Computer Science"
          description: "В этой книге представлена математика, поддерживающая расширенное компьютерное программирование и анализ алгоритмов. Основной целью известных авторов является обеспечение прочной и актуальной базы математических умений - навыков, необходимых для решения сложных задач, оценки ужасающих сумм и выявления тонких закономерностей в данных. Это незаменимый текст и ссылка не только для компьютерных ученых - авторы сами сильно полагаются на него! - но для серьезных пользователей математики практически в каждой дисциплине."
          link: "https://www.amazon.com/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025"
        - name: "sicp"
          title: "Structure and Interpretation of Computer Programs"
          description: "Структура и интерпретация компьютерных программ оказали огромное влияние на учебные программы в области компьютерных наук за последнее десятилетие. Эта долгожданная ревизия содержит изменения во всем тексте. В книге реализованы новые версии большинства основных программных систем, включая переводчиков и составителей, и авторы включили множество небольших изменений, которые отражают их опыт преподавания курса в Массачусетском технологическом институте с момента публикации первого издания. Введена новая тема, в которой подчеркивается центральная роль различных подходов к работе со временем в вычислительных моделях: объекты с состоянием, параллельное программирование, функциональное программирование и ленивая оценка, а также недетерминированное программирование."
          link: "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871"
        - name: "design_programms"
          title: "How to Design Programs: An Introduction to Programming and Computing"
          description: "Это введение в программирование ставит информатику в ядро либерального художественного образования. В отличие от других вводных книг, он фокусируется на процессе разработки программ. Такой подход способствует развитию различных навыков — критического чтения, аналитического мышления, творческого синтеза и внимания к деталям — которые важны для всех, а не только для будущих программистов. Книга знакомит читателей с двумя принципиально новыми идеями. Во-первых, в нем представлены рекомендации по проектированию программ, которые показывают читателю, как анализировать постановку задачи; как сформулировать краткие цели; как составить примеры; как разработать план решения на основе анализа; как завершить программу; и как протестировать."
          link: "https://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186"
        - name: "algorithm_manual"
          title: "The Algorithm Design Manual"
          description: "Это недавно расширенное и обновленное второе издание бестселлера классики продолжает вынимать “тайну” из проектирования алгоритмов и анализа их эффективности и эффективности. В дополнение к первому изданию книга в настоящее время служит основным учебником для курсов алгоритмов проектирования, сохраняя при этом свой статус главного практического руководства по алгоритмам для программистов, исследователей и студентов."
          link: "https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202"
        - name: "cormen"
          title: "Introduction to Algorithms, 3rd Edition (The MIT Press)"
          description: "Некоторые книги по алгоритмам являются строгими, но неполными; другие охватывают массу материала, но недостаточно строгими. Введение в алгоритмы уникально сочетает строгость и полноту. Книга охватывает широкий спектр алгоритмов в глубину, но делает их дизайн и анализ доступными для всех уровней читателей. Каждая глава является относительно автономной и может быть использована в качестве единицы исследования. Алгоритмы описаны на английском языке и в псевдокоде, предназначенным для чтения любым, кто сделал небольшое программирование. Объяснения были сохранены элементарно, не жертвуя глубиной охвата или математической строгость."
          link: "https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844"
        - name: "compilers"
          title: "Compilers: Principles, Techniques, and Tools (2nd Edition)"
          description: "Компиляторы: принципы, методы и инструменты, известные профессорам, студентам и разработчикам во всем мире как “Книга драконов”, выпускается в новом издании. Каждая глава была полностью пересмотрена, чтобы отразить разработки программного обеспечения, языков программирования и компьютерной архитектуры, которые произошли с 1986 года, когда было опубликовано последнее издание. Авторы, признавая, что немногие читатели когда-либо будут продолжать строить компилятор, сохраняют свое внимание на более широком наборе проблем, возникающих при разработке программного обеспечения и разработке программного обеспечения."
          link: "https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811"
        - name: "c_lang"
          title: "C Programming Language, 2nd Edition"
          description: "Авторы представляют полное руководство по программированию языка языка ANSI. Написанная разработчиками C, эта новая версия помогает читателям идти в ногу с завершенным стандартом ANSI для C, показывая, как воспользоваться богатым набором операторов C, экономией выражения, улучшенным потоком управления и структурами данных. 2/E был полностью переписан с дополнительными примерами и наборами проблем, чтобы уточнить реализацию сложных языковых конструкций. В течение многих лет программисты C позволяли K & R направлять их на создание хорошо структурированных и эффективных программ. Теперь эта же справка доступна тем, кто работает с компиляторами ANSI. Содержит подробное описание языка C, а также официальное справочное руководство по языку C для краткой справки по синтаксису, объявлениям, изменениям ANSI, правилам области, а также список продолжается и продолжается."
          link: "https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628"
    oop:
      title: "Объектно-ориентированное программирование"
      articles:
        - name: "growing"
          title: "Growing Object-Oriented Software, Guided by Tests"
          description: "Тест-драйв разработки (TDD) в настоящее время является признанным методом для более быстрого предоставления лучшего программного обеспечения. TDD основан на простой идее: напишите тесты для вашего кода, прежде чем написать сам код. Однако эта “простая” идея требует умения и суждения, чтобы преуспеть. Теперь есть практическое руководство по TDD, которое выводит вас за рамки основных концепций. Основываясь на десятилетнем опыте создания реальных систем, два пионера TDD показывают, как позволить тестам направлять вашу разработку и “расти” программное обеспечение, которое является согласованным, надежным и поддерживаемым."
          link: "https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627"
        - name: "domain_driven"
          title: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
          description: "Это серьезная книга о предметном моделировании в разработке программного обеспечения. Общество разработки программного обеспечения живет от одной волны шумихи к другой. ООП, шаблоны, XP, TDD, CI/CD, BigData, DevOps - это всего лишь несколько. Эта книга возникла из золотого века ООП. Автор признает, что объектно-ориентированная парадигма не является единственной доступной, но склонность к ООП/ООД очевидна (и оправдана). В этой книге рассказывается о том, как сделать моделирование основных программных компонентов “правильным путем”."
          link: "https://www.amazon.com/Domain-Driven-Tacking-Complexity-Software/dp/8131724468/ref=sr_1_fkmr1_2?s=books&ie=UTF8&qid=1542577469&sr=1-2-fkmr1&keywords=Domain-Driven+Design%3A+Tackling+Complexity+in+the+Heart+of+Software"
    ruby:
      title: "Знай свой язык"
      articles:
        - name: "well_grounded"
          title: "The Well-Grounded Rubyist"
          description: "The Well-Grounded Rubyist, Second Edition адресован как новичкам Ruby, так и программистам Ruby, которые хотят углубить свое понимание языка. Это красиво написанное и полностью пересмотренное второе издание включает в себя охват новых функций в Ruby 2.1, а также расширенное и обновленное освещение аспектов языка, которые изменились."
          link: "https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692"
        - name: "programming_ruby"
          title: "Programming Ruby: The Pragmatic Programmers' Guide, Second Edition"
          description: "Ruby является все более популярным, полностью объектно-ориентированным динамическим языком программирования, который многие практикующие считают лучшим и самым полезным языком, доступным сегодня. Когда Руби впервые ворвался на сцену в западном мире, прагматические программисты были там с окончательным справочным руководством, Programming Ruby: The Pragmatic Programmer's Guide."
          link: "https://www.amazon.com/Programming-Ruby-Pragmatic-Programmers-Second/dp/0974514055"
        - name: "ruby_programming"
          title: "The Ruby Programming Language: Everything You Need to Know"
          description: "Эта книга начинается с краткого руководства по языку, а затем подробно объясняет язык снизу вверх: от лексической и синтаксической структуры до типов данных, выражений и выражений и далее через методы, блоки, лямбды, замыкания, классы и модули. Книга также включает в себя длинное и подробное введение в богатый API платформы Ruby, демонстрируя - с тяжелыми комментариями пример кода - возможности Ruby для обработки текста, числовых манипуляций, коллекций, ввода-вывода, сетей и параллелизма. Целая глава посвящена возможностям метапрограммирования Ruby."
          link: "https://www.amazon.com/Ruby-Programming-Language-Everything-Need/dp/0596516177"
  interview_questions:
    title: "Вопросы на интервью"
    description: "Эта секция содержит ссылки на ресурсы для чтения и подготовки к собеседованию."
    list:
      - name: "Toptal: Как нанять великого разработчика Ruby"
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: "Toptal: 21 Основные вопросы интервью Ruby"
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: "Hookops: 35 + Ruby и Rails Интервью Вопросы и ответы"
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: "Educba: 15 наиболее важных вопросов и ответов на интервью Ruby"
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: "Ruby Garage: Как Интервью с разработчиком Ruby on Rails"
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: "RyanSobol: 15 вопросов, которые нужно задать во время интервью Ruby"
        link: "https://gist.github.com/ryansobol/5252653"
      - name: "Toptal: 9 Основные вопросы для интервью Ruby on Rails"
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: "Что такое Better Docs"
    description: "Это сайт является веб адаптацией Github репозитория <a href=\"https://github.com/khusnetdinov/ruby.fundamental\">Ruby.Fundamental</a>, который собрал множество звезд и был переведен на Японский язык. Better Docs позволяет вам быстро найти большое количество лучших практик, собранных в одном репозитории. Просто используйте это репозиторий как справку или ресурс для подготовки к собеседованию."
    oss:
      title: "Спасибо Open Source"
      description: "Better Docs появился в процессе работы и поиска информации о лучших практиках и знаниях о Ruby, изучая проекты с открытым исходным кодом для разработки веб приложений, написанных на Ruby."
      thanks: "Если Better Docs помог вам чем-либо, подумайте о том, что бы дать нам звезду на <a href=\"https://github.com/howtohireme/ruby.fundamental\">Github</a> (это поможет найти нас большему количеству разработчиков) или внести свой вклад в наши проекты."
