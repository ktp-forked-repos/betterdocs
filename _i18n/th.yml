head:
  title: BetterDocs
  metatags:
    description: การเขียนโปรแกรมพื้นฐานพร้อมตัวอย่างทับทิมและการอ้างอิง ครอบคลุมหัวข้อ,
      หลักการ SOLID, รูปแบบการออกแบบ, โครงสร้างข้อมูล, อัลกอริทึม
    keywords: เอกสารที่ดีกว่า, Ruby, พื้นฐาน, Ruby พื้นฐานการเขียนโปรแกรม Ruby gotchas,
      การโปรแกรมเชิงฟังก์ชัน, Metaprogramming, เธรด, หลักการที่เป็นของแข็งของทับทิมพร้อมกับตัวอย่าง,
      รูปแบบการออกแบบ Ruby พร้อมตัวอย่าง, อัลกอริทึม Ruby พร้อมตัวอย่าง, โครงสร้างข้อมูล
      Ruby พร้อมตัวอย่าง

content:
  menu:
    open: เปิดเมนู
    close: ปิดเมนู

sidebar:
  - title: อัลกอริทึม
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: โครงสร้างข้อมูล
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: รูปแบบการออกแบบ
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: ฟังก์ชั่นการเขียนโปรแกรม
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: คำถามสัมภาษณ์
    url: interview_questions
  - title: การเขียนโปรแกรม Meta
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: หลักการที่มั่นคง
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: กลายเป็น Ruby Meister
    url: ruby_meister
  - title: หัวข้อ
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config
pages:
  wiki: อ่านวิกิ
  credits: เครดิต
  page404:
    title: ไม่พบหน้านี้ :(
    description: ไม่พบหน้าที่ร้องขอ
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: อัลกอริทึม
    complexity:
      best: ดีที่สุด
      average: เฉลี่ย
      worst: แย่ที่สุด
    sorting:
      title: การเรียงลำดับ
      description: อัลกอริทึมการเรียงลำดับเป็นอัลกอริทึมที่ทำให้องค์ประกอบของรายการในลำดับที่แน่นอน
        คำสั่งที่ใช้มากที่สุดคือคำสั่งตัวเลขและคำศัพท์ การจัดเรียงที่มีประสิทธิภาพเป็นสิ่งสำคัญสำหรับการเพิ่มประสิทธิภาพการใช้อัลกอริทึมอื่น
        ๆ (เช่นอัลกอริธึมการค้นหาและผสาน) ซึ่งต้องการข้อมูลอินพุตในรายการที่เรียง มันก็มักจะมีประโยชน์สำหรับข้อมูล
        canonicalizing และการผลิตเอาท์พุทที่มนุษย์สามารถอ่านได้
      bubble_sort:
        title: เรียงลำดับฟอง
        description: การเรียงลำดับฟองมีคุณสมบัติหลายอย่างเหมือนกับการเรียงลำดับการแทรก
          แต่มีค่าใช้จ่ายสูงกว่าเล็กน้อย ในกรณีของข้อมูลที่เรียงลำดับแล้วการเรียงลำดับของฟองจะใช้
          <span class="code-inline time">O(n)</span> แต่ต้องการอย่างน้อย 2 ผ่านข้อมูล
      insertion_sort:
        title: เรียงลำดับการแทรก
        description: แม้ว่ามันจะเป็นหนึ่งในอัลกอริธึมการเรียงลำดับขั้นต้นที่มีเวลากรณีเลวร้ายที่สุด
          <span class="code-inline">O(n<sup>2</sup>)</span> การ เรียงลำดับการแทรกเป็นอัลกอริทึมของตัวเลือกเมื่อข้อมูลเกือบเรียงลำดับ
          มีค่าใช้จ่ายต่ำ) ด้วยเหตุผลเหล่านี้และเนื่องจากมีความเสถียรการเรียงลำดับการแทรกจึงมักถูกใช้เป็นกรณีพื้นฐานแบบเรียกซ้ำ
          (เมื่อขนาดของปัญหาเล็ก) สำหรับอัลกอริทึมการเรียงลำดับการแบ่งและพิชิตที่สูงขึ้นเช่นการเรียงแบบผสานหรือการเรียงแบบรวดเร็ว
      selection_sort:
        title: เรียงลำดับการเลือก
        description: จากการเปรียบเทียบที่นำเสนอในที่นี้อาจสรุปได้ว่าไม่ควรใช้การเรียงลำดับการเลือก
          มันไม่ได้ปรับให้เข้ากับข้อมูลในทางใดทางหนึ่ง (สังเกตว่าภาพเคลื่อนไหวสี่ภาพด้านบนทำงานในระบบล็อค)
          ดังนั้นเวลารันไทม์ของมันจึงเป็นกำลังสอง อย่างไรก็ตามการเรียงลำดับการเลือกมีคุณสมบัติในการลดจำนวนของการแลกเปลี่ยน
          ในแอปพลิเคชันที่มีค่าใช้จ่ายในการแลกเปลี่ยนไอเท็มสูงการเรียงลำดับตัวเลือกที่ดีอาจเป็นอัลกอริทึมของตัวเลือก
      shell_sort:
        title: เรียงเปลือก
        description: ความซับซ้อนของเวลาที่เลวร้ายที่สุดของการเรียงลำดับเชลล์ขึ้นอยู่กับลำดับการเพิ่ม
          สำหรับการเพิ่มทีละ 1 4 13 40 121 ... ซึ่งเป็นสิ่งที่จะใช้ที่นี่ซับซ้อนเวลาเป็น
          <span class="code-inline">O(n<sup><sup>3</sup>/<sub>2</sub></sup></span>)
          สำหรับการเพิ่มขึ้นอื่น ๆ เวลาซับซ้อนเป็นที่รู้จักกัน <span class="code-inline">O(n<sup><sup>4</sup>/<sub>3</sub></sup>)</span>
          และแม้กระทั่ง <span class="code-inline">O(n·lg<sub>2</sub>(n))</span>
          ไม่ทราบขอบเขตที่แน่นบนความซับซ้อนของเวลาและลำดับการเพิ่มที่ดีที่สุดไม่เป็นที่รู้จัก
          เนื่องจากการเรียงลำดับของเชลล์จะขึ้นอยู่กับการเรียงลำดับการเรียงเปลือกจึงเป็นการสืบทอดคุณสมบัติการเรียงลำดับการแทรกของสืบทอด
          การปรับตัวนั้นไม่น่าทึ่งนักเนื่องจากการเรียงของเชลล์ต้องการการส่งข้อมูลหนึ่งครั้งสำหรับการเพิ่มแต่ละครั้ง
          แต่มันก็มีความสำคัญ สำหรับลำดับการเพิ่มที่แสดงด้านบนมีการเพิ่มขึ้นของ <span
          class="code-inline">log<sub>3</sub>(n)</span> ดังนั้นความซับซ้อนของเวลาสำหรับข้อมูลที่เรียงลำดับเกือบจะคือ
          <span class="code-inline">O(n·log<sub>3</sub>(n))</span> เนื่องจากค่าใช้จ่ายต่ำ,
          การใช้งานที่ค่อนข้างง่าย, คุณสมบัติการปรับตัว, และความซับซ้อนของเวลาย่อย -
          การเรียงลำดับ, การเรียงลำดับของเชลล์อาจเป็นทางเลือกที่มีประสิทธิภาพในการเรียงลำดับอัลกอริธึม
          <span class="code-inline">O(n·lg(n))</span> ไม่ใหญ่มาก
      heap_sort:
        title: เรียงลำดับกอง
        description: เรียงลำดับกอง นั้นง่ายต่อการนำไปใช้, ทำการเรียงลำดับ <span class="code-inline">O
          (n · lg (n))</span> , แต่ไม่เสถียร ลูปแรกเฟส <span class="code-inline">n (n)</span>
          “ heapify” ใส่อาเรย์ลงในลำดับฮีพ ลูปที่สองเฟส <span class="code-inline">O
          (n · lg (n))</span> “ sort down” จะแยกค่าสูงสุดและกู้คืนลำดับฮีปซ้ำ ๆ ฟังก์ชัน
          sink ถูกเขียนซ้ำเพื่อความชัดเจน ดังนั้นตามที่แสดงรหัสต้องการพื้นที่ <span
          class="code-inline">Θ (lg (n))</span> สำหรับสแต็กการโทรซ้ำ อย่างไรก็ตามการวนรอบหางซ้ำในอ่างล้างจาน
          () นั้นง่ายต่อการแปลงเป็นการวนซ้ำซึ่งให้พื้นที่ <span class="code-inline">O
          (1)</span> ถูกผูกไว้ ทั้งสองขั้นตอนมีการปรับตัวเล็กน้อย แต่ก็ไม่ได้มีประโยชน์อย่างยิ่ง
          ในกรณีที่เกือบเรียงลำดับเฟสฮีพพิตจะทำลายคำสั่งเดิม ในกรณีที่กลับด้านเฟส heapify
          นั้นเร็วที่สุดเนื่องจากอาร์เรย์เริ่มต้นตามลำดับฮีพ แต่จากนั้นเฟสการเรียงลำดับจะเป็นเรื่องปกติ
          ในกรณีที่มีคีย์เฉพาะไม่กี่ตัวมีการเพิ่มความเร็ว แต่ไม่มากเท่าในการจัดเรียงเชลล์หรือ
          จัดเรียงอย่างรวดเร็ว แบบ 3 ทาง
      merge_sort:
        title: เรียงลำดับการผสาน
        description: 'การเรียงลำดับการผสานนั้นสามารถคาดเดาได้มาก มันทำการเปรียบเทียบระหว่าง
          <span class="code-inline">0.5lg(n)</span> และ <span class="code-inline">lg
          (n)</span> เปรียบเทียบต่อองค์ประกอบและระหว่าง <span class="code-inline">lg
          (n)</span> และ <span class="code-inline">1.5lg(n)</span> swaps ต่อองค์ประกอบ
          Minima สามารถทำได้สำหรับข้อมูลที่เรียงลำดับแล้ว; ค่าสูงสุดนั้นสามารถทำได้โดยเฉลี่ยสำหรับการสุ่มข้อมูล
          หากใช้พื้นที่พิเศษ <span class="code-inline">Θ(n)</span> ไม่ต้องกังวลการผสานการจัดเรียงเป็นตัวเลือกที่ยอดเยี่ยม:
          มันง่ายในการติดตั้งและเป็นอัลกอริทึมการเรียงลำดับ <span class="code-inline">O
          (n·lg(n))</span>ที่ เสถียรเท่านั้น โปรดทราบว่าเมื่อเรียงลำดับรายการที่เชื่อมโยงการเรียงแบบผสานต้องใช้พื้นที่พิเศษ
          <span class="code-inline">Θ(lg(n)</span> พิเศษเท่านั้น (สำหรับการเรียกซ้ำ)
          การเรียงลำดับผสานเป็นอัลกอริทึมของตัวเลือกสำหรับสถานการณ์ที่หลากหลาย: เมื่อต้องการความเสถียรเมื่อเรียงลำดับรายการที่เชื่อมโยง
          การเข้าถึงมีราคาแพงกว่าการเข้าถึงตามลำดับ (ตัวอย่างเช่นการเรียงลำดับภายนอกบนเทป)
          มีอัลกอริธึมการผสานเวลาเชิงเส้นอยู่ในสถานที่สำหรับขั้นตอนสุดท้ายของอัลกอริทึม
          แต่ทั้งสองมีราคาแพงและซับซ้อน เช่นการจัดเรียงภายนอกเมื่อ extra <span class="code-inline">Θ(n)</span>
          พื้นที่พิเศษไม่สามารถใช้ได้'
      quick_sort:
        title: จัดเรียงอย่างรวดเร็ว
        description: เมื่อนำมาใช้อย่างระมัดระวัง, จัดเรียงอย่างรวดเร็ว มีความแข็งแกร่งและมีค่าใช้จ่ายต่ำ
          เมื่อไม่ต้องการการจัดเรียงที่มีความเสถียร quicksort เป็นตัวจัดเรียงวัตถุประสงค์ทั่วไปที่ยอดเยี่ยม
          - แม้ว่าควรใช้เวอร์ชันการแบ่งพาร์ติชันแบบ 3 ทางแทน โค้ดการแบ่งพาร์ติชันแบบสองทิศทางที่แสดงด้านบนเขียนขึ้นเพื่อความชัดเจนมากกว่าประสิทธิภาพที่ดีที่สุด
          มันแสดงให้เห็นถึงสถานที่ที่ไม่ดีและในช่วงวิกฤตจะแสดงเวลา <span class="code-inline">O
          (n <sup>2</sup> )</span> เมื่อมีคีย์เฉพาะไม่กี่ตัว วิธีการแบ่งพาร์ติชันแบบสองทางที่มีประสิทธิภาพและมีประสิทธิภาพมากขึ้นจะได้รับใน
          Quicksort นั้นเหมาะสมที่สุดโดย Robert Sedgewick และ Jon Bentley การแบ่งพาร์ติชันที่แข็งแกร่งสร้างการเรียกซ้ำแบบสมดุลเมื่อมีค่าจำนวนมากเท่ากับ
          pivot ซึ่งรับประกันความน่าจะเป็นของเวลา <span class="code-inline">O (n · lg
          (n))</span> และพื้นที่ <span class="code-inline">O (lg (n))</span> สำหรับอินพุตทั้งหมด
          ด้วยการเรียงลำดับย่อยทั้งสองที่ดำเนินการแบบเรียกซ้ำการเรียงลำดับด่วนต้องใช้พื้นที่พิเศษ
          <span class="code-inline">O (n)</span> สำหรับกองการเรียกซ้ำในกรณีที่เลวร้ายที่สุดเมื่อการเรียกซ้ำไม่สมดุลกัน
          สิ่งนี้ไม่น่าจะเกิดขึ้นได้มากนัก แต่สามารถหลีกเลี่ยงได้โดยการเรียงลำดับย่อยย่อยที่เล็กกว่าซ้ำก่อน
          การเรียงลำดับย่อยที่สองคือการเรียกซ้ำแบบหางซึ่งอาจทำได้ด้วยการวนซ้ำแทน ด้วยการปรับให้เหมาะสมนี้อัลกอริทึมใช้พื้นที่พิเศษ
          <span class="code-inline">O (lg (n))</span> ในกรณีที่แย่ที่สุด
      other: ขั้นตอนวิธีการเรียงลำดับอื่น ๆ
      additional: อ่านเพิ่มเติม
    searching:
      title: ค้นหา
      binary_search:
        title: ค้นหาแบบทวิภาค
        description: ในวิทยาการคอมพิวเตอร์การค้นหาแบบไบนารี่หรือที่รู้จักกันในชื่อการค้นหาครึ่งช่วงหรือการค้นหาแบบลอการิทึมเป็นอัลกอริธึมการค้นหาที่ค้นหาตำแหน่งของค่าเป้าหมายภายในอาร์เรย์ที่เรียงลำดับ
          มันเปรียบเทียบค่าเป้าหมายกับองค์ประกอบกลางของอาร์เรย์ หากพวกเขาไม่เท่ากันครึ่งที่เป้าหมายไม่สามารถกำจัดได้จะถูกกำจัดและการค้นหาจะดำเนินต่อไปในครึ่งที่เหลือจนกว่าจะประสบความสำเร็จ
      knuth_moriss_pratt_search:
        title: ค้นหา Knuth-Morris-Pratt
        description: ในวิทยาการคอมพิวเตอร์ Knuth – Morris – Pratt string algorithm (หรืออัลกอริทึม
          KMP) ค้นหาการเกิดขึ้นของ &quot;คำ&quot; W ภายในหลัก &quot;สตริงข้อความ&quot;
          S โดยการใช้การสังเกตว่าเมื่อเกิดความไม่ตรงกัน ข้อมูลเพื่อพิจารณาว่าการแข่งขันครั้งต่อไปอาจเริ่มต้นขึ้นได้อย่างไรจึงข้ามการตรวจสอบอักขระที่ตรงกันก่อนหน้านี้อีกครั้ง
      other:
        title: อัลกอริธึมการค้นหาอื่น ๆ
        dijkstra: อัลกอริทึมของ Dijkstra
        kruskal: อัลกอริทึมของ Kruskal
        longest: การเรียงลำดับที่เพิ่มขึ้นที่ยาวที่สุด
        telephone_number: หมายเลขโทรศัพท์เป็นคำพูด
    credits: 'รหัสและบทความถูกนำมาจากแหล่งข้อมูล:'
  data_structures:
    title: โครงสร้างข้อมูล
    description: ในวิทยาการคอมพิวเตอร์สัญกรณ์ O ใหญ่จะใช้ในการจำแนกอัลกอริทึมโดยวิธีที่พวกเขาตอบสนองต่อการเปลี่ยนแปลงขนาดอินพุตเช่นเวลาในการประมวลผลของอัลกอริทึมเปลี่ยนแปลงอย่างไรเมื่อขนาดของปัญหามีขนาดใหญ่มาก
      ในทฤษฎีจำนวนการวิเคราะห์มันถูกใช้เพื่อประเมิน &quot;ข้อผิดพลาดที่เกิดขึ้น&quot;
      ในขณะที่แทนที่ขนาดแบบอะซิมโทติคของฟังก์ชันเกี่ยวกับคณิตศาสตร์ด้วยค่าที่ใช้ในการโต้แย้งขนาดใหญ่
      ตัวอย่างที่มีชื่อเสียงคือปัญหาในการประมาณระยะเวลาที่เหลือในทฤษฎีบทจำนวนเฉพาะ
    axioms:
      title: สัจพจน์พื้นฐานของโครงสร้างข้อมูล
      description: ประสิทธิภาพการทำงานเวลาของรันไทม์ภาษาทั่วไปได้รับชุดของสัจพจน์ซึ่งตอนนี้เราจะสมมุติ
      fetch_store:
        title: ดึงข้อมูลและเก็บเวลา
        description1: เวลาที่จำเป็นในการดึงข้อมูลการอ้างอิงไปยังวัตถุจากหน่วยความจำเป็นค่าคงที่
          <span class="code-inline">T_fetch</span> และเวลาที่ต้องใช้ในการจัดเก็บการอ้างอิงไปยังวัตถุที่อยู่ในหน่วยความจำเป็นค่าคงที่,
          <span class="code-inline">T_store</span>
        description2: ตาม Axiom คำสั่งการมอบหมายมีเวลาทำงาน <span class="code-inline">T_fetch
          + T_store</span> นั่นคือเวลาที่จะดึงการอ้างอิงวัตถุจากตัวแปร x คือ <span class="code-inline">T_fetch</span>
          และเวลาที่ใช้ในการจัดเก็บการอ้างอิงวัตถุนั้นในตัวแปร y คือ <span class="code-inline">T_store</span>
        description3: ยังมีเวลาทำงาน <span class="code-inline">T_fetch + T_store</span>
          เมื่อต้องการดูสาเหตุของกรณีนี้ให้พิจารณาว่าค่าคงที่ <span class="code-inline">1</span>
          ตั้งชื่อวัตถุ Fixnum ที่มีค่าหนึ่ง ดังนั้นเราสามารถคาดได้ว่าค่าใช้จ่ายในการดึงข้อมูลอ้างอิงไปยังวัตถุที่มีชื่อว่า
          1 นั้นเหมือนกับของการดึงข้อมูลอ้างอิงไปยังวัตถุอื่น
      elementary_operations:
        title: เวลาดำเนินการทางคณิตศาสตร์เบื้องต้น
        description1: เวลาที่ใช้ในการดำเนินการทางคณิตศาสตร์เบื้องต้นเช่นการบวกการลบการคูณการหารและการเปรียบเทียบล้วนเป็นค่าคงที่ทั้งหมด
          เวลาเหล่านี้แสดงโดย <span class="code-inline">T_ +, T_-, T_ /, T_ *, T_ &lt;,</span>
          ตามลำดับ
        description2: เราสามารถกำหนดเวลาของคำสั่งเช่น <span class="code-inline">2 *
          T_fetch + T_ + + T_store</span> นี่เป็นเพราะเราจำเป็นต้องดึงข้อมูลอ้างอิงวัตถุสองรายการจากตัวแปร
          y และ 1 ดำเนินการเพิ่มให้วัตถุใหม่ที่มีค่าคือผลรวม; และเก็บการอ้างอิงไปยังวัตถุใหม่ในตัวแปร
          y
        description3: เราจะสมมติว่าทางเลือกนั้นต้องการเวลาในการรันเหมือนกับคำสั่งเดิม
      call_method:
        title: วิธีการโทรเวลา
        description1: เวลาที่ใช้ในการเรียกใช้เมธอดเป็นค่าคงที่ <span class="code-inline">T_call</span>
          และเวลาที่ต้องการคืนค่าจากเมธอดนั้นเป็นค่าคงที่ <span class="code-inline">T_return</span>
          เหตุผลสำหรับการทำให้โอเวอร์เฮดที่เกี่ยวข้องกับพารามิเตอร์ผ่านเช่นเดียวกับเวลาในการจัดเก็บการอ้างอิงวัตถุคือ
          การส่งผ่านของอาร์กิวเมนต์เป็นแนวคิดเหมือนกับการกำหนดค่าพารามิเตอร์จริงให้กับพารามิเตอร์ที่เป็นทางการของวิธีการ
        description2: ตาม Axiom เวลาทำงานของคำสั่งจะเป็น <span class="code-inline">T_fetch
          + 2 * T_store + T_call + T_f (x)</span> โดยที่ <span class="code-inline">T_f
          (x)</span> เป็นเวลาทำงานของวิธีการ f สำหรับอินพุต x ตัวแรกของทั้งสองสโตร์เกิดจากการผ่านพารามิเตอร์
          x ไปยังเมธอด f ครั้งที่สองเกิดขึ้นจากการมอบหมายให้ตัวแปร y
      calculating:
        title: เวลาคำนวณ
        description1: เวลาที่ใช้ในการคำนวณที่อยู่ที่บอกเป็นนัยโดยการดำเนินการสมัครสมาชิกอาร์เรย์เช่น
          <span class="code-inline">a[i]</span> เป็นค่าคงที่ <span class="code-inline">T_
          []</span> เวลานี้ไม่รวมเวลาในการคำนวณนิพจน์ตัวห้อยและไม่รวมเวลาในการเข้าถึงองค์ประกอบอาร์เรย์
        description2: 'นี่คือ <span class="code-inline">3 * T_fetch</span> ต้องการตัวถูกดำเนินการสามตัว:
          ตัวแรกในการดึงข้อมูลอ้างอิงไปยังวัตถุอาร์เรย์ a; วินาทีเพื่อดึงการอ้างอิงไปยังวัตถุดัชนี
          i; และอันที่สามเพื่อดึงการอ้างอิงไปยังองค์ประกอบอาร์เรย์ <span class="code-inline">a[i]</span>'
      object:
        title: เวลาสร้างวัตถุ
        description1: เวลาที่ใช้ในการสร้างวัตถุอินสแตนซ์ใหม่ของคลาสนั้นเป็นค่าคงที่
          <span class="code-inline">T_new</span> เวลานี้ไม่รวมเวลาที่ใช้เพื่อเริ่มต้นวัตถุ
          โดยการใช้สัจพจน์เราสามารถตรวจสอบว่าเวลาทำงานของคำสั่ง
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> โดยที่ <span class="code-inline">T_fixnum_init</span>
          เป็นเวลาทำงานของวิธีการเริ่มต้นของคลาส Fixnum
      example:
        title: ตัวอย่าง
        description: ในส่วนนี้เราใช้ Axioms การวิเคราะห์เวลาทำงานของโปรแกรมเพื่อคำนวณการสรุปชุดเลขคณิตอย่างง่าย
    implementations:
      title: การดำเนินงาน
      stack:
        title: กอง
        description: สแต็กคือพี่น้องของคิว มันเลียนแบบสแต็คในชีวิตจริง (เช่นกระดาษ)
          มันคือ FILO (เข้าก่อนออกก่อน) เพื่อที่ว่าเมื่อมีการดึงไอเท็มจากสแต็คมันจะถูกส่งกลับในลำดับที่กลับมา
          Ruby Arrays เป็นภาชนะที่สมบูรณ์แบบอีกครั้ง เช่นเดียวกับคิวก็สามารถนำมาใช้โดยใช้รายการที่เชื่อมโยง
        as_array: สแต็กเป็นอาร์เรย์
        as_linked_list: สแต็คเป็นรายการที่เชื่อมโยง
      queue:
        title: คิว
        description: คิวเป็นโครงสร้างแบบคอนเทนเนอร์ที่เรียบง่ายซึ่งเลียนแบบคิวชีวิตจริง
          (เช่นรออยู่ที่ธนาคาร) มันเป็น FIFO (เข้าก่อนออกก่อน) ซึ่งหมายความว่าเมื่อคุณดึงรายการจากคิวพวกเขาจะถูกส่งกลับตามลำดับที่พวกเขาป้อน
          Ruby Arrays จัดเตรียมวิธีการที่ทำให้การใช้คิวง่ายขึ้นเล็กน้อย แต่การตั้งชื่อพวกเขาอย่างเหมาะสมและมีอยู่ในคลาสความสะดวกสบายนั้นคุ้มค่าที่จะเห็นว่าพวกมันถูกนำไปใช้
          การใช้งานทางเลือกสามารถทำได้โดยใช้รายการที่เชื่อมโยง
        as_array: คิวเป็นอาร์เรย์
        as_linked_list: คิวเป็นรายการที่เชื่อมโยง
      deque:
        title: และ
        description: Deque เป็นคิวที่อนุญาตให้เพิ่มและลบรายการที่ปลายทั้งสอง
        as_array: และเป็นอาร์เรย์
        as_linked_list: Deque เป็นรายการที่เชื่อมโยง
      singly_linked_list:
        title: รายการที่เชื่อมโยงเดียวดาย
        description: รายการที่เชื่อมโยงเดี่ยวประกอบด้วยโหนดที่มีเขตข้อมูลเช่นเดียวกับเขตข้อมูล
          &#39;ถัดไป&#39; ซึ่งชี้ไปที่โหนดถัดไปในบรรทัดของโหนด การดำเนินการที่สามารถดำเนินการในรายการที่เชื่อมโยงเดี่ยวรวมถึงการแทรกการลบและการข้ามเส้นทาง
      doubly_linked_list:
        title: รายการเชื่อมโยงสองครั้ง
        description: ในรายการที่มีการเชื่อมโยงเป็นสองเท่าแต่ละองค์ประกอบของรายการจะมีการอ้างอิงสองรายการ
          - การอ้างอิงถึงการสืบทอด
      ordered_list:
        title: รายการสั่งซื้อ
        description: รายการที่สั่งซื้อคือรายการที่ลำดับของรายการมีความสำคัญ อย่างไรก็ตามรายการในรายการสั่งซื้อไม่จำเป็นต้องเรียงลำดับ
          ดังนั้นจึงเป็นไปได้ที่จะเปลี่ยนลำดับของรายการและยังมีรายการสั่งซื้อที่ถูกต้อง
        as_array: รายการสั่งซื้อเป็นอาร์เรย์
      hash_table:
        title: ตารางแฮช
        description: ตารางแฮชเป็นคอนเทนเนอร์ที่ค้นหาได้ ดังนั้นจึงมีวิธีการวางวัตถุลงในภาชนะค้นหาวัตถุในภาชนะและลบวัตถุออกจากภาชนะ
      binary_tree:
        title: ต้นไม้ไบนารี
        description: ต้นไม้ไบนารีเป็นต้นไม้ที่แต่ละโหนดสามารถมีลูกได้สูงสุดสองคน เด็กถูกกำหนดซ้ายและขวา
      binary_search_tree:
        title: ต้นไม้ค้นหาแบบทวิภาค &lt;
        description: 'ในวิทยาการคอมพิวเตอร์, binary search trees (BST) บางครั้งเรียกว่าการเรียงลำดับหรือการจัดเรียงต้นไม้ไบนารีเป็นประเภทที่เฉพาะเจาะจงของภาชนะ:
          โครงสร้างข้อมูลที่เก็บ &quot;รายการ&quot; (เช่นตัวเลขชื่อ ฯลฯ ) ในหน่วยความจำ
          อนุญาตการค้นหาอย่างรวดเร็วการเพิ่มและการลบรายการและสามารถใช้ในการใช้ชุดรายการแบบไดนามิกหรือตารางการค้นหาที่อนุญาตให้ค้นหารายการด้วยคีย์
          (เช่นค้นหาหมายเลขโทรศัพท์ของบุคคลโดยใช้ชื่อ)'
      b_tree:
        title: B ต้นไม้
        description: ในวิทยาการคอมพิวเตอร์ B-tree เป็นโครงสร้างข้อมูลแบบต้นไม้ที่ปรับสมดุลตัวเองซึ่งช่วยให้การเรียงลำดับข้อมูลและอนุญาตให้ค้นหาการเข้าถึงตามลำดับการแทรกและการลบในเวลาลอการิทึม
          B-tree เป็นลักษณะทั่วไปของแผนภูมิการค้นหาแบบไบนารีที่โหนดสามารถมีลูกได้มากกว่าสองคน
          (ซึ่งแตกต่างจากต้นไม้การค้นหาแบบไบนารีที่ปรับสมดุลตัวเองต้นไม้ B นั้นเหมาะสำหรับระบบที่อ่านและเขียนบล็อกขนาดใหญ่
          ต้นไม้เป็นตัวอย่างที่ดีของโครงสร้างข้อมูลสำหรับหน่วยความจำภายนอกซึ่งมักใช้ในฐานข้อมูลและระบบไฟล์
      binary_heap:
        title: กองไบนารี
        description: ฮีปไบนารีคือต้นไม้ไบนารีสมบูรณ์ที่สั่งซื้อฮีปซึ่งใช้งานโดยใช้อาร์เรย์
          ในฮีปจะพบคีย์ที่เล็กที่สุดที่รูทและเนื่องจากรูทนั้นมักพบในตำแหน่งแรกของอาเรย์การหาคีย์ที่เล็กที่สุดนั้นเป็นการดำเนินการที่ไม่สำคัญในฮีปไบนารี
      credits: 'รหัสและบทความถูกนำมาจากแหล่งข้อมูล:'
      source: หน้านี้มีรหัสทับทิมจากหนังสือของ &quot;โครงสร้างข้อมูลและอัลกอริทึมที่มีรูปแบบการออกแบบเชิงวัตถุในทับทิม&quot;
        โดย Bruno R. Preiss ลิขสิทธิ์ (c) 2004 โดย Bruno R. Preiss, P.Eng สงวนลิขสิทธิ์.
  design_patterns:
    title: รูปแบบการออกแบบ
    creational:
      title: รูปแบบการสร้าง
      description: ในวิศวกรรมซอฟต์แวร์รูปแบบการออกแบบเชิงสร้างสรรค์เป็นรูปแบบการออกแบบที่จัดการกับกลไกการสร้างวัตถุพยายามสร้างวัตถุในลักษณะที่เหมาะสมกับสถานการณ์
        รูปแบบพื้นฐานของการสร้างวัตถุอาจส่งผลให้เกิดปัญหาการออกแบบหรือเพิ่มความซับซ้อนให้กับการออกแบบ
        รูปแบบการออกแบบเชิงสร้างสรรค์แก้ปัญหานี้ได้ด้วยการควบคุมการสร้างวัตถุนี้ รูปแบบการออกแบบเชิงสร้างสรรค์ประกอบด้วยสองแนวคิดหลัก
        หนึ่งคือการห่อหุ้มความรู้เกี่ยวกับคลาสที่เป็นรูปธรรมที่ระบบใช้ อีกวิธีหนึ่งคือการซ่อนวิธีการสร้างและรวมคลาสของอินสแตนซ์เหล่านี้
      abstract_factory:
        title: รูปแบบโรงงานนามธรรม
        description: รูปแบบโรงงานที่เป็นนามธรรมให้วิธีการแค็ปซูลกลุ่มของโรงงานแต่ละแห่งที่มีรูปแบบทั่วไปโดยไม่ต้องระบุคลาสที่เป็นรูปธรรม
          ในการใช้งานปกติซอฟต์แวร์ไคลเอนต์จะสร้างการใช้งานที่เป็นรูปธรรมของโรงงานที่เป็นนามธรรมจากนั้นใช้อินเทอร์เฟซทั่วไปของโรงงานเพื่อสร้างวัตถุที่เป็นรูปธรรมซึ่งเป็นส่วนหนึ่งของชุดรูปแบบ
          ลูกค้าไม่ทราบ (หรือสนใจ) ว่าวัตถุใดเป็นรูปธรรมที่ได้รับจากแต่ละโรงงานภายในเหล่านี้เนื่องจากใช้เฉพาะอินเตอร์เฟสทั่วไปของผลิตภัณฑ์
          รูปแบบนี้แยกรายละเอียดของการใช้งานชุดของวัตถุจากการใช้งานทั่วไปและอาศัยองค์ประกอบของวัตถุเนื่องจากการสร้างวัตถุถูกนำไปใช้ในวิธีการที่เปิดเผยในส่วนต่อประสานจากโรงงาน
      builder:
        title: รูปแบบการสร้าง
        description: รูปแบบตัวสร้างเป็นรูปแบบการออกแบบซอฟต์แวร์การสร้างวัตถุ ซึ่งแตกต่างจากรูปแบบโรงงานนามธรรมและรูปแบบวิธีการโรงงานที่มีความตั้งใจที่จะเปิดใช้งานความหลากหลายรูปแบบความตั้งใจของรูปแบบการสร้างคือการหาวิธีการแก้ปัญหาการต่อต้านรูปแบบการสร้าง
          telescoping รูปแบบการต่อต้านการสร้าง telescoping เกิดขึ้นเมื่อการเพิ่มขึ้นของการรวมกันของพารามิเตอร์ตัวสร้างวัตถุนำไปสู่รายการชี้แจงของการก่อสร้าง
          แทนที่จะใช้ตัวสร้างจำนวนมากรูปแบบตัวสร้างใช้วัตถุอื่นตัวสร้างที่ได้รับพารามิเตอร์การกำหนดค่าเริ่มต้นแต่ละขั้นตอนแล้วส่งคืนวัตถุที่สร้างผลลัพธ์ในครั้งเดียว
      factory:
        title: รูปแบบโรงงาน
        description: ในการเขียนโปรแกรมตามคลาสรูปแบบวิธีการจากโรงงานเป็นรูปแบบการสร้างที่ใช้วิธีการจากโรงงานเพื่อจัดการกับปัญหาในการสร้างวัตถุโดยไม่ต้องระบุคลาสที่แน่นอนของวัตถุที่จะสร้างขึ้น
          สิ่งนี้ทำได้โดยการสร้างวัตถุโดยการเรียกใช้วิธีการจากโรงงานไม่ว่าจะระบุในส่วนต่อประสานและนำไปใช้งานโดยคลาสลูกหรือนำไปใช้ในคลาสฐาน
      prototype:
        title: รูปแบบต้นแบบ
        description: รูปแบบต้นแบบเป็นลวดลายที่สร้างสรรค์ตามแนวของโรงงาน เคล็ดลับกับต้นแบบคือคุณสร้างวัตถุใหม่โดยการคัดลอกวัตถุต้นแบบ
          เปลี่ยนวัตถุต้นแบบนั้นและวัตถุที่ตามมาทั้งหมดที่คุณสร้างจะหลุดออกไปพร้อมกับสำเนาของการเปลี่ยนแปลง
      singleton:
        title: รูปแบบซิงเกิล
        description: ตรวจสอบให้แน่ใจว่าคลาสมีเพียงอินสแตนซ์เดียวและให้จุดเข้าถึงส่วนกลางแก่คลาสนั้น
          สิ่งนี้มีประโยชน์เมื่อต้องการวัตถุหนึ่งชิ้นเพื่อประสานการทำงานกับระบบ บางครั้งแนวคิดจะถูกทำให้เป็นแนวไปยังระบบที่ทำงานได้อย่างมีประสิทธิภาพมากขึ้นเมื่อมีวัตถุเพียงวัตถุเดียวหรือ
          จำกัด การสร้างอินสแตนซ์ให้กับวัตถุจำนวนหนึ่ง
      not_covered:
        title: 'ไม่ครอบคลุมรูปแบบ:'
        lazy: การเริ่มต้น Lazy
        multiton: Multiton
        pool: กลุ่มวัตถุ
        resource: การจัดหาทรัพยากรเป็นการเริ่มต้น
    structural:
      title: รูปแบบโครงสร้าง
      description: ในวิศวกรรมซอฟต์แวร์รูปแบบการออกแบบโครงสร้างเป็นรูปแบบการออกแบบที่ทำให้การออกแบบง่ายขึ้นโดยการระบุวิธีง่ายๆในการตระหนักถึงความสัมพันธ์ระหว่างเอนทิตี
      adapter:
        title: รูปแบบของอะแดปเตอร์
        description: ในวิศวกรรมซอฟต์แวร์รูปแบบอะแด็ปเตอร์เป็นรูปแบบการออกแบบซอฟต์แวร์ที่อนุญาตให้อินเตอร์เฟสของคลาสที่มีอยู่ถูกใช้เป็นอินเตอร์เฟสอื่น
          มักจะใช้เพื่อให้คลาสที่มีอยู่ทำงานกับผู้อื่นโดยไม่ต้องแก้ไขซอร์สโค้ด
      composite:
        title: รูปแบบคอมโพสิต
        description: รูปแบบการออกแบบคอมโพสิตเป็นรูปแบบโครงสร้างที่ใช้ในการแสดงวัตถุที่มีโครงสร้างต้นไม้แบบลำดับชั้น
          จะช่วยให้การรักษาที่สม่ำเสมอของทั้งโหนดใบบุคคลและสาขาที่ประกอบด้วยหลายโหนด
      decorator:
        title: รูปแบบมัณฑนากร
        description: ในการเขียนโปรแกรมเชิงวัตถุรูปแบบมัณฑนากร (หรือเรียกอีกอย่างว่า
          Wrapper การตั้งชื่ออื่นที่ใช้ร่วมกับรูปแบบตัวแปลง) เป็นรูปแบบการออกแบบที่อนุญาตให้มีการเพิ่มพฤติกรรมให้กับวัตถุแต่ละชิ้นทั้งแบบคงที่หรือแบบไดนามิก
          วัตถุจากคลาสเดียวกัน รูปแบบมัณฑนากรมักจะมีประโยชน์สำหรับการปฏิบัติตามหลักการความรับผิดชอบเดียวเนื่องจากช่วยให้การทำงานแบ่งออกเป็นคลาสต่างๆ
      facade:
        title: ลวดลายด้านหน้า
        description: รูปแบบการออกแบบ Facade มักใช้เมื่อระบบมีความซับซ้อนมากหรือยากที่จะเข้าใจเนื่องจากระบบมีคลาสที่พึ่งพาซึ่งกันและกันจำนวนมากหรือซอร์สโค้ดไม่พร้อมใช้งาน
          รูปแบบนี้ซ่อนความซับซ้อนของระบบที่มีขนาดใหญ่ขึ้นและให้อินเทอร์เฟซที่ง่ายกว่าให้กับลูกค้า
          มันมักจะเกี่ยวข้องกับคลาส wrapper เดียวซึ่งมีชุดของสมาชิกที่ลูกค้าต้องการ
          สมาชิกเหล่านี้เข้าถึงระบบในนามของลูกค้าซุ้มและซ่อนรายละเอียดการใช้งาน
      flyweight:
        title: รูปแบบฟลายเวท
        description: ในการเขียนโปรแกรมคอมพิวเตอร์ flyweight เป็นรูปแบบการออกแบบซอฟต์แวร์
          flyweight เป็นวัตถุที่ลดการใช้หน่วยความจำด้วยการแบ่งปันข้อมูลให้มากที่สุดเท่าที่จะทำได้กับวัตถุอื่นที่คล้ายกัน
          มันเป็นวิธีใช้วัตถุในจำนวนมากเมื่อการแสดงซ้ำ ๆ อย่างง่าย ๆ จะใช้หน่วยความจำที่ยอมรับไม่ได้
          บ่อยครั้งที่บางส่วนของสถานะวัตถุสามารถใช้ร่วมกันและเป็นเรื่องธรรมดาที่จะเก็บไว้ในโครงสร้างข้อมูลภายนอกและส่งต่อไปยังวัตถุฟลายเวทชั่วคราวเมื่อมีการใช้งาน
      proxy:
        title: รูปแบบพร็อกซี
        description: 'พร็อกซีในรูปแบบทั่วไปส่วนใหญ่เป็นคลาสที่ทำงานเป็นส่วนต่อประสานกับสิ่งอื่น
          พร็อกซีสามารถเชื่อมต่อกับสิ่งใดก็ได้: การเชื่อมต่อเครือข่ายวัตถุขนาดใหญ่ในหน่วยความจำไฟล์หรือทรัพยากรอื่น
          ๆ ที่มีราคาแพงหรือไม่สามารถทำซ้ำได้ ในระยะสั้นพร็อกซีเป็นวัตถุห่อหุ้มหรือตัวแทนที่ถูกเรียกโดยลูกค้าในการเข้าถึงวัตถุที่ให้บริการจริงที่อยู่เบื้องหลัง
          การใช้พร็อกซีสามารถส่งต่อไปยังวัตถุจริงหรือสามารถให้ตรรกะเพิ่มเติม ในฟังก์ชั่นการทำงานพิเศษของพร็อกซี่สามารถให้ได้ตัวอย่างเช่นการแคชเมื่อการดำเนินการบนวัตถุจริงเป็นทรัพยากรที่เข้มข้นหรือการตรวจสอบเงื่อนไขก่อนการดำเนินการบนวัตถุจริงจะถูกเรียก
          สำหรับลูกค้าการใช้งานของวัตถุพร็อกซี่คล้ายกับการใช้วัตถุจริงเพราะทั้งสองใช้อินเทอร์เฟซเดียวกัน'
      protection_proxy:
        title: พรอกซีคุ้มครอง
        description: พรอกซีคุ้มครอง คุณกำลังทำงานกับ MNC อยู่หรือเปล่า? ถ้าเป็นเช่นนั้นเราอาจทราบพร็อกซีเซิร์ฟเวอร์ที่ให้บริการอินเทอร์เน็ตโดย
          จำกัด การเข้าถึงเว็บไซต์บางประเภทเช่นอีเมลสาธารณะเครือข่ายสังคมออนไลน์การจัดเก็บข้อมูลเป็นต้นฝ่ายบริหารรู้สึกว่าควรปิดกั้นเนื้อหา
          จัดทำเว็บเพจที่เกี่ยวข้องกับงานเท่านั้น พร็อกซีเซิร์ฟเวอร์ทำหน้าที่ดังกล่าว
          นี่เป็นรูปแบบการออกแบบพรอกซี
      virtual_proxy:
        title: พร็อกซีเสมือน
        description: พร็อกซีเสมือน ใช้แทนโครงกระดูกแทนวัตถุที่ซับซ้อนหรือหนัก เมื่ออิมเมจต้นแบบมีขนาดใหญ่เพียงแค่แสดงโดยใช้วัตถุพร็อกซีเสมือนและตามความต้องการโหลดวัตถุจริง
          คุณรู้ว่าวัตถุจริงมีราคาแพงในแง่ของการสร้างอินสแตนซ์และดังนั้นโดยไม่จำเป็นต้องใช้จริงเราจะไม่ใช้วัตถุจริง
          เราจะใช้พร็อกซีเสมือนจริงจนกว่าจะมีความจำเป็นเกิดขึ้น
      remote_proxy:
        title: รีโมตพรอกซี
        description: รีโมตพรอกซี ในการสื่อสารวัตถุแบบกระจายวัตถุในพื้นที่หมายถึงวัตถุระยะไกล
          (อันที่เป็นของพื้นที่ที่อยู่ที่แตกต่างกัน) โลคัลวัตถุเป็นพร็อกซีสำหรับวัตถุระยะไกลและการเรียกใช้เมธอดบนวัตถุในระบบส่งผลให้เกิดการเรียกใช้เมธอดระยะไกลบนวัตถุระยะไกล
          คิดว่าการใช้ ATM นั้นจะเก็บวัตถุพร็อกซีสำหรับข้อมูลธนาคารที่มีอยู่ในเซิร์ฟเวอร์ระยะไกล
      not_covered:
        title: 'ไม่ครอบคลุมรูปแบบ:'
        callback: โทรกลับข้อเขียน
        bridge: สะพาน
        data_bus: ดาต้าบัส
        role: บทบาทของวัตถุ
    behavioral:
      title: รูปแบบพฤติกรรม
      description: ในวิศวกรรมซอฟต์แวร์รูปแบบการออกแบบพฤติกรรมคือรูปแบบการออกแบบที่ระบุรูปแบบการสื่อสารทั่วไประหว่างวัตถุและตระหนักถึงรูปแบบเหล่านี้
        รูปแบบเหล่านี้ช่วยเพิ่มความยืดหยุ่นในการสื่อสารนี้
      chain_of_responsobility:
        title: รูปแบบของความรับผิดชอบ
        description: ในการออกแบบเชิงวัตถุรูปแบบห่วงโซ่ความรับผิดชอบเป็นรูปแบบการออกแบบที่ประกอบด้วยแหล่งที่มาของวัตถุคำสั่งและชุดของวัตถุการประมวลผล
          แต่ละวัตถุการประมวลผลมีตรรกะที่กำหนดประเภทของวัตถุคำสั่งที่สามารถจัดการได้
          ส่วนที่เหลือจะถูกส่งผ่านไปยังวัตถุการประมวลผลต่อไปในห่วงโซ่ กลไกยังมีอยู่สำหรับการเพิ่มวัตถุการประมวลผลใหม่ที่ส่วนท้ายของห่วงโซ่นี้
      command:
        title: รูปแบบคำสั่ง
        description: รูปแบบคำสั่งเป็นรูปแบบการออกแบบพฤติกรรมที่ใช้ในการจัดเก็บข้อมูลที่จำเป็นในการเรียกวิธีการในอนาคต
          คำสั่งเป็นเพียงชุดของการกระทำที่รวมอยู่ในวัตถุ ด้วยทับทิมเราสามารถใช้ Procs
          ทำสิ่งเดียวกันโดยไม่จำเป็นต้องสร้างวัตถุแยกต่างหาก นี่เป็นตัวเลือกที่ดีเมื่อการกระทำนั้นง่ายและไม่ต้องการการบันทึกข้อมูลสถานะมิฉะนั้นคลาสคำสั่งจะเป็นตัวเลือกที่ดีกว่า
      interpreter:
        title: รูปแบบของล่าม
        description: ในการเขียนโปรแกรมคอมพิวเตอร์รูปแบบของล่ามเป็นรูปแบบการออกแบบที่ระบุวิธีการประเมินประโยคในภาษา
          แนวคิดพื้นฐานคือการมีคลาสสำหรับแต่ละสัญลักษณ์ (เทอร์มินัลหรือไม่ใช่เทอร์มินัล)
          ในภาษาคอมพิวเตอร์พิเศษ ทรีไวยากรณ์ของประโยคในภาษาเป็นตัวอย่างของรูปแบบคอมโพสิตและใช้ในการประเมิน
          (ตีความ) ประโยคสำหรับลูกค้า
      iterator:
        title: รูปแบบการวนซ้ำ
        description: รูปแบบการออกแบบตัววนซ้ำให้การเข้าถึงองค์ประกอบภายในคอนเทนเนอร์โดยไม่เปิดเผยว่าคอนเทนเนอร์แสดงองค์ประกอบอย่างไร
          ตัววนซ้ำสามารถใช้เป็นตัวชี้แบบเคลื่อนย้ายได้ที่อนุญาตให้เข้าถึงองค์ประกอบที่ห่อหุ้มภายในคอนเทนเนอร์
      external_iterator:
        title: รูปแบบตัววนซ้ำภายนอก
        description: 'ตัววนซ้ำภายนอก: ตรรกะการวนซ้ำนั้นมีอยู่ในคลาสที่แยกต่างหาก คลาสการทำซ้ำสามารถวางนัยเพื่อจัดการกับชนิดของวัตถุหลายชนิดตราบใดที่อนุญาตการทำดัชนี
          มันต้องการคลาสเพิ่มเติมเพื่อทำการวนซ้ำจริง ๆ แต่มันอนุญาตให้มีความยืดหยุ่นมากขึ้นเนื่องจากคุณสามารถควบคุมการวนซ้ำได้ซึ่งองค์ประกอบใดที่ถูกวนซ้ำแล้วซ้ำอีก'
      internal_iterator:
        title: รูปแบบตัววนซ้ำภายใน
        description: 'Internal iterator: ตรรกะการวนซ้ำทั้งหมดเกิดขึ้นภายในวัตถุรวม ใช้การบล็อกรหัสเพื่อส่งต่อตรรกะของคุณไปยังผลรวมซึ่งเรียกการบล็อกสำหรับแต่ละองค์ประกอบ'
      mediator:
        title: รูปแบบคนกลาง
        description: โดยปกติโปรแกรมจะประกอบด้วยคลาสจำนวนมาก ดังนั้นตรรกะและการคำนวณจึงถูกแจกจ่ายในคลาสเหล่านี้
          อย่างไรก็ตามเมื่อมีการพัฒนาคลาสเพิ่มเติมในโปรแกรมโดยเฉพาะในระหว่างการบำรุงรักษาและ
          / หรือการเปลี่ยนโครงสร้างปัญหาการสื่อสารระหว่างคลาสเหล่านี้อาจซับซ้อนมากขึ้น
          ทำให้โปรแกรมอ่านและดูแลรักษาได้ยากขึ้น นอกจากนี้อาจเป็นการยากที่จะเปลี่ยนโปรแกรมเนื่องจากการเปลี่ยนแปลงใด
          ๆ อาจส่งผลกระทบต่อรหัสในคลาสอื่น ๆ ด้วยรูปแบบผู้ไกล่เกลี่ยการสื่อสารระหว่างวัตถุถูกห่อหุ้มด้วยวัตถุผู้ไกล่เกลี่ย
          วัตถุจะไม่สื่อสารกันโดยตรง แต่จะสื่อสารผ่านตัวกลาง สิ่งนี้จะช่วยลดการพึ่งพาระหว่างการสื่อสารวัตถุดังนั้นการลดการแต่งงาน
      momento:
        title: ช่วงเวลาของรูปแบบ
        description: 'รูปแบบโมเมนโม่นำมาใช้กับวัตถุสามชิ้น: ผู้ริเริ่มผู้ดูแลและโมโม
          ผู้สร้างเป็นวัตถุบางอย่างที่มีสถานะภายใน ผู้ดูแลกำลังจะทำอะไรบางอย่างกับผู้สร้าง
          แต่ต้องการที่จะสามารถยกเลิกการเปลี่ยนแปลงได้ ผู้ดูแลคนแรกขอให้ผู้ประดิษฐ์ถามวัตถุสักครู่
          จากนั้นก็จะทำการดำเนินการใด ๆ (หรือลำดับของการดำเนินการ) มันจะทำ เมื่อต้องการย้อนกลับไปสู่สถานะก่อนการดำเนินการจะส่งคืนวัตถุโมโมไปที่ผู้สร้าง
          วัตถุโมโมเป็นวัตถุทึบแสง (สิ่งหนึ่งซึ่งผู้ดูแลไม่สามารถหรือไม่ควรเปลี่ยนแปลง)
          เมื่อใช้รูปแบบนี้ควรใช้ความระมัดระวังหากผู้สร้างอาจเปลี่ยนวัตถุหรือทรัพยากรอื่น
          ๆ - รูปแบบโมโมใช้ในวัตถุเดียว'
      observer:
        title: รูปแบบการสังเกตการณ์
        description: รูปแบบการสังเกตการณ์เป็นรูปแบบการออกแบบซอฟต์แวร์ที่วัตถุเรียกว่าหัวเรื่องดูแลรายการของผู้ติดตามเรียกว่าผู้สังเกตการณ์และแจ้งให้พวกเขาทราบโดยอัตโนมัติเมื่อมีการเปลี่ยนแปลงสถานะใด
          ๆ ส่วนใหญ่จะใช้ในการใช้ระบบการจัดการเหตุการณ์แบบกระจาย รูปแบบ Observer ยังเป็นส่วนสำคัญในรูปแบบสถาปัตยกรรม
          model-view – controller (MVC) ที่คุ้นเคย รูปแบบการสังเกตการณ์ถูกนำไปใช้ในไลบรารีและระบบการเขียนโปรแกรมจำนวนมากรวมถึงชุดเครื่องมือ
          GUI เกือบทั้งหมด
      state:
        title: รูปแบบของรัฐ
        description: รูปแบบสถานะเป็นรูปแบบการออกแบบซอฟต์แวร์เชิงพฤติกรรมที่ใช้เครื่องรัฐในลักษณะเชิงวัตถุ
          ด้วยรูปแบบสถานะเครื่องของรัฐจะถูกนำไปใช้โดยการนำแต่ละรัฐมาเป็นคลาสที่ได้รับมาจากอินเตอร์เฟสรูปแบบของรัฐ
      strategy:
        title: รูปแบบกลยุทธ์
        description: กลยุทธ์ช่วยให้อัลกอริทึมแตกต่างจากลูกค้าที่ใช้งาน กลยุทธ์เป็นหนึ่งในรูปแบบที่รวมอยู่ในรูปแบบการออกแบบหนังสือที่มีอิทธิพลโดย
          Gamma และคณะ ที่เป็นที่นิยมแนวคิดของการใช้รูปแบบเพื่ออธิบายการออกแบบซอฟต์แวร์
          ตัวอย่างเช่นคลาสที่ดำเนินการตรวจสอบความถูกต้องของข้อมูลที่เข้ามาอาจใช้รูปแบบกลยุทธ์เพื่อเลือกอัลกอริทึมการตรวจสอบความถูกต้องตามประเภทของข้อมูลแหล่งที่มาของข้อมูลทางเลือกของผู้ใช้หรือปัจจัยอื่น
          ๆ ไม่ทราบปัจจัยเหล่านี้สำหรับแต่ละกรณีจนกว่าจะถึงเวลาใช้งานและอาจต้องการการตรวจสอบที่แตกต่างอย่างสิ้นเชิง
          กลยุทธ์การตรวจสอบความถูกต้องห่อหุ้มแยกจากวัตถุที่ตรวจสอบความถูกต้องอาจถูกใช้โดยวัตถุตรวจสอบอื่น
          ๆ ในพื้นที่ต่าง ๆ ของระบบ (หรือแม้แต่ระบบที่แตกต่างกัน) โดยไม่มีการทำซ้ำรหัส
      template:
        title: รูปแบบวิธีการเทมเพลต
        description: ในการเขียนโปรแกรมเชิงวัตถุคลาสแรกจะถูกสร้างขึ้นซึ่งให้ขั้นตอนพื้นฐานของการออกแบบอัลกอริทึม
          ขั้นตอนเหล่านี้มีการใช้งานโดยใช้วิธีนามธรรม ต่อมา subclasses จะเปลี่ยนวิธีนามธรรมเพื่อใช้การกระทำจริง
          ดังนั้นอัลกอริทึมทั่วไปจะถูกบันทึกไว้ในที่เดียว แต่อาจมีการเปลี่ยนแปลงขั้นตอนที่เป็นรูปธรรมโดยคลาสย่อย
      visitor:
        title: รูปแบบของผู้มาเยี่ยม
        description: ในการเขียนโปรแกรมเชิงวัตถุและวิศวกรรมซอฟต์แวร์รูปแบบการออกแบบผู้เข้าชมเป็นวิธีการแยกอัลกอริทึมจากโครงสร้างวัตถุที่ทำงาน
          ผลลัพธ์เชิงปฏิบัติของการแยกนี้คือความสามารถในการเพิ่มการปฏิบัติการใหม่ไปยังโครงสร้างวัตถุที่มีอยู่โดยไม่ต้องดัดแปลงโครงสร้างเหล่านั้น
          เป็นวิธีหนึ่งในการปฏิบัติตามหลักการเปิด / ปิด ในสาระสำคัญผู้เข้าชมช่วยให้หนึ่งเพิ่มฟังก์ชั่นเสมือนใหม่ให้กับครอบครัวของคลาสโดยไม่ต้องแก้ไขชั้นเรียนด้วยตนเอง;
          แต่จะสร้างคลาสผู้เยี่ยมชมที่ใช้ความเชี่ยวชาญเฉพาะทางที่เหมาะสมของฟังก์ชันเสมือน
          ผู้เข้าชมใช้การอ้างอิงอินสแตนซ์เป็นข้อมูลเข้าและใช้เป้าหมายผ่านการจัดส่งซ้ำ
      not_covered:
        title: 'ไม่ครอบคลุมรูปแบบ:'
        hierarchical: ผู้เข้าชมตามลำดับชั้น
      credits: 'รหัสและบทความถูกนำมาจากแหล่งข้อมูล:'
  functional_programming:
    title: ฟังก์ชั่นการเขียนโปรแกรม
    description: 'การใช้ภาษาในสไตล์ที่ใช้งานได้นั้นหมายถึงคุณสามารถเข้าถึงฟีเจอร์สำคัญบางอย่างที่แสดงด้านล่าง:'
    axioms:
      immutable: 'ค่าไม่เปลี่ยนรูป: เมื่อตั้งค่า“ ตัวแปร” แล้วจะไม่สามารถเปลี่ยนแปลงได้
        ในรูบีหมายความว่าคุณต้องปฏิบัติต่อตัวแปรอย่างคงที่'
      side_effects: 'ไม่มีผลข้างเคียง: เมื่อผ่านค่าที่กำหนดไว้ฟังก์ชันจะต้องส่งคืนผลลัพธ์เดียวกันเสมอ
        สิ่งนี้ไปควบคู่ไปกับการมีค่าที่ไม่เปลี่ยนรูปแบบ ฟังก์ชั่นไม่สามารถรับค่าและเปลี่ยนมันได้เนื่องจากจะทำให้เกิดผลข้างเคียงที่เป็นวงสัมผัสกับการส่งคืนผลลัพธ์'
      pure_functions: 'ฟังก์ชันลำดับสูงกว่า: ฟังก์ชันเหล่านี้เป็นฟังก์ชันที่อนุญาตให้ใช้เป็นอาร์กิวเมนต์หรือใช้ฟังก์ชันเป็นค่าส่งคืน
        นี่คือหนึ่งในคุณสมบัติที่สำคัญที่สุดของภาษาการทำงานใด ๆ'
      applying: 'Currying: เปิดใช้งานโดยฟังก์ชั่นลำดับสูงกว่าการ Currying กำลังเปลี่ยนฟังก์ชั่นที่รับอาร์กิวเมนต์หลาย
        ๆ ตัวเป็นฟังก์ชันที่รับหนึ่งอาร์กิวเมนต์ สิ่งนี้จะเข้าคู่กับแอปพลิเคชั่นบางส่วนซึ่งเปลี่ยนฟังก์ชั่นหลายอาร์กิวเมนต์เป็นฟังก์ชันที่ใช้อาร์กิวเมนต์น้อยลงจากเดิม'
      recursion: 'การเรียกซ้ำ: วนซ้ำโดยเรียกฟังก์ชันจากภายในตัวมันเอง เมื่อคุณไม่สามารถเข้าถึงข้อมูลที่ไม่สามารถเปลี่ยนแปลงได้การเรียกซ้ำใช้เพื่อสร้างและโยงการสร้างข้อมูล
        นี่เป็นเพราะการวนซ้ำไม่ใช่แนวคิดการทำงานเนื่องจากต้องการให้ตัวแปรถูกส่งไปรอบ
        ๆ เพื่อเก็บสถานะของการวนซ้ำในเวลาที่กำหนด'
      lazy: 'Lazy-Assessment หรือ Delay Evaluation: ชะลอการประมวลผลของค่าจนกว่าจะถึงเวลาที่จำเป็นจริงๆ
        หากเป็นตัวอย่างคุณมีรหัสบางส่วนที่สร้างรายการของหมายเลขฟีโบนักชีที่เปิดใช้งานการประเมินผลแบบขี้เกียจสิ่งนี้จะไม่ถูกประมวลผลและคำนวณจริงจนกว่าจะมีค่าหนึ่งในผลลัพธ์ที่ต้องการโดยฟังก์ชันอื่นเช่นใส่'
    pure_functions:
      title: ฟังก์ชั่นที่บริสุทธิ์
      description: คุณจะเห็นว่าฟังก์ชั่นนี้คำนวณผลลัพธ์โดยใช้อาร์กิวเมนต์
    closures:
      title: ปิด
      description: แลมบ์ดาบังคับใช้การปิดตัวและสามารถรักษาบริบทของวัตถุไว้ได้
    applying:
      title: การนำไปใช้บางส่วนและการดำเนินการ
      description: ก่อนอื่นเรามาทำความเข้าใจว่าแอปพลิเคชั่นที่แตกต่างกันของฟังก์ชั่นเหล่านี้คืออะไร
        แอปพลิเคชันฟังก์ชันบางส่วนกำลังเรียกใช้ฟังก์ชันที่มีอาร์กิวเมนต์จำนวนหนึ่งเพื่อรับฟังก์ชันกลับมาซึ่งจะใช้อาร์กิวเมนต์น้อยลงมาก
        การ Currying ใช้ฟังก์ชันที่รับอาร์กิวเมนต์ n และแยกออกเป็นฟังก์ชัน n ที่รับหนึ่งอาร์กิวเมนต์
      proc: เพื่อที่จะให้คุณมีความคิดที่ชัดเจนมากขึ้นในสิ่งที่แต่ละสิ่งสองอย่างนี้จะทำหน้าที่เราจะมาเป็นตัวอย่าง
        Proc
      partial: แอปพลิเคชั่นบางส่วนของฟังก์ชันนี้จะกลับมาถ้าเราผ่านข้อโต้แย้งสองข้อแรกไปแล้ว
        Procs ที่ซ้อนกันต่อไปนี้
      curry: <span class="code-inline">.curry</span> ส่งคืน proc ที่ curried หากกำหนดอาร์กิวเมนต์
        arity เพิ่มเติมจะกำหนดจำนวนอาร์กิวเมนต์ proc curried ได้รับข้อโต้แย้งบางอย่าง
        หากมีการกำหนดจำนวนอาร์กิวเมนต์ที่เพียงพอก็จะส่งผ่านอาร์กิวเมนต์ที่ให้ไปยัง proc
        ดั้งเดิมและส่งคืนผลลัพธ์ มิฉะนั้นส่งคืน proc ที่ curried อื่นที่ใช้เวลาที่เหลือของการขัดแย้ง
  gotchas:
    title: Gotchas
    description1: ผู้เริ่มต้น Ruby on Rails ส่วนใหญ่ตื่นเต้นกับกรอบการทำงานและเริ่มสร้างแอพพลิเคชั่นโดยไม่ต้องมีความรู้ด้านภาษา
      และนั่นคือความมหัศจรรย์ของ RoR
    description2: เมื่อถึงจุดหนึ่งสิ่งต่าง ๆ เริ่มจริงจัง บางคนใช้เวลาและความพยายามในการค้นหาความลับสกปรกของ
      Ruby on Rails ในขณะที่บางคนก็มองข้ามและกลายเป็นนักพัฒนาอาวุโสที่แทบไม่มีความรู้เรื่องภาษาเลย
    description3: อย่างไรก็ตามไม่ช้าก็เร็วผู้เริ่มต้นหรือโปรแกรมเมอร์ที่มีประสบการณ์เราทุกคนต่างก็รู้จักกันในชื่อ
      Ruby Gotchas ซึ่งเป็นภาษาย่อยเล็ก ๆ ที่ซ่อนตัวจากเว็บไซต์ของเราเป็นเวลาหลายชั่วโมงสำหรับการดีบักแบบง่าย
      ๆ
    description4: นี่คือรายการของ gotchas Ruby ยอดนิยมและวิทยากรที่นักพัฒนาควรระวัง
      สำหรับแต่ละกรณีมีตัวอย่างของรหัสที่สับสนและ / หรือรหัสข้อผิดพลาดได้ง่าย
    description5: พวกเขามาพร้อมกับแนวปฏิบัติที่ดีที่จะป้องกันไม่ให้คุณทำผิดพลาด (แต่หายาก)
      และทำให้ชีวิตของคุณ (และผู้ดูแลโค้ดของคุณ) ง่ายขึ้น
    surprising:
      title: ทับทิมสามารถสร้างความประหลาดใจ
      description: แม้ว่า &quot;ออกแบบมาเพื่อเพิ่มความสุขโปรแกรมเมอร์&quot; ด้วย &quot;หลักการของความประหลาดใจน้อยที่สุด&quot;
        ทับทิมยังคงมี gotchas งานนำเสนอนี้จะเริ่มต้นจาก gotchas เล็กน้อยมือใหม่ไปสู่
        gotchas ขั้นสูงและสับสน
    quotes:
      title: อย่าอ้างฉันถึงสิ่งนี้ แต่ ...
      description: การแก้ไขสตริง (รวมถึงอักขระพิเศษเช่น <span class="code-inline">\
        n</span> ) ล้มเหลวด้วยเครื่องหมายคำพูด <span class="code-inline">&#39;เดี่ยว&#39;</span>
        - ต้องมีเครื่องหมายคำพูด <span class="code-inline">&quot;คู่&quot;</span> เหมือนกับในภาษาส่วนใหญ่ที่มีการแก้ไขสตริง
        เพื่อหลีกเลี่ยงการใช้เป็นสองเท่าในทางปฏิบัติ
    twue:
      title: มันเป็นเรื่องที่สอง! มันเป็นเรื่องที่สอง!
      description: 'มีเพียงสองสิ่งเท่านั้นที่เป็นเท็จ: <span class="code-inline">false</span>
        และ <span class="code-inline">nil</span> ทุกสิ่งทุกอย่างคือความจริงแม้แต่ <span
        class="code-inline">0</span> (false ใน C), <span class="code-inline">&quot;&quot;</span>
        (false ใน JS), <span class="code-inline">[]</span> , ฯลฯ เดินทางไปหาผู้คนจาก
        C, JS และอื่น ๆ ซึ่งบางส่วนเป็นเท็จ'
    symbols_and_strings:
      title: แขวนเขาไว้ในรูปหุ่นหรือร้อยเขาเป็นสัญลักษณ์
      description: '<span class="code-inline">Symbol! = String</span> แม้ว่าจะเหมือนกันเมื่อพิมพ์
        จำไว้ว่าอันไหนใช้สำหรับ args ให้ใช้วิธีใดวิธีหนึ่งตามที่คาดไว้: &quot;จงเสรีในสิ่งที่คุณยอมรับและอนุรักษ์ในสิ่งที่คุณส่ง&quot;
        กฎหมายของ Postel'
    string_or_nothing:
      title: สตริง ... หรือไม่มีอะไร!
    constants:
      title: ค่าคงที่ไม่ใช่
      description: ตัวพิมพ์ใหญ่เริ่มต้นหมายถึงค่าคงที่ใน Ruby ลองเปลี่ยนค่าคงที่ Ooooh
        คุณได้รับคำเตือน! BFD การแช่แข็งแม้ไม่ได้ผลกับ Fixnums มันใช้งานได้กับอาร์เรย์
        (เรียงลำดับ) และวัตถุอื่น ๆ ส่วนใหญ่ ... เขาบอกล่วงหน้า
    equals:
      title: บางคนมีความเท่าเทียมกันมากกว่าคนอื่น ๆ
      description: <span class="code-inline">==</span> เป็นค่าเดียวกันปกติ. <span class="code-inline">eql?</span>
        ค่าและคลาส (1 คือ Fixnum, 1.0 คือ Float), <span class="code-inline">. equal?</span>
        เป็นวัตถุเดียวกัน มันมีขนมาก
    operations:
      title: "&gt; ===! = ==!"
      description: <span class="code-inline">===</span> คือ &quot;case equality&quot;
        เช่นเดียวกับในคำสั่ง case ชื่อที่ดีกว่าอาจเป็น. <span class="code-inline">อธิบายหรือไม่</span>
        หรือเกิน. รวม <span class="code-inline">?</span> . อีกครั้งมันมีขนมาก ดูเอกสารเกี่ยวกับวัตถุคลาส
        รับคนจากภาษาโดยที่ <span class="code-inline">===</span> เป็นเอกลักษณ์ของวัตถุหรือค่าและคลาสเดียวกัน
    priority:
      title: และ! = &amp;&amp;, หรือ! = ||
      description: '<span class="code-inline">&&</span> มีลำดับความสำคัญสูงกว่า
        <span class="code-inline">=</span> ดังนั้น <span class="code-inline">x = true && false</span>
        หมายถึง <span class="code-inline">x = (true && false)</span>
        และมีลำดับความสำคัญต่ำกว่าดังนั้น <span class="code-inline">x = true and false</span>
        <span class="code-inline">(x = true) and false</span> คู่มือสไตล์ทับทิม: ใช้ <span class="code-inline">&&,
        ||</span> สำหรับนิพจน์บูลีน <span class="code-inline">and, or</span> สำหรับโฟลว์การควบคุม'
    sensitive:
      title: อย่าไวเกินไป!
      description: ช่องว่างไม่รู้สึก? ไม่เสมอ! Parser คิดว่านี่เป็นนิพจน์โดยที่ arg
        หนึ่ง แต่ <span class="code-inline">(1, 2)</span> ไม่ใช่ expression Ruby ที่ถูกต้อง!
        (ใช้ได้กับอาร์กิวเมนต์ 1 ข้อ)
      usage: 'ด้วย args หลายอัน: <br/> - ไม่มี parens ไม่มีปัญหา <br/> - ผู้ปกครองไม่มีพื้นที่ตกลง
        <br/> - ผู้ปกครองและพื้นที่ไม่!'
      methods: '<span class="code-inline">method / num</span> เป็น regex หรือ string
        ที่ไม่ได้ระบุ! ทับทิมคิดว่าคุณให้เหตุผลกับวิธีการ หลักการทั่วไป: ใช้ช่องว่าง
        BALANCED; ทั้งสองข้างหรือไม่'
      arguments: '<span class="code-inline">one -2</span> ทำให้ Ruby คิดว่าคุณกำลังให้อาร์กิวเมนต์
        <span class="code-inline">-2</span> กับวิธีที่หนึ่ง เหมือนกันสำหรับ <span class="code-inline">+2</span>
        หรือแม้กระทั่ง <span class="code-inline">* 2</span> อีกครั้ง: ใช้ช่องว่าง BALANCED
        ทั้งสองข้างหรือไม่'
      stubby: 'lambdas &quot;Stabby&quot; (1.9+) วงเล็บที่เป็นตัวเลือกเว้นวรรคก่อนหลังจาก
        args โดยไม่มีผู้ปกครองตกลง เว้นวรรคหลังจากผู้ปกครองตกลง อีกครั้งเว้นวรรคก่อนผู้ปกครองไม่!
        UPDATE: แก้ไขใน 2.0!'
    onto:
      title: The yer @ สู่!
      description: 'ค่า Naked กลายเป็นตัวแปรท้องถิ่นชั่วคราว! การแก้ไข: จำ <span class="code-inline">@!</span>
        (หรือ &quot;self.&quot; หรือใช้ <span class="code-inline">attr_writer, attr_accessor</span>
        .) รับคนจาก Java / C ++, Python ไม่มาก (ซึ่งต้องการ &quot;self&quot; ด้วย) &quot;คุณใช้ตัวแปรนั้นต่อไปฉันไม่คิดว่ามันหมายถึงสิ่งที่คุณคิดว่ามันหมายถึง&quot;
        ไม่ใช่ Inigo Montoya'
    variables:
      title: ระวังสิมันคือ @@!
      description: ดูสิ่งที่เติมที่ว่างเปล่า? เราไม่ได้เปลี่ยน <span class="code-inline">ค่า @@</span>
        ของผู้ปกครองก่อนที่จะตรวจสอบและไม่ได้เป็นเด็กเลย! หรือว่าพวกเรา <span
        class="code-inline">ตัวแปร @@</span> จะถูกแชร์กับคลาสย่อยไม่ใช่แค่มี แต่ตัวแปรเท่านั้น!
        การประกาศ <span class="code-inline">ค่า @@</span> ของ Child เปลี่ยนแปลงผู้ปกครองและรวมถึง
        Child&#39;s.ut ที่เปลี่ยนไปของผู้ปกครองด้วยนั่นคือ @@
    initialize:
      title: ด้วย init (ialize) หรือไม่มีเลย
      description: การเริ่มต้นของผู้ปกครองจะทำงานโดยอัตโนมัติเฉพาะในกรณีที่เด็กไม่มี
        อื่นผู้ปกครองจะต้องเรียกให้ทำงาน
    superman:
      title: ซูเปอร์แมนกับมนุษย์ล่องหน
      description: '<span class="code-inline">super</span> กับรายการหาเรื่องไม่ส่งสิ่งที่โทรได้
        <span class="code-inline">super</span> กับ args อย่างชัดเจนส่ง args เหล่านั้นเพื่อส่ง
        args NO ใช้ parens ว่างเปล่า: <span class="code-inline">super()</span>.'
    regexp:
      title: เมื่อไหร่จะจบ? (หรือเริ่ม?)
      description: 'ใน regexps มาตรฐาน: <span class="code-inlne">^</span> คือ start
        และ <span class="code-inline">$</span> คือจุดสิ้นสุดของสตริงทั้งหมด ruby regexes
        เริ่มต้นที่ multiline ดังนั้น: <span class="code-inline">^</span> คือ start
        และ <span class="code-inline">$</span> คือ end ของบรรทัดใด ๆ <span class="code-inline">\
        A</span> คือเริ่มต้นและ <span class="code-inline">\ Z</span> คือจุดสิ้นสุดของสตริงทั้งหมด
        (หรือ \ z เพื่อรวมบรรทัดใหม่ ... ซึ่งเป็น gotcha อีกอัน!)'
    any:
      title: ได้รับ.
      description: '<span class="code-inline">.any?</span> ไม่ได้หมายความว่า &quot;องค์ประกอบใด
        ๆ &quot;! ด้วยบล็อก: &quot;ทำบล็อกให้เป็นจริงหรือไม่&quot; โดยไม่ต้อง: &quot;มีความจริงใด
        ๆ ?&quot; มีบล็อกโดยนัย: <span class="code-inline">{ |element| element }</span>'
    undef:
      title: "(ยกเลิก) Def Leppard"
      description: ตัวแปรที่ประกาศในบล็อกที่ส่งผ่านไปยังตัววนซ้ำ (เช่นเวลาหรือแต่ละอัน)
        จะไม่ถูกกำหนดที่ด้านบนของการวนซ้ำแต่ละครั้ง! Iterators เรียกบล็อกนั้นซ้ำ ๆ ดังนั้น
        vars จะอยู่นอกขอบเขตอีกครั้งหลังจากการโทรแต่ละครั้ง โครงสร้างการวนลูปในตัว (เช่นในขณะที่หรือเพื่อ)
        ใช้ได้ (หรือประกาศ vars ก่อนการบล็อก)
    freeze:
      title: แช่แข็ง (Ar) ray
      description: การแช่แข็งอาร์เรย์ (หรือแฮช) ค้างไว้ไม่ใช่รายการที่มีอยู่ สามารถแก้ไขสตริงได้
        วิธีนี้คุณสามารถปรับเปลี่ยนสล็อตที่กำหนดใน Array of Strings ที่ถูกตรึง
    one_is_one:
      title: 1 คือ 1 …และอีกมากจะเป็นเช่นนั้น!
      description: 'การเปลี่ยน Fixnum เป็นค่าใหม่หมายถึงวัตถุใหม่ พวกเขาไม่สามารถแก้ไขได้ในสถานที่!
        ดังนั้นไม่สามารถแก้ไข Array of Fixnums ที่แช่แข็งได้ (Fixnums and Integers ไม่มีวิธีการสาธิตให้ทดลองใช้)
        BTW: <span class="code-inline">object_id</span> ของ Fixnum คือ <span class="code-inline">value
        * 2 + 1</span>'
    bang:
      title: "(ถึง! ||! ถึง!) ==?"
      description: แบงทำเครื่องหมายว่าอันตราย ทำไม? บ่อยครั้งที่อาจแก้ไขตัวรับกับเวอร์ชันที่ไม่ใช่การดัดแปลง
        อย่าพึ่งพาค่าตอบแทนในลักษณะเดียวกันกับที่ไม่ใช่เวอร์ชั่น! ไม่มีผลตอบแทนมากมายหากไม่มีการเปลี่ยนแปลงที่จำเป็น!
    array:
      title: Array of New Gotchas
      description: ค่าเริ่มต้นที่กำหนดเป็นวัตถุเป็นวัตถุเดียวกันสำหรับแต่ละช่อง! การกลายพันธุ์หนึ่งกลายพันธุ์เริ่มต้นสำหรับทุกคน
        ค่าเริ่มต้นที่กำหนดเป็นบล็อกได้รับการประเมินแยกกันสำหรับแต่ละช่อง ใช้สิ่งนี้เพื่อสร้าง
        vars ใหม่สำหรับแต่ละ
    hash:
      title: ทำแฮชจากมัน
      description: 'ส่วนใหญ่ปัญหาเดียวกัน (และวิธีแก้ไข) เป็นอาร์เรย์ GOTCHAS เพิ่มเติม:
        สร้างวัตถุใหม่ในการเข้าถึงช่องว่าง! อาจสร้างวัตถุใหม่จำนวนมากเกินไป ซากปรักหักพังการตรวจสอบเนื้อหา
        &quot;ของจริง&quot; หรือจำนวน (ไม่มีการตรวจสอบ,. ขนาด ฯลฯ )'
    rescue:
      title: ช่วยชีวิตฉันโยนสายฉันจะพยายามจับมัน!
      description: ในรูบีการขว้างปาและจับไม่ได้เป็นข้อยกเว้น! พวกเขาคือการควบคุมการไหลขั้นสูงเพื่อออกจากการทำรังลึก
        Ruby ใช้การเพิ่มและช่วยเหลือสำหรับข้อยกเว้น
    to_str:
      title: to_s VS to_str
      description: '<span class="code-inline">to_s</span> ถูกกำหนดในทุกวัตถุและจะส่งคืนบางสิ่งบางอย่างเสมอ
        <span class="code-inline">to_str</span> ถูกกำหนดบนวัตถุที่มีลักษณะเป็นสตริงเท่านั้น
        ตัวอย่างเช่น <span class="code-inline">Symbol</span> มี <span class="code-inline">to_str</span>
        แต่ <span class="code-inline">Array</span> ไม่ได้ ดังนั้นคุณสามารถใช้ <span
        class="code-inline">obj.respond_to?(:to_str)</span> แทน <span class="code-inline">obj.is_a?(String)</span>
        หากคุณต้องการใช้ประโยชน์จากการพิมพ์เป็ดโดยไม่ต้องกังวลว่าคลาสที่คุณทำงานด้วยนั้นเป็นคลาสย่อยของ
        <span class="code-inline">String</span> หรือ ไม่.'
    missing:
      title: จำเป็นต้องประสานงาน method_missing และ response_to_missing หรือไม่
      description: 'เมื่อแทนที่ <span class="code-inline">method_missing</span> โปรดอย่าลืมการ
        <span class="code-inline">respond_to_missing?</span> เช่นกัน เมื่อคุณใช้ method_missing
        เพื่อให้อ็อบเจกต์คืนค่าบางอย่างในการเรียกเมธอดให้ตรวจสอบให้แน่ใจว่าคุณได้กำหนด
        หากคุณไม่ทำมันจะไม่มีอะไรเกิดขึ้นในแวบแรก แต่คุณจะเจอกับปัญหาในที่สุด พิจารณาคลาสนี้:'
      respond_to: 'มีโค้ดจำนวนมาก (อัญมณีหรือของคุณเอง) ที่ต้องพึ่งพา respons_to? (สำหรับเหตุผลที่ดี)
        คุณต้องการแพทช์ respons_to_missing หรือไม่? เช่นกัน:'
    exception:
      title: การช่วยเหลือจาก StandardError ไม่ใช่ข้อยกเว้น
      description: 'ไม่ช่วยกู้ข้อยกเว้นช่วยชีวิต StandardError ก่อนที่จะช่วยกู้ข้อยกเว้นอย่างชัดเจนจะช่วยได้แม้จะไม่ใช่ข้อผิดพลาดที่สามารถกู้คืนได้เช่น
        SyntaxError, LoadError และ Interrupt หากคุณไม่ใช้ตัวระบุประเภทข้อยกเว้น Ruby
        จะตรวจจับเฉพาะ StandardError ซึ่งอาจเป็นสิ่งที่คุณต้องการ:'
    private:
      title: ข้อมูลส่วนตัวไม่ได้เป็นอย่างนั้นจริง ๆ และไม่ใช่วิธีการเรียนแบบ W
      description: มีวิธีที่จะทำให้วิธีการเรียนเป็นส่วนตัวใน Ruby คุณเพียงแค่ต้องผ่านห่วงบางอย่าง
        เอ่อฉันหมายถึงใช้ <span class="code-inline">class << self</span> ไวยากรณ์ของ
        ตัวเอง ความผิดปกตินี้ผลักดันอินสแตนซ์ซิงเกิลลงบนคลาสเพื่อสร้างวิธีการเรียนอย่างมีประสิทธิภาพ
    braces:
      title: วงเล็บปีกกาเทียบกับการทำ
      description: หลักการทั่วไปคือการใช้ <span class="code-inline">do .. end</span>
        สำหรับบล็อกหลายบรรทัดและเครื่องหมายปีกกาสำหรับบล็อกบรรทัดเดียว แต่ก็มีความแตกต่างระหว่างทั้งสองที่สามารถแสดงได้
        ซึ่งหมายความว่า <span class="code-inline">{}</span> มีลำดับความสำคัญสูงกว่า
        <span class="code-inline">do .. end</span> ดังนั้นโปรดระลึกไว้เสมอเมื่อตัดสินใจว่าคุณต้องการใช้อะไร
    module:
      title: 'class Foo :: Bar ซึ่งนิยามอยู่นอก Module Foo จะไม่เห็นข้างใน Foo'
      description: คุณสามารถนึกถึงลักษณะที่ปรากฏของ <span class="code-inline">module Something</span>,
        <span class="code-inline">class Something</span> หรือ <span
        class="code-inline">def something</span> ที่เป็น &quot;เกตเวย์&quot; ในขอบเขตใหม่
        เมื่อ Ruby กำลังค้นหาคำจำกัดความของชื่อที่ถูกอ้างอิงก่อนจะดูในขอบเขตปัจจุบัน
        (เมธอดคลาสหรือโมดูล) และหากไม่พบตำแหน่งที่จะย้อนกลับผ่านแต่ละรายการที่มี &quot;เกตเวย์&quot;
        และการค้นหา ขอบเขตที่นั่น
    credits: 'รหัสและบทความถูกนำมาจากแหล่งข้อมูล:'
  meta_programming:
    title: metaprogramming
    description: Metaprogramming คือการเขียนโปรแกรมคอมพิวเตอร์ที่เขียนหรือจัดการโปรแกรมอื่น
      ๆ (หรือตัวเอง) เป็นข้อมูลของพวกเขาหรือที่เป็นส่วนหนึ่งของงานในเวลารวบรวมที่จะทำที่รันไทม์
      ในหลายกรณีสิ่งนี้ช่วยให้โปรแกรมเมอร์สามารถทำงานได้มากขึ้นในเวลาเดียวกันตามที่พวกเขาใช้ในการเขียนโค้ดทั้งหมดด้วยตนเองหรือให้โปรแกรมที่มีความยืดหยุ่นมากขึ้น
      Metaprogramming กำลังเขียนโค้ดที่เขียนโค้ดระหว่างรันไทม์เพื่อทำให้ชีวิตของคุณง่ายขึ้น
    dynamic_dispatch:
      title: การจัดส่งแบบไดนามิก
      description: ช่วยให้เราสามารถส่งข้อความ <span class="code-inline">หัวเรื่อง public_send
        (ข้อความ, ข้อโต้แย้ง *)</span>
    dynamic_method:
      title: วิธีการแบบไดนามิก
      description: 'ช่วยให้เราสามารถสร้างวิธีการ <span class="code-inline">define_method:
        method_name {block ที่กลายเป็นวิธีร่างกาย}</span> แบบไดนามิก'
    ghost_methods:
      title: วิธีการผี
      description: การจับ &quot;วิธีการผี&quot; และส่งต่อไปยังวิธีอื่นในขณะที่อาจเพิ่มตรรกะรอบการโทร
        ใช้ <span class="code-inline">method_missing</span>
    dynamic_proxies:
      title: ผู้รับมอบฉันทะแบบไดนามิก
      description: 'ตัวอย่างเช่นคุณสามารถให้วิธีการในจินตนาการโดยใช้ <span class="code-inline">method_missing</span>
        เพื่อแยกวิเคราะห์ข้อความขาเข้า (เช่น <span class="code-inline">get_name</span>
        , <span class="code-inline">get_age</span> ) และมอบอำนาจให้วิธีอื่นเช่น <span
        class="code-inline">get (: data_type)</span> โดยที่ <span class="code-inline">:
        data_type</span> คือ <span class="code-inline">: name</span> หรือ <span class="code-inline">:
        age</span>'
      more: หาก (หลังจากการวิเคราะห์) คุณค้นพบปัญหาด้านประสิทธิภาพด้วยการใช้ <span class="code-inline">method_missing</span>
        คุณสามารถใช้เทคนิค &quot;วิธีการแบบไดนามิก&quot; เพื่อสร้างวิธีการจริงหลังจากได้รับข้อความจาก
        &#39;method_missing` เป็นครั้งแรก
  solid_principles:
    good: ดี!
    bad: ไม่ดี!
    title: หลักการที่มั่นคง
    description: ในการเขียนโปรแกรมคอมพิวเตอร์ SOLID (ความรับผิดชอบเดี่ยว, เปิด - ปิด,
      Liskov แทน, การแยกส่วนต่อประสาน, และการผกผันของการพึ่งพาอาศัย) เป็นคำย่อช่วยจำที่แนะนำโดย
      Michael Feathers สำหรับ &quot;หลักการห้าประการแรก&quot; ที่ตั้งชื่อโดย Robert
      C. Martin ในช่วงต้นทศวรรษ สำหรับห้าหลักการพื้นฐานของการเขียนโปรแกรมและการออกแบบเชิงวัตถุ
      ความตั้งใจคือหลักการเหล่านี้เมื่อนำมาใช้ร่วมกันจะทำให้มีโอกาสมากขึ้นที่โปรแกรมเมอร์จะสร้างระบบที่ง่ายต่อการบำรุงรักษาและขยายเวลา
      หลักการของ SOLID เป็นแนวทางที่สามารถนำไปใช้ในขณะที่ทำงานกับซอฟต์แวร์เพื่อลบกลิ่นรหัสโดยทำให้โปรแกรมเมอร์ทำการ
      refactor ซอร์สโค้ดของซอฟต์แวร์จนกว่าจะสามารถอ่านได้และขยายได้ มันเป็นส่วนหนึ่งของกลยุทธ์โดยรวมของการพัฒนาซอฟต์แวร์ที่คล่องตัวและปรับตัวได้
    single:
      title: หลักการความรับผิดชอบเดี่ยว
      description: หลักการความรับผิดชอบเดียวคือนามธรรมที่สุดของพวง มันช่วยให้ชั้นเรียนและวิธีการเล็กและบำรุงรักษาได้
        นอกเหนือจากการทำให้ชั้นเรียนมีขนาดเล็กและเน้นไปที่มันแล้วยังทำให้เข้าใจง่ายขึ้นตัวอย่างของสิ่งนี้อาจเพิ่มการสนับสนุนสำหรับการส่งอีเมลสรุปค่าคอมมิชชั่นของบุคคลที่เฉพาะเจาะจง
        ความจริงที่ว่าเราสามารถระบุสาเหตุได้หลายประการเพื่อส่งสัญญาณการละเมิดหลักการความรับผิดชอบเดี่ยว
    open_close:
      title: หลักการเปิด / ปิด
      description: หลักการเปิด / ปิดระบุว่าคลาสหรือวิธีการควรเปิดเพื่อขยาย แต่ปิดเพื่อการปรับเปลี่ยน
        สิ่งนี้บอกเราว่าเราควรมุ่งมั่นเพื่อการออกแบบแบบแยกส่วนที่ทำให้เราสามารถเปลี่ยนพฤติกรรมของระบบได้โดยไม่ต้องทำการดัดแปลงชั้นเรียนด้วยตนเอง
        โดยทั่วไปจะทำได้โดยใช้รูปแบบเช่นรูปแบบกลยุทธ์
      after: ด้วยการปรับเปลี่ยนนี้เราได้ทำให้สามารถเพิ่มตัวแยกวิเคราะห์ใหม่โดยไม่ต้องเปลี่ยนรหัสใด
        ๆ พฤติกรรมเพิ่มเติมใด ๆ จะต้องมีการเพิ่มตัวจัดการใหม่เท่านั้น สิ่งนี้ทำให้ FileParser
        ของเราสามารถนำกลับมาใช้ใหม่ได้และในหลาย ๆ กรณีจะทำให้เราปฏิบัติตามหลักการความรับผิดชอบเดี่ยวด้วยการสนับสนุนให้เราสร้างคลาสที่เล็กลง
    liskov:
      title: หลักการทดแทนของ Liskov
      description: หลักการของ Liskov นั้นยากที่จะเข้าใจ หลักการระบุว่าคุณควรจะสามารถแทนที่อินสแตนซ์ใด
        ๆ ของคลาสพาเรนต์ด้วยอินสแตนซ์ของลูกใดลูกหนึ่งของมัน
    segregation:
      title: หลักการผกผันของการพึ่งพา
      description: 'หลักการระบุว่าลูกค้าไม่ควรถูกบังคับให้พึ่งพาวิธีการที่ไม่ได้ใช้
        ในตัวอย่างนี้มีคลาสคอมพิวเตอร์โปรแกรมเมอร์และช่างเทคนิค ทั้งโปรแกรมเมอร์และช่างเทคนิคใช้คอมพิวเตอร์ในวิธีที่ต่างกัน
        โปรแกรมเมอร์ใช้คอมพิวเตอร์ในการพิมพ์ แต่ช่างรู้วิธีเปลี่ยนฮาร์ดไดรฟ์ของคอมพิวเตอร์
        สิ่งที่ Interface Segregation Principle (ISP) บังคับใช้คือคลาสหนึ่งไม่ควรขึ้นอยู่กับวิธีการที่ไม่ได้ใช้
        ในกรณีของเราโปรแกรมเมอร์นั้นเชื่อมต่อกับคอมพิวเตอร์ # change_hard_drive วิธีโดยไม่จำเป็นเพราะมันไม่ได้ใช้
        แต่สถานะการเปลี่ยนแปลงที่วิธีการบังคับใช้นี้สามารถส่งผลกระทบต่อโปรแกรมเมอร์
        มาสร้างรหัสอีกครั้งเพื่อเชื่อฟัง LSP'
      after: หลังจาก refactor นี้ช่างเทคนิคใช้วัตถุที่แตกต่างจากประเภท ComputerInternals
        ซึ่งแยกได้จากสถานะของคอมพิวเตอร์ สถานะของวัตถุคอมพิวเตอร์สามารถได้รับอิทธิพลจากโปรแกรมเมอร์
        แต่การเปลี่ยนแปลงจะไม่ส่งผลกระทบต่อช่างเทคนิค แต่อย่างใด
    di:
      title: หลักการผกผันของการพึ่งพา
      description: หลักการการพึ่งพาการพึ่งพาเกี่ยวข้องกับวัตถุระดับสูง (คิดว่าตรรกะทางธุรกิจ)
        ซึ่งไม่ขึ้นอยู่กับรายละเอียดการใช้งานระดับต่ำ (คิดว่าการสืบค้นฐานข้อมูลและ IO)
        รายละเอียด สิ่งนี้สามารถทำได้ด้วยการพิมพ์เป็ดและหลักการผกผันการพึ่งพา บ่อยครั้งที่รูปแบบนี้ถูกใช้เพื่อให้บรรลุหลักการเปิด
        / ปิดที่เรากล่าวถึงข้างต้น ในความเป็นจริงเราสามารถนำตัวอย่างเดียวกันกลับมาใช้ใหม่เพื่อสาธิตหลักการนี้ได้
        ขณะนี้มีคลาสตัวจัดรูปแบบ แต่ฉันฮาร์ดโค้ดลงในคลาส Report ดังนั้นจึงสร้างการพึ่งพาจากรายงานไปยัง
        JSONFormatter เนื่องจากรายงานเป็นแนวคิดที่เป็นนามธรรม (ระดับสูง) มากกว่า JSONFormatter
        เราจึงทำลาย DIP ได้อย่างมีประสิทธิภาพ
      after: วิธีนี้รายงานไม่ขึ้นอยู่กับ JSONFormatter และสามารถใช้ฟอร์แมตเตอร์ชนิดใดก็ได้ที่มีเมธอดที่เรียกว่ารูปแบบ
        (ซึ่งรู้จักกันในชื่อการพิมพ์เป็ด) สิ่งที่ควรทราบอีกประการหนึ่งคือเราได้ใช้การฉีดพึ่งพาเพื่อแก้ปัญหาอีกครั้ง
        เทคนิคนี้เป็นสิ่งที่ทรงพลังมากเมื่อเป้าหมายของเราคือแยกวัตถุออกและแม้ว่ามันจะมีชื่อย่อเหมือนกับหลักการพึ่งพาการพึ่งพา
        (รูปแบบการฉีดขึ้นต่อกันของการพึ่งพา) แต่ก็เป็นแนวคิดที่ต่างกัน
  threads:
    example: ตัวอย่าง
    title: หัวข้อ
    description: 'หมายเหตุเกี่ยวกับการขนานและการทำงานพร้อมกัน: ความแตกต่างหลักระหว่างการใช้กระบวนการกับเธรดคือวิธีการจัดการหน่วยความจำ
      ในระดับสูงประมวลผลหน่วยความจำในขณะที่เธรดแชร์หน่วยความจำ สิ่งนี้ทำให้กระบวนการวางไข่ช้าลงกว่าการวางไข่ของเธรดและนำไปสู่กระบวนการที่ใช้ทรัพยากรมากขึ้นเมื่อทำงาน
      โดยรวมแล้วเธรดจะมีค่าใช้จ่ายน้อยกว่ากระบวนการ Thread API นี้เป็น Ruby API ฉันพูดเป็นนัย
      ๆ ว่าการใช้งานทับทิมที่แตกต่างกันมีพฤติกรรมการทำเกลียวที่แตกต่างกัน'
    green:
      title: หัวข้อสีเขียว
      description: Ruby 1.9 แทนที่เธรดสีเขียวด้วยเธรดดั้งเดิม อย่างไรก็ตาม GIL ยังคงป้องกันการขนาน
        ที่ถูกกล่าวว่าการทำงานพร้อมกันได้รับการปรับปรุงผ่านการตั้งเวลาที่ดีขึ้น กำหนดเวลาใหม่ทำให้การตัดสินใจเปลี่ยนบริบทมีประสิทธิภาพมากขึ้นโดยการย้ายเธรดเหล่านั้นไปยังเธรดเนทีฟที่แยกต่างหาก
    gil:
      title: GIL - ล็อคล่ามระดับโลก
      description: MRI มีการล็อคล่ามทั่วโลก (GIL) มันเป็นล็อคการทำงานของรหัส Ruby ซึ่งหมายความว่าในบริบทที่มีหลายเธรดเธรดเดียวเท่านั้นที่สามารถเรียกใช้โค้ด
        Ruby ได้ในแต่ละครั้งดังนั้นหากคุณมี 8 เธรดที่ทำงานบนเครื่อง 8-core อย่างต่อเนื่องเธรดเดียวเท่านั้น
        . GIL มีอยู่เพื่อปกป้องทับทิมจากสภาพการแข่งขันที่อาจทำให้ข้อมูลเสียหาย มีคำเตือนและการปรับให้เหมาะสม
        แต่นี่เป็นส่วนสำคัญ
      example: ความจริงง่ายๆนี้คือสิ่งที่ทำให้เธรดมีประสิทธิภาพมากและทำให้ยากต่อการทำงาน
        ฉันได้ให้ความคิดแก่คุณแล้วว่าทำไมเธรดถึงดี นี่เป็นโปรแกรมง่ายๆที่แสดงให้เห็นถึงความยากลำบากของพวกเขา
        ที่นี่คุณจะเห็นว่าเรามีองค์ประกอบ <span class="code-inline">10 * 10000</span>
        ในอาร์เรย์ โปรดทราบว่าทับทิมที่ต่างกันสามารถแสดงผลลัพธ์ที่ต่างกันได้ GIL มีอยู่ใน
        MRI ruby เท่านั้น
    mutex:
      title: Mutex - การดำเนินการร่วมกัน
      description: Mutexes จัดเตรียมกลไกสำหรับหลายเธรดเพื่อซิงโครไนซ์การเข้าถึงส่วนสำคัญของโค้ด
        ในคำอื่น ๆ พวกเขาช่วยนำคำสั่งบางอย่างและรับประกันบางอย่างไปสู่โลกของความสับสนวุ่นวายแบบมัลติเธรดชื่อ
        &#39;mutex&#39; นั้นย่อมาจากคำว่า &#39;mutex&#39; หากคุณตัดส่วนบางส่วนของรหัสของคุณด้วย
        mutex คุณรับประกันได้ว่าไม่มีสองเธรดที่สามารถเข้าสู่ส่วนนั้นได้ในเวลาเดียวกัน
        Mutexes จัดเตรียมกลไกสำหรับหลายเธรดเพื่อซิงโครไนซ์การเข้าถึงส่วนสำคัญของโค้ด
        มันช่วยนำคำสั่งบางอย่างและรับประกันบางอย่างเพื่อโลกของความสับสนวุ่นวายแบบมัลติเธรด
      example: ในโปรแกรมนี้เนื่องจากเธรดใด ๆ ต้องล็อค mutex ก่อนที่จะสามารถส่งไปยัง
        Array ได้จึงรับประกันได้ว่าจะไม่มีเธรดสองเธรดดำเนินการในเวลาเดียวกัน กล่าวอีกนัยหนึ่งการดำเนินการนี้ไม่สามารถถูกขัดจังหวะอีกต่อไปก่อนที่จะเสร็จสมบูรณ์
        เมื่อเธรดหนึ่งเริ่มผลักไปที่อาร์เรย์จะไม่มีเธรดอื่นใดที่สามารถป้อนส่วนของโค้ดนั้นได้จนกว่าเธรดแรกจะเสร็จสิ้น
        ตอนนี้การดำเนินการนี้ปลอดภัยสำหรับเธรด ที่นี่คุณจะเห็นว่าเรามีองค์ประกอบ <span
        class="code-inline">10 * 10000</span> ในอาร์เรย์ ตอนนี้ทุกอย่างเหมือนกันเพราะ
        mutex mutex ตั้งค่าขอบเขตเดียวกันสำหรับเธรด เธรดแรกที่พบรหัสบิตนี้จะล็อก mutex
        จากนั้นจะกลายเป็นเจ้าของ mutex นั้น จนกว่าเธรดที่เป็นเจ้าของจะปลดล็อก mutex
        จะไม่มีเธรดอื่นที่สามารถล็อกได้
    fibers:
      title: เส้นใย
      description: เส้นใยเป็นพื้นฐานสำหรับการใช้งานพร้อมกันน้ำหนักเบาสหกรณ์ในทับทิม
        โดยพื้นฐานแล้วมันเป็นวิธีการสร้างบล็อคโค้ดที่สามารถหยุดชั่วคราวและทำงานต่อได้เหมือนกับเธรด
        ความแตกต่างที่สำคัญคือพวกเขาจะไม่ถูกจองล่วงหน้าและการตั้งเวลาจะต้องทำโดยโปรแกรมเมอร์และไม่ใช่
        VM ซึ่งแตกต่างจากรุ่นอื่น ๆ ที่ใช้งานพร้อมกันน้ำหนักเบาแบบไม่ซ้อนกันแต่ละเส้นใยมาพร้อมกับ
        4KB ขนาดเล็ก สิ่งนี้ทำให้ไฟเบอร์ถูกหยุดชั่วคราวจากการเรียกฟังก์ชันที่ซ้อนกันอย่างลึกล้ำภายในบล็อกไฟเบอร์
    rails:
      title: รางความปลอดภัยด้าย
      description: ปัญหาของเรื่องนี้ก็คือไม่มีวิธีง่ายๆที่จะพูดด้วยความมั่นใจแน่นอนว่าแอปโดยรวมนั้นปลอดภัยต่อเธรด
      global_variables: ตัวแปรทั่วโลกเป็นระดับโลก ซึ่งหมายความว่าพวกเขาแบ่งปันระหว่างเธรด
        หากคุณไม่มั่นใจว่าจะไม่ใช้ตัวแปรทั่วโลกในตอนนี้นี่เป็นอีกเหตุผลที่จะไม่แตะต้องพวกเขา
        หากคุณต้องการแชร์บางสิ่งทั่วโลกผ่านแอปคุณมีแนวโน้มที่จะได้รับบริการที่ดีกว่า
        (แต่ดูด้านล่าง)
      class_variables: ตัวแปรคลาส สำหรับวัตถุประสงค์ของการสนทนาเกี่ยวกับเธรดตัวแปรคลาสไม่แตกต่างจากตัวแปรโกลบอลมากนัก
        พวกเขาใช้ร่วมกันข้ามเธรดในลักษณะเดียวกันปัญหาไม่มากเกี่ยวกับการใช้ตัวแปรคลาส
        แต่เกี่ยวกับการกลายพันธุ์เหล่านั้น และถ้าคุณจะไม่กลายพันธุ์ตัวแปรคลาสในหลายกรณีค่าคงที่จะเป็นตัวเลือกที่ดีกว่า
      instance_variables: ตัวแปรอินสแตนซ์ของคลาส แต่บางทีคุณอาจอ่านว่าคุณควรใช้ตัวแปรอินสแตนซ์ของคลาสแทนตัวแปรคลาสใน
        Ruby บางทีคุณควรจะ แต่พวกเขาเป็นเพียงปัญหาสำหรับเธรดโปรแกรมเป็นตัวแปรคลาส
      memoization: 'การบันทึกด้วยตัวเองไม่ใช่ปัญหาความปลอดภัยของเธรด มักใช้เพื่อเก็บข้อมูลในตัวแปรคลาสหรือตัวแปรอินสแตนซ์ของคลาส
        (ดูจุดก่อนหน้า) ในความเป็นจริงการดำเนินการสองตัว <span class="code-inline">|
        | =</span> เป็นสองการดำเนินงานดังนั้นจึงมีการสลับบริบทที่อาจเกิดขึ้นที่อยู่ตรงกลาง
        ดังนั้นแม้ว่าคุณจะใช้ตัวแปรอินสแตนซ์เท่านั้นคุณอาจสิ้นสุดด้วยเงื่อนไขการแข่งขันพร้อมการบันทึก
        อย่าบันทึกความจำให้กับตัวแปรคลาสหรือตัวแปรอินสแตนซ์ของคลาส หากคุณต้องการบันทึกสิ่งที่อยู่ในระดับคลาสให้ใช้ตัวแปรโลคัลเธรด
        (<span class="code-inline">Thread.current[:baz]</span>) แทน อย่างไรก็ตามโปรดระวังว่ามันยังคงเป็นตัวแปรทั่วโลก'
    config:
      title: กำหนดค่า threadsafe!?
      description: การเรียกวิธีนี้ตั้งสี่ตัวเลือกในการกำหนดค่าแอพของเรา ลองทำตามตัวเลือกและพูดคุยเกี่ยวกับสิ่งที่มันทำ
      frameworks: 'Preloading Frameworks: ตัวเลือกแรก @preload_frameworks ทำสิ่งที่กล่าวไว้มากมันบังคับให้
        Rails framework โหลดอย่างกระตือรือร้นในการบู๊ต เมื่อไม่ได้เปิดใช้งานตัวเลือกนี้คลาสของเฟรมเวิร์กจะโหลดอย่างเกียจคร้านผ่านทาง
        autoload ในสภาพแวดล้อมแบบมัลติเธรดกรอบงานจำเป็นต้องโหลดอย่างกระตือรือร้นก่อนที่จะสร้างเธรดใด
        ๆ เนื่องจากปัญหาความปลอดภัยของเธรดที่มีการโหลดอัตโนมัติ เรารู้ว่าการโหลดเฟรมเวิร์กไม่ใช่
        threadsafe ดังนั้นกลยุทธ์คือการโหลดทั้งหมดก่อนที่เธรดใด ๆ จะพร้อมที่จะจัดการกับคำขอ'
      cache: 'แคชคลาส: ตัวเลือก @cache_classes ควบคุมว่าคลาสจะโหลดใหม่หรือไม่ จำตอนที่คุณกำลังทำ“
        TDD” ในใบสมัครของคุณ? คุณปรับเปลี่ยนคอนโทรลเลอร์จากนั้นโหลดหน้าซ้ำเพื่อ“ ทดสอบ”
        และดูว่าสิ่งต่าง ๆ เปลี่ยนไปหรือไม่ ใช่นั่นคือสิ่งที่ตัวเลือกนี้ควบคุม เมื่อตัวเลือกนี้เป็นเท็จเช่นเดียวกับในการพัฒนาชั้นเรียนของคุณจะถูกโหลดใหม่เมื่อพวกเขาได้รับการแก้ไข
        หากไม่มีตัวเลือกนี้เราจะไม่สามารถทำ“ F5DD” ของเราได้ (ใช่นั่นคือการพัฒนาแบบขับเคลื่อนด้วย
        F5) ในการผลิตเรารู้ว่าคลาสจะไม่ได้รับการแก้ไขในทันทีดังนั้นการทำงานเพื่อค้นหาว่าการโหลดคลาสซ้ำนั้นเป็นเพียงการสิ้นเปลืองทรัพยากรหรือไม่'
      di: 'การโหลดการพึ่งพา: ตัวเลือกนี้ @dependency_loading การควบคุมการโหลดรหัสเมื่อพบค่าคงที่ที่ขาดหายไป
        ตัวอย่างเช่นตัวควบคุมอ้างอิงรุ่นผู้ใช้ แต่ค่าคงที่ผู้ใช้ไม่ได้กำหนดไว้ ในกรณีนั้นหาก
        @dependency_loading เป็นจริง Rails จะค้นหาไฟล์ที่มีค่าคงที่ของผู้ใช้และโหลดไฟล์นั้น
        เราได้พูดคุยกันแล้วว่าการโหลดโค้ดไม่ปลอดภัยต่อเธรดดังนั้นแนวคิดในที่นี้คือเราควรโหลดเฟรมเวิร์กจากนั้นโหลดรหัสผู้ใช้ทั้งหมดจากนั้นปิดการโหลดการอ้างอิง
        เมื่อการโหลดการพึ่งพาถูกปิดใช้งานโค้ดเฟรมเวิร์กและโค้ดแอพควรถูกโหลดและค่าคงที่ที่หายไปใด
        ๆ จะเพิ่มข้อยกเว้นแทนที่จะพยายามโหลดรหัส เราปรับการปิดใช้งานตัวเลือกนี้ในการผลิตเนื่องจากการโหลดรหัส
        (ตามที่กล่าวไว้ก่อนหน้านี้ไม่ใช่ threadsafe และเราคาดว่าจะมีการโหลดรหัสทั้งหมดก่อนที่เธรดใด
        ๆ จะสามารถจัดการคำขอ'
      concurrency: 'การอนุญาตการทำงานพร้อมกัน: @allow_concurrency ตัวเลือกควบคุมว่าจะใช้มิดเดิลแวร์
        Rack :: Lock ในสแต็กของคุณหรือไม่ ชั้นวาง :: ล็อคล้อม mutex รอบคำขอของคุณ แนวคิดที่ว่าถ้าคุณมีรหัสที่ไม่ใช่
        threadsafe, mutex นี้จะป้องกันไม่ให้หลายเธรดดำเนินการรหัสคอนโทรลเลอร์ของคุณในเวลาเดียวกัน
        เมื่อ threadsafe! มีการตั้งค่ามิดเดิลแวร์นี้จะถูกลบและรหัสของตัวควบคุมสามารถทำงานแบบขนานได้'
    credits: 'รหัสและบทความถูกนำมาจากแหล่งข้อมูล:'
  ruby_meister:
    title: กลายเป็น Ruby Meister
    description: ในการพูดคุยนี้เราจะตรวจสอบการเดินทางที่ยาวนานจากการเป็นสามเณรทับทิมเพื่อให้ได้ผู้เชี่ยวชาญทับทิมที่แท้จริงและจะพยายามทำให้มันสั้นลงสำหรับคุณโดยการแบ่งปันข้อมูลเชิงลึกที่สำคัญบางอย่าง
      Master Rubyist มีรากฐานทางทฤษฎีที่ยอดเยี่ยมอาศัยกล่องเครื่องมือที่กว้างขวางมีความเข้าใจอย่างลึกซึ้งเกี่ยวกับค่านิยมหลักและหลักการของ
      Ruby และยังคงฝึกฝนทักษะของพวกเขาอยู่เสมอ บางทีคุณกำลังบอกตัวเองว่า &quot;ว้าวนี่มันค่อนข้างคลุมเครือ!&quot;
      แต่ถ้าคุณเข้าร่วมเซสชั่นนี้ฉันสัญญาว่าคุณจะรู้แจ้งขบขันและคุณจะสนุกไปกับมัน! ฟังดูเข้าท่า?
      หนังสือที่ยอดเยี่ยมจะเป็นส่วนหนึ่งของแหล่งข้อมูลที่ฉันแนะนำให้ผู้คนยกระดับทักษะของพวกเขา
    video: การเดินทางอันยาวนานสู่ Ruby Mastery โดย Bozhidar Batsov
    computer_science_fundamentals:
      title: พื้นฐานวิทยาศาสตร์คอมพิวเตอร์
      articles:
        - name: inside_machine
          title: 'ภายในเครื่อง: คำแนะนำเบื้องต้นเกี่ยวกับไมโครโปรเซสเซอร์และสถาปัตยกรรมคอมพิวเตอร์'
          description: คอมพิวเตอร์ดำเนินงานนับไม่ถ้วนตั้งแต่ธุรกิจที่สำคัญไปจนถึงการพักผ่อนหย่อนใจ
            แต่ไม่ว่าพวกเขาจะมีลักษณะและพฤติกรรมแตกต่างกันอย่างไรพวกเขาล้วนมีความคล้ายคลึงกันในฟังก์ชั่นพื้นฐาน
            เมื่อคุณเข้าใจว่าไมโครโปรเซสเซอร์ - หรือหน่วยประมวลผลกลาง (CPU) - ทำงานอย่างไรคุณจะได้เข้าใจแนวคิดพื้นฐานที่เป็นหัวใจสำคัญของการคำนวณสมัยใหม่ทั้งหมด
        - name: code
          title: 'รหัส: ภาษาที่ซ่อนอยู่ของฮาร์ดแวร์คอมพิวเตอร์และซอฟต์แวร์'
          description: ไฟฉายการบุกรุกของอังกฤษแมวดำและกระดานหกทำอะไรกับคอมพิวเตอร์ได้บ้าง?
            ใน CODE พวกเขาแสดงวิธีที่แยบยลที่เราใช้กับภาษาและคิดค้นวิธีการใหม่ในการสื่อสารซึ่งกันและกัน
            และผ่าน CODE เราจะเห็นว่าความฉลาดและการบังคับของมนุษย์ในการสื่อสารได้ขับเคลื่อนนวัตกรรมทางเทคโนโลยีของสองศตวรรษที่ผ่านมาอย่างไร
        - name: concrete_math
          title: 'คณิตศาสตร์คอนกรีต: มูลนิธิวิทยาศาสตร์คอมพิวเตอร์'
          description: หนังสือเล่มนี้แนะนำคณิตศาสตร์ที่สนับสนุนการโปรแกรมคอมพิวเตอร์ขั้นสูงและการวิเคราะห์อัลกอริธึม
            เป้าหมายหลักของผู้เขียนที่รู้จักกันดีคือการให้พื้นฐานที่แข็งแกร่งและเกี่ยวข้องกับทักษะทางคณิตศาสตร์
            - ทักษะที่จำเป็นในการแก้ปัญหาที่ซับซ้อนเพื่อประเมินผลบวกที่น่ากลัว มันเป็นข้อความที่ขาดไม่ได้และการอ้างอิงไม่เพียง
            แต่สำหรับนักวิทยาศาสตร์คอมพิวเตอร์ - ผู้เขียนเองก็ต้องพึ่งพามันเป็นอย่างมาก!
            - แต่สำหรับผู้ใช้คณิตศาสตร์อย่างจริงจังในแทบทุกสาขาวิชา
        - name: sicp
          title: โครงสร้างและการตีความโปรแกรมคอมพิวเตอร์
          description: 'โครงสร้างและการตีความโปรแกรมคอมพิวเตอร์มีผลกระทบอย่างมากต่อหลักสูตรวิทยาการคอมพิวเตอร์ในช่วงทศวรรษที่ผ่านมา
            การแก้ไขที่รอมานานนี้มีการเปลี่ยนแปลงตลอดทั้งข้อความ มีการใช้งานใหม่ของระบบการเขียนโปรแกรมที่สำคัญส่วนใหญ่ในหนังสือรวมถึงล่ามและผู้แปลและผู้เขียนได้รวมการเปลี่ยนแปลงเล็กน้อยจำนวนมากที่สะท้อนถึงประสบการณ์การสอนหลักสูตรที่
            MIT ตั้งแต่ตีพิมพ์ครั้งแรก ชุดรูปแบบใหม่ได้รับการแนะนำที่เน้นบทบาทสำคัญที่เล่นโดยวิธีการที่แตกต่างกันในการจัดการกับเวลาในรูปแบบการคำนวณ:
            วัตถุที่มีสถานะการเขียนโปรแกรมพร้อมกันการเขียนโปรแกรมการทำงานและการประเมินผลที่ขี้เกียจ'
        - name: design_programms
          title: 'วิธีการออกแบบโปรแกรม: ความรู้เบื้องต้นเกี่ยวกับการเขียนโปรแกรมและคอมพิวเตอร์'
          description: การเขียนโปรแกรมเบื้องต้นนี้ทำให้วิทยาการคอมพิวเตอร์เป็นแกนหลักของการศึกษาศิลปศาสตร์
            ไม่เหมือนกับหนังสือแนะนำตัวอื่น ๆ แต่จะเน้นไปที่กระบวนการออกแบบโปรแกรม วิธีนี้ส่งเสริมความหลากหลายของทักษะการอ่านเชิงวิเคราะห์การสังเคราะห์เชิงสร้างสรรค์และการใส่ใจในรายละเอียดที่สำคัญสำหรับทุกคนไม่ใช่แค่โปรแกรมเมอร์คอมพิวเตอร์ในอนาคต
            หนังสือเล่มนี้ตีแผ่ผู้อ่านถึงสองแนวคิดใหม่ที่เป็นพื้นฐาน ก่อนอื่นจะนำเสนอแนวทางการออกแบบโปรแกรมที่แสดงให้ผู้อ่านเห็นวิธีวิเคราะห์คำแถลงปัญหา;
            วิธีกำหนดเป้าหมายที่รัดกุม วิธีทำตัวอย่าง วิธีการพัฒนาโครงร่างของโซลูชันบนพื้นฐานของการวิเคราะห์
            วิธีจบโปรแกรม และวิธีการทดสอบ
        - name: algorithm_manual
          title: คู่มือการออกแบบอัลกอริทึม
          description: รุ่นที่สองที่เพิ่งขยายและปรับปรุงใหม่ของคลาสสิกที่ขายดีที่สุดนี้ยังคงนำ
            &quot;ความลึกลับ&quot; ออกจากการออกแบบอัลกอริธึมและวิเคราะห์ประสิทธิภาพและประสิทธิภาพของพวกเขา
            ตอนนี้หนังสือเล่มนี้ทำหน้าที่เป็นตำราเรียนหลักของทางเลือกสำหรับหลักสูตรการออกแบบอัลกอริธึมและยังคงสถานะเป็นคู่มืออ้างอิงเชิงปฏิบัติขั้นต้นสำหรับอัลกอริทึมสำหรับโปรแกรมเมอร์นักวิจัยและนักเรียน
        - name: cormen
          title: รู้เบื้องต้นเกี่ยวกับอัลกอริทึมรุ่นที่ 3 (The MIT Press)
          description: หนังสือบางเล่มเกี่ยวกับอัลกอริธึมเข้มงวด แต่ไม่สมบูรณ์ อื่น ๆ
            ครอบคลุมมวลของวัสดุ แต่ขาดความเข้มงวด รู้เบื้องต้นเกี่ยวกับอัลกอริทึมที่ไม่ซ้ำกันรวมความแม่นยำและความครอบคลุม
            หนังสือครอบคลุมอัลกอริธึมในเชิงลึกที่หลากหลาย แต่ทำให้ผู้อ่านทุกระดับสามารถเข้าถึงการออกแบบและการวิเคราะห์ของพวกเขาได้
            แต่ละบทค่อนข้างอยู่ในตัวเองและสามารถใช้เป็นหน่วยการเรียนรู้ได้ อัลกอริธึมนั้นอธิบายเป็นภาษาอังกฤษและใน
            pseudocode ที่ออกแบบมาเพื่อให้ทุกคนที่สามารถทำการเขียนโปรแกรมได้สามารถอ่านได้
            คำอธิบายได้รับการรักษาระดับประถมศึกษาโดยไม่ต้องเสียสละความลึกของความคุ้มครองหรือความแม่นยำทางคณิตศาสตร์
        - name: compilers
          title: 'ผู้แต่ง: หลักการเทคนิคและเครื่องมือ (รุ่นที่ 2)'
          description: 'ผู้แต่ง: หลักการเทคนิคและเครื่องมือที่รู้จักกันในนามอาจารย์นักเรียนและนักพัฒนาทั่วโลกในชื่อ
            &quot;Dragon Book&quot; มีวางจำหน่ายในรุ่นใหม่ ทุกบทได้รับการแก้ไขอย่างสมบูรณ์เพื่อสะท้อนถึงการพัฒนาในด้านวิศวกรรมซอฟต์แวร์ภาษาการเขียนโปรแกรมและสถาปัตยกรรมคอมพิวเตอร์ที่เกิดขึ้นตั้งแต่ปีพ.
            ศ. 2529 เมื่อมีการตีพิมพ์ครั้งล่าสุด ผู้เขียนยอมรับว่ามีผู้อ่านเพียงไม่กี่คนเท่านั้นที่จะสร้างคอมไพเลอร์ได้โดยให้ความสำคัญกับปัญหาที่กว้างขึ้นในการออกแบบซอฟต์แวร์และการพัฒนาซอฟต์แวร์'
        - name: c_lang
          title: ภาษาการเขียนโปรแกรม C, 2nd Edition
          description: ผู้เขียนนำเสนอคู่มือฉบับสมบูรณ์เพื่อการเขียนโปรแกรมภาษา C มาตรฐาน
            ANSI รุ่นใหม่นี้เขียนโดยนักพัฒนาของ C ช่วยให้ผู้อ่านติดตามมาตรฐาน ANSI ที่ผ่านการสรุปสำหรับ
            C ในขณะที่แสดงวิธีการใช้ประโยชน์จากชุดตัวดำเนินการที่หลากหลายของ C เศรษฐกิจในการแสดงออกการปรับปรุงการควบคุมการไหลและโครงสร้างข้อมูล
            2 / E ได้รับการเขียนใหม่อย่างสมบูรณ์พร้อมตัวอย่างเพิ่มเติมและชุดปัญหาเพื่อชี้แจงการดำเนินการสร้างภาษาที่ยาก
            เป็นเวลาหลายปีที่โปรแกรมเมอร์ C ได้ให้ K&amp;R แนะนำพวกเขาในการสร้างโปรแกรมที่มีโครงสร้างดีและมีประสิทธิภาพ
            ตอนนี้ความช่วยเหลือเดียวกันนี้มีให้สำหรับผู้ที่ทำงานกับคอมไพเลอร์ ANSI รวมถึงการครอบคลุมรายละเอียดของภาษา
            C รวมทั้งคู่มืออ้างอิงภาษา C อย่างเป็นทางการสำหรับความช่วยเหลือแบบทันทีที่มีสัญลักษณ์ไวยากรณ์การประกาศการเปลี่ยนแปลง
            ANSI กฎขอบเขตและรายการไปเรื่อย ๆ
    oop:
      title: การเขียนโปรแกรมเชิงวัตถุ
      articles:
        - name: growing
          title: การพัฒนาซอฟต์แวร์เชิงวัตถุนำโดยการทดสอบ
          description: 'Test-Driven Development (TDD) ขณะนี้เป็นเทคนิคที่กำหนดขึ้นสำหรับการส่งมอบซอฟต์แวร์ที่ดีขึ้นเร็วขึ้น
            TDD นั้นมาจากแนวคิดง่าย ๆ : เขียนการทดสอบสำหรับโค้ดของคุณก่อนที่คุณจะเขียนโค้ดเอง
            อย่างไรก็ตามความคิดที่ &quot;ง่าย&quot; นี้ต้องใช้ทักษะและวิจารณญาณในการทำสิ่งที่ดี
            ตอนนี้มีแนวทางปฏิบัติที่เป็นประโยชน์ต่อ TDD ที่นำคุณไปสู่แนวความคิดพื้นฐาน
            ด้วยประสบการณ์กว่าทศวรรษในการสร้างระบบโลกแห่งความจริงผู้บุกเบิก TDD สองคนแสดงวิธีให้การทดสอบเป็นแนวทางในการพัฒนาและซอฟต์แวร์“
            เติบโต” ที่สอดคล้องกันเชื่อถือได้และบำรุงรักษาได้'
        - name: domain_driven
          title: 'การออกแบบที่ขับเคลื่อนด้วยโดเมน: การแก้ปัญหาความซับซ้อนในใจกลางของซอฟต์แวร์'
          description: หนังสือเล่มนี้เป็นหนังสือเกี่ยวกับการสร้างแบบจำลองโดเมนในการออกแบบซอฟต์แวร์
            สังคมการพัฒนาซอฟต์แวร์ใช้ชีวิตจากคลื่นลูกหนึ่งไปสู่อีกคลื่นหนึ่ง OOP, รูปแบบ,
            XP, TDD, CI / CD, BigData, DevOps - นี่เป็นเพียงชื่อไม่กี่ หนังสือเล่มนี้มีต้นกำเนิดมาจากยุคทองของ
            OOP ผู้เขียนยอมรับว่ากระบวนทัศน์เชิงวัตถุไม่ได้มีอยู่เพียงอย่างเดียว แต่อคติต่อ
            OOP / OOD นั้นชัดเจน (และสมเหตุสมผล) หนังสือเล่มนี้บอกเกี่ยวกับวิธีการสร้างแบบจำลองของส่วนประกอบซอฟต์แวร์หลัก“
            วิธีที่ถูกต้อง”
    ruby:
      title: รู้ว่าคุณหรั่ง
      articles:
        - name: well_grounded
          title: Rubyist ที่มีเหตุผล
          description: Rubyist ที่มีสายกราวด์รุ่นที่สองกล่าวถึงผู้มาใหม่ถึง Ruby และโปรแกรมเมอร์
            Ruby ที่ต้องการทำความเข้าใจภาษาอย่างลึกซึ้งยิ่งขึ้น ฉบับที่สองที่เขียนอย่างสวยงามและปรับปรุงใหม่ทั้งหมดนี้รวมถึงความครอบคลุมของฟีเจอร์ที่ใหม่ใน
            Ruby 2.1 รวมถึงการขยายและครอบคลุมการอัพเดตในแง่มุมของภาษาที่มีการเปลี่ยนแปลง
        - name: programming_ruby
          title: 'Programming Ruby: คู่มือโปรแกรมเมอร์อย่างจริงจังฉบับที่สอง'
          description: 'Ruby เป็นภาษาโปรแกรมพลวัตเชิงวัตถุที่ได้รับความนิยมมากขึ้นเรื่อย
            ๆ โดยผู้ปฏิบัติงานหลายคนยกย่องว่าเป็นภาษาที่ดีที่สุดและมีประโยชน์มากที่สุดในปัจจุบัน
            เมื่อรูบี้เข้ามาในฉากในโลกตะวันตกครั้งแรกโปรแกรมเมอร์ในระบบ Pragmatic อยู่ที่นั่นพร้อมกับคู่มืออ้างอิงที่ชัดเจน
            Programming Ruby: คู่มือโปรแกรมเมอร์ของ Pragmatic'
        - name: ruby_programming
          title: 'ภาษาการเขียนโปรแกรม Ruby: ทุกสิ่งที่คุณต้องรู้'
          description: 'หนังสือเล่มนี้เริ่มต้นด้วยบทช่วยสอนเริ่มต้นอย่างรวดเร็วสำหรับภาษาจากนั้นอธิบายภาษาโดยละเอียดจากล่างขึ้นบน:
            จากโครงสร้างคำศัพท์และวากยสัมพันธ์ไปจนถึงประเภทข้อมูลไปจนถึงประเภทข้อมูลไปยังนิพจน์และข้อความและผ่านวิธีการบล็อกแลบดาสห้องเรียนและ
            โมดูล หนังสือเล่มนี้ยังมีการแนะนำอย่างละเอียดและยาวเกี่ยวกับ API ที่สมบูรณ์ของแพลตฟอร์ม
            Ruby ซึ่งแสดงให้เห็น - ด้วยรหัสตัวอย่างที่มีความเห็นอย่างหนัก - สิ่งอำนวยความสะดวกของ
            Ruby สำหรับการประมวลผลข้อความการจัดการตัวเลขคอลเลกชันอินพุต / เอาท์พุตเครือข่าย
            ทั้งบททุ่มเทให้กับความสามารถในการเขียนโปรแกรมของรูบี้'
  interview_questions:
    title: คำถามสัมภาษณ์
    description: ส่วนนี้จะเชื่อมโยงแหล่งข้อมูลสำหรับการอ่านและการเตรียมการสัมภาษณ์
    list:
      - name: 'Toptal: วิธีการจ้างนักพัฒนา Ruby ที่ยอดเยี่ยม'
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: 'Toptal: 21 คำถามการสัมภาษณ์ทับทิม'
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: 'Hookops: 35+ คำถามและคำตอบสำหรับการสัมภาษณ์ Ruby and Rails'
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: 'Educba: 15 คำถามและคำตอบสำหรับการสัมภาษณ์ทับทิมที่สำคัญที่สุด'
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: 'Ruby Garage: วิธีสัมภาษณ์ Ruby ของคุณบน Developer Rails'
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: 'RyanSobol: 15 คำถามที่ต้องถามระหว่างการสัมภาษณ์ทับทิม'
        link: "https://gist.github.com/ryansobol/5252653"
      - name: 'Toptal: 9 Essential Ruby on Rails สัมภาษณ์คำถาม'
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: เอกสารที่ดีกว่าคืออะไร
    description: เว็บไซต์นี้เป็นเว็บดัดแปลง Github repository <a href="https://github.com/khusnetdinov/ruby.fundamental">Ruby.Fundamental</a>
      ซึ่งรวบรวมดาวจำนวนมากและแปลเป็นภาษาจีน เอกสารที่ดีขึ้นจะช่วยให้คุณค้นหาแนวปฏิบัติที่ดีที่สุดจำนวนมากที่รวบรวมไว้ในที่เก็บเดียวได้อย่างรวดเร็ว
      เพียงแค่คุณ repo นี้ชอบแหล่งข้อมูลอ้างอิงหรือการเตรียมการสัมภาษณ์
    oss:
      title: ขอบคุณที่มาเปิด
      description: Better Docs ถูกสร้างขึ้นในขณะที่ทำงานและค้นหาวิธีปฏิบัติที่ดีที่สุดและความรู้เกี่ยวกับ
        ruby ซึ่งเป็นวิศวกรรมโอเพ่นซอร์สสำหรับแอปพลิเคชันการพัฒนาเว็บที่เขียนใน Ruby
      thanks: ถ้าเอกสารที่ดีกว่าช่วยคุณได้ไม่ว่าทางใดก็ตามลองคิดถึงการให้ดาวดวงหนึ่งแก่เราบน
        <a href="https://github.com/howtohireme/ruby.fundamental">Github</a> (ช่วยให้เราสามารถเข้าถึงนักพัฒนาได้มากขึ้น)
        หรือมีส่วนร่วมในโครงการของเรา
