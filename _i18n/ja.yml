head:
  title: BetterDocs
  metatags:
    description: ルビーの例と参考文献を使った基本的なプログラミング。スレッド、SOLIDの原則、デザインパターン、データ構造、アルゴリズムを網羅しています。
    keywords: より良いドキュメント、Ruby、基礎、Rubyプログラミングの基礎Rubyの手引き、関数型プログラミング、メタプログラミング、スレッド、例を含むRubyの堅実な原則、例を含むRubyのデザインパターン、例を含むRubyのアルゴリズム、例を含むRubyのデータ構造

content:
  menu:
    open: メニューを開く
    close: メニューを閉じる

sidebar:
  a: 
  ds: 
  dp: 
  fp: 
  iq: 
  mp: 
  sp: 
  brm: 
  t: 
sidebar:
  - title: アルゴリズム
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: データ構造
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: デザインパターン
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: 関数型プログラミング
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: 面接の質問
    url: interview_questions
  - title: メタプログラミング
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: 堅実な原則
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: Ruby Meisterになる
    url: ruby_meister
  - title: スレッド
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:
  wiki: ウィキを読む
  credits: クレジット
  page404:
    title: ページが見つかりません ：（
    description: 要求されたページが見つかりませんでした。
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: アルゴリズム
    complexity:
      best: ベスト
      average: 平均
      worst: 最悪
    sorting:
      title: ソート
      description: ソートアルゴリズムは、リストの要素を特定の順序で並べるアルゴリズムです。最もよく使われる順序は、数値順と辞書順です。効率的なソートは、入力データをソート済みリストに入れることを必要とする他のアルゴリズム（検索アルゴリズムやマージアルゴリズムなど）の使用を最適化するために重要です。また、データを正規化したり、人間が読める形式の出力を生成したりするのにも便利です。
      bubble_sort:
        title: バブルソート
        description: バブルソートには、挿入ソートと同じプロパティが多数ありますが、オーバーヘッドがわずかに高くなります。ほぼソートされたデータの場合、バブルソートは<span
          class="code-inline time">O(n)</span>を 取りますが、データを少なくとも2回通過する必要があります（一方、挿入ソートでは1回通過のようなものが必要です）。
      insertion_sort:
        title: 挿入ソート
        description: これは<span class="code-inline">O(n<sup>2</sup>)</span>の 最悪ケース時間の基本的なソートアルゴリズムの1つですが、データがほぼソートされるとき（適応的であるため）または問題サイズが小さいとき（挿入されるため）に最適です。低いオーバーヘッドがあります）。これらの理由から、また安定性もあるため、マージソートやクイックソートなどのオーバーヘッドの分割統治ソートアルゴリズムの場合、挿入ソートは再帰的な基本ケース（問題サイズが小さい場合）としてよく使用されます。
      selection_sort:
        title: 選択ソート
        description: ここに提示された比較から、選択ソートは決して使用されるべきではないと結論づけるかもしれません。これはデータにはまったく適応しません（上記の4つのアニメーションはロックステップで実行されます）ので、実行時間は常に2次です。ただし、選択ソートにはスワップの数を最小限に抑えるという性質があります。アイテムを交換するコストが高いアプリケーションでは、選択ソートが最適なアルゴリズムになる可能性があります。
      shell_sort:
        title: シェルソート
        description: シェルソートの最悪の場合の時間的な複雑さは増分シーケンスに依存します。ここで使用されるものでインクリメント1 4 13 40
          121 ...、のために、時間複雑度は<span class="code-inline">O(n<sup><sup>3</sup>/<sub>2</sub></sup>)</span>です。他の増分のため、時間複雑度は、
          <span class="code-inline">O(n<sup><sup>4<sub>/</sub>3</sup></sup>)</span>さらには
          <spanclass="code-inline">O(n・lg<sub>2(n)</sub></span>であることが知られています。時間の複雑さに対する厳密な上限も最良の増分シーケンスも知られていない。シェルソートは挿入ソートに基づいているため、シェルソートは挿入ソートのアダプティブプロパティを継承します。シェルソートはインクリメントごとにデータを1回通過する必要があるため、適応はそれほど劇的ではありませんが、重要です。上記のインクリメントシーケンスでは、
          <span class="code-inline">log<sub>3</sub>(n)</span>の インクリメントがあるため、ほぼソートされたデータの時間複雑度は
          <span class="code-inline">O(n・log<sub>3</sub>(n))</span>です。その低いオーバーヘッド、比較的簡単な実装、適応特性、およびサブ次の時間の複雑性、シェル・ソートは
          <span class="code-inline">O(n・lg(n))</span>に対する実行可能な代替することができるデータをソートする場合、いくつかの用途のためのアルゴリズムをソートありますあまり大きくありません。
      heap_sort:
        title: ヒープソート
        description: ヒープソートは実装が簡単で、 <span class="code-inline">O(n・lg(n))</span>インプレースソートを実行しますが、安定していません。最初のループ、
          <span class="code-inline">Θ(n)</span>の 「heapify」フェーズは、配列をヒープ順に並べます。 2番目のループ、
          <span class="code-inline">O(n・lg(n))</span>の 「並べ替え」フェーズでは、最大値が繰り返し抽出され、ヒープの順序が復元されます。明快さのためにsink関数は再帰的に書かれています。したがって、示されるように、コードは再帰呼び出しスタックのために<span
          class="code-inline">Θ(lg(n))</span>スペースを必要とします。ただし、sink（）の末尾再帰は簡単に反復に変換され、
          <span class="code-inline">O(1</span>の 空間境界が得られます。どちらのフェーズも少し適応的ですが、特に有用な方法ではありません。ほぼソートされたケースでは、heapifyフェーズは元の順序を破壊します。逆の場合、配列はヒープ順に開始されるため、ヒープ化フェーズはできるだけ高速になりますが、ソートダウンフェーズが一般的です。いくつかのユニークなキーのケースでは、いくらかスピードアップがありますが、シェルソートや3-wayクイックソートほどではありません。
      merge_sort:
        title: マージソート
        description: マージソートは非常に予測可能です。これは、要素ごとに、ととの間のの比較
          <span class="code-inline">0.5lg(n)</span>と<span
          class="code-inline">lg(n)</span>との間になり、<span class="code-inline">1.5lg(n)</span>は 要素ごとに入れ替え。最小値はすでにソートされたデータに対して達成されます。最大値は、平均してランダムデータに対して達成されます。
          <span class="code-inline">Θ(n)</span>の 余分なスペースを使用しても問題がない場合は、マージソートが優れた選択です。実装が簡単で、唯一の安定した
          <span class="code-inline">O(n・lg(n))</span>ソートアルゴリズムです。リンクリストをソートするとき、マージソートは<span
          class="code-inline">Θ(lg(n))</span>の 追加スペースのみを必要とします（再帰用）マージソートは、安定性が必要な場合、リンクリストをソートする場合、ランダムな場合に最適なアルゴリズムです。アクセスはシーケンシャルアクセスよりはるかに高価です（たとえば、テープ上の外部ソート）アルゴリズムの最後のステップには線形時間インプレースマージアルゴリズムが存在しますが、それらは高価で複雑です。
          <span class="code-inline">Θ(n)</span>の 追加スペースが利用できない場合の外部ソートなど。
      quick_sort:
        title: クイックソート
        description: 慎重に実装すると、クイックソートは堅牢でオーバーヘッドが少なくなります。安定したソートが必要ない場合は、quicksortが優れた汎用ソートです。ただし、代わりに3-wayパーティショニングバージョンを使用する必要があります。上記の2方向分割コードは、最適なパフォーマンスではなく、わかりやすくするために書かれています。それは貧弱な局所性を示し、そして批判的には、固有の鍵がほとんどないときに<span
          class="code-inline">O(n<sup>2</sup>)</span>時間を示す。 Quicksortには、Robert SedgewickとJon
          Bentleyによる、より効率的で堅牢な2分割方法があります。ロバスト分割は、ピボットに等しい多くの値があるときにバランスのとれた再帰を生成し、すべての入力に対して<span class="code-inline">O(n・lg(n)</span>時間と<span class="code-inline">O(lg(n))</span>空間の確率保証をもたらします。両方のサブソートが再帰的に実行されるため、クイックソートでは、再帰のバランスが取れていない最悪の場合、再帰スタックに<span
          class="code-inline">O(n)</span>の 追加スペースが必要になります。これは起こりにくいことですが、小さい方のサブ配列を最初に再帰的にソートすることで回避できます。
      other: その他のソートアルゴリズム
      additional: 追加の読み物
    searching:
      title: 検索中
      binary_search:
        title: 二分検索
        description: コンピュータサイエンスでは、ハーフインターバル検索または対数検索とも呼ばれるバイナリ検索は、ソートされた配列内のターゲット値の位置を見つける検索アルゴリズムです。ターゲット値を配列の中央の要素と比較します。それらが等しくない場合、ターゲットが嘘をつくことができない半分は排除され、それが成功するまで残りの半分について探索が続けられる。
      knuth_moriss_pratt_search:
        title: クヌース - モリス - プラット検索
        description: コンピュータサイエンスでは、Knuth-Morris-Pratt文字列検索アルゴリズム（またはKMPアルゴリズム）は、不一致が発生したときに単語自体が十分に具現化されているという観察結果を使用して、メインの「テキスト文字列」S内の次の一致が始まる可能性がある場所を判断するための情報。これにより、以前に一致した文字の再検査を回避します。
      other:
        title: その他の検索アルゴリズム
        dijkstra: ダイクストラのアルゴリズム
        kruskal: クラスカルのアルゴリズム
        longest: 最長増加サブシーケンス
        telephone_number: 言葉への電話番号
    credits: コードと記事はリソースから取得されました。
  data_structures:
    title: データ構造
    description: コンピュータサイエンスでは、問題サイズが極端に大きくなるにつれてアルゴリズムの処理時間がどのように変化するかなど、入力サイズの変化に対応する方法でアルゴリズムを分類するために、大きなO表記法が使用されます。解析的数論では、算術関数の漸近サイズを大きな有限引数でとられる値で置き換えながら、「コミットされたエラー」を推定するために使用されます。有名な例は、素数定理の剰余項を推定する問題です。
    axioms:
      title: データ構造の基本公理
      description: 共通言語ランタイムの実行時性能は、これから仮定する公理の集合によって与えられます。
      fetch_store:
        title: 時間を取り出して保管する
        description1: メモリからオブジェクトへの参照を取得するのに必要な時間は定数<span class="code-inline">T_fetch</span>であり、メモリにオブジェクトへの参照を格納するのに必要な時間は定数<span
          class="code-inline">T_store</span>です。
        description2: 公理によると、代入文は実行時間<span class="code-inline">T_fetch + T_store</span>を持ち ます。つまり、変数xからオブジェクト参照を取得するのにかかる時間は<span
          class="code-inline">T_fetch</span>で、そのオブジェクト参照を変数yに格納するのにかかる時間は<span class="code-inline">T_store</span>です。
        description3: 実行時間<span class="code-inline">T_fetch + T_store</span>もあり ます。なぜこれが当てはまるかを確かめるために、定数<span
          class="code-inline">1</span>が値1を持つFixnumオブジェクトに名前を付けると考えてください。したがって、1という名前のオブジェクトへの参照を取得するためのコストは、他のオブジェクトへの参照を取得するためのコストと同じになります。
      elementary_operations:
        title: 初等算術演算時間
        description1: 加算、減算、乗算、除算、比較などの基本算術演算の実行に必要な時間はすべて定数です。これらの時間はそれぞれ<span class="code-inline">T_
          +、T_-、T_ /、T_ *、T_<</span>で 表されます。
        description2: <span class="code-inline">2 * T_fetch + T_ + + T_store</span>の ように、ステートメントの時間を決定できます。これは、変数yと1から2つのオブジェクト参照を取得する必要があるためです。値が合計である新しいオブジェクトを与える加算を実行します。そして、新しいオブジェクトへの参照を変数yに格納します。
        description3: 代替案は、元の文とまったく同じ実行時間を必要とすると想定します。
      call_method:
        title: 呼び出し方法の時間
        description1: メソッドを呼び出すのに必要な時間は定数<span class="code-inline">T_call</span>で、メソッドから戻るのに必要な時間は定数<span
          class="code-inline">T_return</span>です 。引数を渡すことは、概念的には、メソッドの仮パラメータに実際のパラメータ値を代入することと同じです。
        description2: Axiomによれば、ステートメントの実行時間は<span class="code-inline">T_fetch + 2 *
          T_store + T_call + T_f(x)</span>になります。ここで、 <span class="code-inline">T_f(x）</span>は入力xに対するメソッドfの実行時間です。
          2つのストアのうち最初のものは、メソッドxへのパラメータxの引き渡しによるものです。 2番目は、変数yへの代入から発生します。
      calculating:
        title: 計算時間
        description1: 例えば<span class="code-inline">a[i]</span>の ような配列購読操作によって暗示されるアドレス計算に必要な時間は定数<span
          class="code-inline">T_[]</span>です。この時間には添字式を計算する時間も配列要素にアクセスする時間も含まれていません。
        description2: これは<span class="code-inline">3 * T_fetch</span>です。 3つのオペランドの取り出しが必要です。最初に配列オブジェクトへの参照を取り出します。
          2番目のインデックスオブジェクトへの参照を取得します。そして3番目は配列要素<span class="code-inline">a[i]</span>への参照を取得します。
      object:
        title: オブジェクト作成時間
        description1: クラスの新しいオブジェクトインスタンスを作成するのに必要な時間は定数<span class="code-inline">T_new</span>です。この時間には、オブジェクトの初期化にかかる時間は含まれていません。公理を適用することによって、ステートメントの実行時間を決定できます。
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> 、ここで<span class="code-inline">T_fixnum_init</span>はFixnumクラスの初期化メソッドの実行時間です。
      example:
        title: 例
        description: この節では、公理、プログラムの実行時間の分析を適用して、次の単純な算術級数の合計を計算します。
    implementations:
      title: 実装
      stack:
        title: スタック
        description: スタックはキューの兄弟です。それは現実のスタック（紙など）を模しています。これはFILO（先入れ先出し）なので、スタックから項目が取り出されるときには、項目が追加された順序と逆の順序で戻されます。また、Ruby配列は完璧なコンテナを提供します。キューと同様に、リンクリストを使用して実装することもできます。
        as_array: 配列としてスタック
        as_linked_list: リンクリストとしてスタック
      queue:
        title: キュー
        description: キューは、実際のキューを模倣する単純なコンテナベースの構造です（例：銀行で並んで待つ）。これはFIFO（先入れ先出し）です。つまり、キューから項目を取り出すと、項目は入力された順序で戻されます。
          Ruby配列はQueueの実装を簡単にするメソッドを提供しますが、適切な名前を付けてコンビニエンスクラスに含めることは、それらが実装されていることを確認する価値があります。リンクリストを使って別の実装を行うこともできます。
        as_array: 配列としてキューに入れる
        as_linked_list: リンクリストとしてのキュー
      deque:
        title: と
        description: Dequeは両端で項目を追加したり削除したりできるキューです。
        as_array: そして配列として
        as_linked_list: リンクリストとしてデキュー
      singly_linked_list:
        title: 単独リンクリスト
        description: 片方向リンクリストには、データフィールドと &#39;next&#39;フィールドを持つノードが含まれます。これは、ノードの並びで次のノードを指します。単一リンクリストで実行できる操作には、挿入、削除、および走査が含まれます。
      doubly_linked_list:
        title: 二重リンクリスト
        description: 二重リンクリストでは、各リスト要素に2つの参照が含まれています。1つはその後継者への参照であり、もう1つはその先行操作への参照です。
      ordered_list:
        title: 順序付きリスト
        description: 順序付きリストは、項目の順序が重要なリストです。ただし、番号付きリストの項目は必ずしもソートされているわけではありません。その結果、アイテムの順序を変更しても有効な順序付きリストを持つことができます。
        as_array: 配列としての順序付きリスト
      hash_table:
        title: ハッシュ表
        description: ハッシュテーブルは検索可能なコンテナです。そのため、オブジェクトをコンテナに入れたり、コンテナ内のオブジェクトを見つけたり、コンテナからオブジェクトを削除したりするためのメソッドを提供します。
      binary_tree:
        title: 二分木
        description: 二分木は、各ノードが最大2つの子を持つことができる木です。子供たちは左右に指名されています。
      binary_search_tree:
        title: 二分探索木&lt;
        description: コンピュータサイエンスでは、順序付きまたはソート済みのバイナリツリーとも呼ばれるバイナリ検索ツリー（BST）は、特定の種類のコンテナです。つまり、「アイテム」（数字、名前など）をメモリに格納するデータ構造です。それらはアイテムの迅速な検索、追加、削除を可能にし、動的なアイテムのセット、またはキーでアイテムを見つけることを可能にするルックアップテーブル（例えば、名前で人の電話番号を見つける）を実装するために使用できます
      b_tree:
        title: Bツリー
        description: コンピュータサイエンスでは、Bツリーはデータをソートし、対数時間で検索、順次アクセス、挿入、および削除を可能にする自己均衡化ツリーデータ構造です。
          Bツリーは、2つ以上の子を持つことができるという点でバイナリ検索ツリーを一般化したものです（自己均衡バイナリ検索ツリーとは異なり、Bツリーは大きなデータブロックを読み書きするシステムに最適化されています）。ツリーは外部メモリのデータ構造の好例で、データベースやファイルシステムでよく使われています。
      binary_heap:
        title: バイナリヒープ
        description: バイナリヒープは、配列を使用して実装されるヒープ順の完全なバイナリツリーです。ヒープでは最小のキーがルートで見つかり、ルートは常に配列の最初の位置にあるため、最小のキーを見つけることはバイナリヒープでは簡単な操作です。
      credits: コードと記事はリソースから取得されました。
      source: このページには、Bruno R. Preissによる「Rubyにおけるオブジェクト指向設計パターンを持つデータ構造とアルゴリズム」の本からのRubyコードが含まれています。著作権（c）2004
        Bruno R. Preiss、P.Eng。全著作権所有。
  design_patterns:
    title: デザインパターン
    creational:
      title: 創造的なパターン
      description: ソフトウェア工学では、創造的デザインパターンは、オブジェクト作成メカニズムを扱い、状況に適した方法でオブジェクトを作成しようとするデザインパターンです。オブジェクト作成の基本的な形式は、設計上の問題や設計の複雑さを増す可能性があります。創造的デザインパターンは、このオブジェクト作成を何らかの形で制御することによってこの問題を解決します。創造的デザインパターンは、2つの主要なアイデアで構成されています。
        1つは、システムがどの具象クラスを使用するかについての知識をカプセル化することです。もう1つは、これらの具象クラスのインスタンスがどのように作成され結合されるかを隠すことです。
      abstract_factory:
        title: 抽象的な工場パターン
        description: 抽象ファクトリパターンは、具体的なクラスを指定せずに、共通のテーマを持つ個々の工場のグループをカプセル化する方法を提供します。通常の使用法では、クライアントソフトウェアは抽象ファクトリの具象実装を作成し、次にファクトリの汎用インタフェースを使用してテーマの一部である具象オブジェクトを作成します。クライアントは、これらの各内部ファクトリからどの具体的なオブジェクトを取得するのかを知らない（または気にする）ことはありません。これは、クライアントが自分の製品の汎用インタフェースのみを使用するためです。このパターンは、オブジェクトの作成がファクトリインタフェースで公開されているメソッドで実装されているため、一連のオブジェクトの実装の詳細とそれらの一般的な使用法を区別し、オブジェクトの構成に依存します。
      builder:
        title: ビルダーパターン
        description: ビルダーパターンは、オブジェクト作成ソフトウェアの設計パターンです。ポリモーフィズムを有効にすることを目的としている抽象ファクトリー・パターンおよびファクトリー・メソッド・パターンとは異なり、ビルダー・パターンの意図は、入れ子式のコンストラクター・アンチパターンに対する解決策を見つけることです[要出典]。伸縮コンストラクタアンチパターンは、オブジェクトコンストラクタパラメータの組み合わせの増加がコンストラクタの指数関数的なリストにつながるときに発生します。多数のコンストラクターを使用する代わりに、Builderパターンでは、各初期化パラメーターをステップごとに受け取り、結果として作成されたオブジェクトを一度に戻す別のオブジェクト（Builder）を使用します。
      factory:
        title: 工場パターン
        description: クラスベースプログラミングでは、ファクトリメソッドパターンは、作成されるオブジェクトの正確なクラスを指定しなくてもオブジェクトを作成するという問題に対処するためにファクトリメソッドを使用する作成パターンです。これは、コンストラクタを呼び出すのではなく、ファクトリメソッドを呼び出すことによってオブジェクトを作成することによって行われます。ファクトリメソッドは、インタフェースで指定し、子クラスで実装するか、基本クラスで実装し、必要に応じて派生クラスでオーバーライドします。
      prototype:
        title: プロトタイプパターン
        description: プロトタイプパターンは工場のラインに沿った創造的なパターンです。プロトタイプの秘訣は、マスターオブジェクトをコピーして新しいオブジェクトを作成することです。そのマスターオブジェクトを変更し、それ以降に作成したすべてのオブジェクトは、その変更のコピーと共に有効になります。
      singleton:
        title: シングルトンパターン
        description: クラスにインスタンスが1つしかないことを確認し、それにグローバルなアクセスポイントを提供します。これは、システム全体でアクションを調整するために正確に1つのオブジェクトが必要な場合に役立ちます。この概念は、オブジェクトが1つしか存在しないときに効率的に動作するシステム、またはインスタンス化を特定の数のオブジェクトに制限するシステムに一般化されることがあります。
      not_covered:
        title: カバーされていないパターン：
        lazy: 遅延初期化
        multiton: マルチトン
        pool: オブジェクトプール
        resource: リソース獲得は初期化です
    structural:
      title: 構造パターン
      description: ソフトウェア工学では、構造設計パターンはエンティティ間の関係を実現する簡単な方法を識別することによって設計を容易にする設計パターンです。
      adapter:
        title: アダプターパターン
        description: ソフトウェア工学では、アダプタパターンは既存のクラスのインタフェースを他のインタフェースとして使用することを可能にするソフトウェア設計パターンです。ソースコードを変更せずに既存のクラスを他のクラスと連携させるためによく使用されます。
      composite:
        title: 複合パターン
        description: 複合設計パターンは、階層ツリー構造を持つオブジェクトを表すために使用される構造パターンです。それは個々の葉の節と多くの節からなる枝の両方の均一な取り扱いを可能にする。
      decorator:
        title: デコレータパターン
        description: オブジェクト指向プログラミングでは、デコレータパターン（別名Wrapper、アダプタパターンと共有される別名）は、他のオブジェクトの動作に影響を与えることなく、静的または動的に個々のオブジェクトに動作を追加できるデザインパターンです。同じクラスのオブジェクトデコレータパターンは、単一責任原則を遵守するのに役立つことがよくあります。これは、機能を固有の関心領域を持つクラス間で分割できるためです。
      facade:
        title: ファサード模様
        description: ファサードデザインパターンは、システムが相互に依存し合うクラスを多数持っているか、またはそのソースコードが利用できないためにシステムが非常に複雑または理解しにくい場合によく使用されます。このパターンは、大規模システムの複雑さを隠し、クライアントへのより単純なインターフェースを提供します。通常、クライアントが必要とするメンバーのセットを含む単一のラッパークラスが関係します。これらのメンバーは、ファサードクライアントに代わってシステムにアクセスし、実装の詳細を隠します。
      flyweight:
        title: フライ級柄
        description: コンピュータプログラミングでは、flyweightはソフトウェア設計パターンです。フライウェイトは、他の同様のオブジェクトとできるだけ多くのデータを共有することによってメモリ使用量を最小限に抑えるオブジェクトです。単純な繰り返し表現で許容できない量のメモリを使用する場合は、オブジェクトを大量に使用する方法です。多くの場合、オブジェクトの状態の一部を共有できるので、それらを外部データ構造に保持し、使用時に一時的にflyweightオブジェクトに渡すことが一般的な方法です。
      proxy:
        title: プロキシパターン
        description: 最も一般的な形式のプロキシは、他のものへのインタフェースとして機能するクラスです。プロキシは、ネットワーク接続、メモリ内のラージオブジェクト、ファイル、または高価な、または複製が不可能なその他のリソースのいずれにも接続できます。つまり、プロキシとは、背後で実際のサービングオブジェクトにアクセスするためにクライアントによって呼び出されているラッパーオブジェクトまたはエージェントオブジェクトです。プロキシの使用は、単に実際のオブジェクトに転送することでも、追加のロジックを提供するためでもかまいません。プロキシでは、実オブジェクトに対する操作がリソースを集中的に使用する場合のキャッシング、実オブジェクトに対する操作が呼び出される前の前提条件の確認など、追加の機能を提供できます。クライアントにとっては、プロキシオブジェクトの使用は実際のオブジェクトの使用に似ています。どちらも同じインターフェイスを実装しているからです。
      protection_proxy:
        title: 保護プロキシ
        description: 保護プロキシ。あなたはMNCに取り組んでいますか？もしそうなら、私たちは公共の電子メール、ソーシャルネットワーキング、データストレージなどのようなある種のウェブサイトへのアクセスを制限することによって私たちにインターネットを提供するプロキシサーバーをよく知っているかもしれません。仕事関連のWebページのみを提供します。プロキシサーバーはその仕事をします。これはプロキシデザインパターンの一種です
      virtual_proxy:
        title: 仮想プロキシ
        description: 仮想プロキシ複雑なオブジェクトや重いオブジェクトの代わりに、スケルトン表現を使用してください。基礎となる画像のサイズが非常に大きい場合は、仮想プロキシオブジェクトを使用してそれを表現し、実際のオブジェクトをオンデマンドでロードするだけです。実際のオブジェクトはインスタンス化の観点から高価であることをあなたは知っています、そして本当の必要性なしで私達は本当のオブジェクトを使用するつもりはありません。必要が生じるまでは、仮想プロキシを使用します。
      remote_proxy:
        title: リモートプロキシ
        description: リモートプロキシ分散オブジェクト通信では、ローカルオブジェクトはリモートオブジェクト（異なるアドレススペースに属するもの）を表します。ローカルオブジェクトはリモートオブジェクトに対するプロキシであり、ローカルオブジェクトに対するメソッド呼び出しは、リモートオブジェクトに対するリモートメソッド呼び出しになります。
          ATMの実装を考えると、リモートサーバーに存在する銀行情報のプロキシオブジェクトを保持します。
      not_covered:
        title: カバーされていないパターン：
        callback: 注釈付きコールバック
        bridge: ブリッジ
        data_bus: データバス
        role: ロールオブジェクト
    behavioral:
      title: 行動パターン
      description: ソフトウェア工学において、ビヘイビアデザインパターンは、オブジェクト間の共通のコミュニケーションパターンを識別し、これらのパターンを実現するデザインパターンです。そうすることによって、これらのパターンはこの通信を実行する際の柔軟性を高める。
      chain_of_responsobility:
        title: 責任連鎖パターン
        description: オブジェクト指向設計では、責任連鎖パターンは、コマンドオブジェクトのソースと一連の処理オブジェクトからなる設計パターンです。各処理オブジェクトには、処理可能なコマンドオブジェクトの種類を定義するロジックが含まれています。残りはチェーン内の次の処理オブジェクトに渡されます。このチェーンの最後に新しい処理オブジェクトを追加するためのメカニズムもあります。
      command:
        title: コマンドパターン
        description: コマンドパターンは、将来のメソッド呼び出しに必要な情報を格納するために使用される動作設計パターンです。コマンドは、単にオブジェクトにラップされた一連のアクションです。
          Rubyでは、別のオブジェクトを作成しなくてもProcを使用して同じことを実行できます。アクションが単純で状態情報を保存する必要がない場合、これは良いオプションです。そうでなければ、コマンドクラスがより良いオプションです。
      interpreter:
        title: 通訳者パターン
        description: コンピュータプログラミングでは、インタプリタパターンは、言語で文を評価する方法を指定するデザインパターンです。基本的な考え方は、特殊なコンピューター言語で各シンボル（端末または非端末）のクラスを持つことです。言語の文の構文木は複合パターンのインスタンスであり、クライアントのために文を評価（解釈）するために使用されます。
      iterator:
        title: イテレーターパターン
        description: イテレータデザインパターンは、コンテナが実際に要素を表す方法を公開することなく、コンテナ内の要素への順次アクセスを提供します。イテレータは、コンテナ内にカプセル化された要素へのアクセスを許可する移動可能なポインタと考えることができます。
      external_iterator:
        title: 外部イテレータパターン
        description: 外部反復子：反復論理は別のクラスに含まれています。反復クラスは、インデックス付けが可能である限り、複数のオブジェクト型を処理するように一般化できます。実際の反復処理を行うには追加のクラスが必要ですが、反復処理を制御できるため、どの要素をどの順序で反復処理するかを制御できるため、柔軟性が向上します。
      internal_iterator:
        title: 内部イテレータパターン
        description: 内部反復子：すべての反復ロジックは集約オブジェクトの内部で発生します。コードブロックを使用してロジックを集合体に渡し、次に集合体がその要素ごとにブロックを呼び出します。
      mediator:
        title: メディエータパターン
        description: 通常、プログラムは多数のクラスで構成されています。そのため、ロジックと計算はこれらのクラスに分散されています。しかしながら、特に保守および／またはリファクタリング中に、プログラム内でより多くのクラスが開発されるにつれて、これらのクラス間の通信の問題はより複雑になる可能性がある。これはプログラムを読み、維持することをより困難にします。さらに、何らかの変更は他のいくつかのクラスのコードに影響を与える可能性があるため、プログラムの変更が困難になる可能性があります。メディエータパターンでは、オブジェクト間の通信はメディエータオブジェクトでカプセル化されます。オブジェクトは互いに直接通信することはなくなり、代わりにメディエータを介して通信します。これにより、通信するオブジェクト間の依存関係が減少し、それによってカップリングが減少します。
      momento:
        title: パターンの瞬間
        description: momentoパターンは3つのオブジェクトで実装されています：創始者、世話人、そしてmomentoです。発信者は、内部状態を持つオブジェクトです。世話人は創始者に何かをしようとしていますが、変更を元に戻すことができるようにしたいです。世話人は最初に創始者にモーメントオブジェクトを要求します。それからそれはそれがやろうとしていたどんな操作（または操作のシーケンス）でも行います。操作前の状態にロールバックするには、momentoオブジェクトをオリジネーターに返します。
          momentoオブジェクト自体は不透明なオブジェクトです（世話人はそれを変えることができない、あるいは変えるべきではありません）。このパターンを使用するとき、発信者が他のオブジェクトやリソースを変更する可能性がある場合は注意が必要です。
      observer:
        title: 観察者パターン
        description: オブザーバパターンは、サブジェクトと呼ばれるオブジェクトがオブザーバと呼ばれるその従属オブジェクトのリストを保持し、通常はそれらのメソッドの1つを呼び出すことによって自動的に状態変化を通知するソフトウェア設計パターンです。主に分散イベント処理システムの実装に使用されます。オブザーバパターンは、よく知られているモデル
          - ビュー - コントローラ（MVC）アーキテクチャパターンの重要な部分です。オブザーバパターンは、ほとんどすべてのGUIツールキットを含む、多数のプログラミングライブラリおよびシステムに実装されています。
      state:
        title: 状態パターン
        description: ステートパターンは、オブジェクト指向の方法でステートマシンを実装する動作ソフトウェアデザインパターンです。ステートパターンでは、ステートマシンは、各個々のステートをステートパターンインタフェースの派生クラスとして実装し、パターンのスーパークラスによって定義されたメソッドを呼び出すことによってステート遷移を実装することによって実装されます。
      strategy:
        title: 戦略パターン
        description: 戦略により、アルゴリズムはそれを使用するクライアントとは独立して異なるようになります。戦略は、Gamma et al。による影響力のある本Design
          Patternsに含まれているパターンの1つです。そのため、ソフトウェア設計を記述するためにパターンを使用するという概念が普及しました。たとえば、着信データに対して検証を実行するクラスは、データの種類、データのソース、ユーザーの選択、またはその他の識別要素に基づいて検証アルゴリズムを選択するための戦略パターンを使用できます。これらの要因は、実行時まで各ケースで不明であり、実行するために根本的に異なる検証が必要になる場合があります。妥当性検査オブジェクトとは別にカプセル化された妥当性検査ストラテジーは、コードの重複なしに、システムのさまざまな領域（または異なるシステムでさえ）の他の妥当性検査オブジェクトによって使用されることがあります。
      template:
        title: テンプレートメソッドパターン
        description: オブジェクト指向プログラミングでは、まず、アルゴリズム設計の基本ステップを提供するクラスが作成されます。これらのステップは抽象メソッドを使用して実装されています。後で、サブクラスは抽象メソッドを変更して実際のアクションを実装します。したがって、一般的なアルゴリズムは1か所に保存されますが、具体的な手順はサブクラスによって変更されることがあります。
      visitor:
        title: 訪問者パターン
        description: オブジェクト指向プログラミングおよびソフトウェア工学では、訪問者デザインパターンは、それが動作するオブジェクト構造からアルゴリズムを分離する方法です。この分離の実際的な結果は、既存のオブジェクト構造に変更を加えることなく、既存のオブジェクト構造に新しい操作を追加できることです。それはオープン/クローズの原則に従う一つの方法です。本質的には、訪問者はクラス自体を変更することなくクラスのファミリーに新しい仮想関数を追加することを可能にします。代わりに、仮想関数の適切な特殊化すべてを実装するビジタークラスを作成します。訪問者はインスタンス参照を入力として受け取り、二重ディスパッチを通して目標を実行します。
      not_covered:
        title: カバーされていないパターン：
        hierarchical: 階層訪問者
      credits: コードと記事はリソースから取得されました。
  functional_programming:
    title: 関数型プログラミング
    description: 機能的なスタイルで言語を使用することは、あなたが以下にリストされるいくつかの重要な機能にアクセスできることを意味します。
    axioms:
      immutable: 不変な値：いったん「変数」が設定されると、それを変更することはできません。 Rubyでは、これは変数を定数のように効果的に扱わなければならないことを意味します。
      side_effects: 副作用なし：与えられた値を渡したとき、関数は常に同じ結果を返さなければなりません。これは不変の値を持つことと密接に関係しています。関数が値を取り、それを変更することはできません。これは、結果を返すことに対して接線方向の副作用を引き起こすことになります。
      pure_functions: 高階関数：これらは、関数を引数として使用すること、または関数を戻り値として使用することを許可する関数です。これは、間違いなく、あらゆる機能言語の最も重要な機能の1つです。
      applying: カリー化：高階関数によって有効にされるカリー化は、複数の引数を取る関数を1つの引数を取る関数に変換することです。これは部分的な関数の適用と密接に関連しています。そして、それは複数の引数を持つ関数をそれが最初にしたより少ない引数を取る関数に変換しています。
      recursion: 再帰：それ自身の中から関数を呼び出すことによるループ。可変データにアクセスできない場合は、再帰を使用してデータの構築と連鎖を行います。これは、特定の時点でのループの状態を格納するために変数を渡す必要があるため、ループは機能的な概念ではないためです。
      lazy: 遅延評価、または遅延評価：実際に必要とされる瞬間まで値の処理を遅らせる。たとえば、遅延評価を有効にしてフィボナッチ数のリストを生成するコードがある場合、結果の値の1つがputなどの別の関数で必要になるまで、これは実際には処理および計算されません。
    pure_functions:
      title: 純粋な機能
      description: この関数はその引数を使用してのみ結果を計算することがわかります。
    closures:
      title: クロージャ
      description: Lambdaはクロージャーも強制しているので、オブジェクト間でコンテキストを維持することができます。
    applying:
      title: 部分的に適用して運ぶ
      description: 最初に、これら2つの機能の異なるアプリケーションが何であるかを理解しましょう。部分関数アプリケーションは、引数を少なくする関数を取り戻すために、いくつかの引数を持つ関数を呼び出しています。カリー化は、n個の引数を取る関数を取り、それを1つの引数を取るn個の関数に分割することです。
      proc: これら二つのことのそれぞれが機能を果たすことについてあなたに明確な考えを与えるために、例Procを取りましょう。
      partial: この関数を部分的に適用すると、最初の2つの引数を渡すと、次の入れ子になったProcが返されます。
      curry: <span class="code-inline">.curry</span>はカレー付きprocを返します。オプションのarity引数が与えられると、それは引数の数を決定します。カレーprocはいくつかの引数を受け取ります。十分な数の引数が与えられると、与えられた引数を元のprocに渡して結果を返します。そうでなければ、残りの引数を取る別のカリー付きプロシージャを返します。
  gotchas:
    title: ガッチャ
    description1: ほとんどのRuby on Rails初心者はフレームワークに興奮し、言語の知識がなくてもアプリケーションの作成を始めます。そしてそれがRoRの魔法です。
    description2: ある時点で物事は深刻になり始めます。 Ruby on Railsの汚い秘密を探究するために時間と労力を費やす人もいれば、言語の知識をほとんど持たない上級開発者になる人もいます。
    description3: いずれにせよ、遅かれ早かれ、初心者から熟練したプログラマーまで、私たちは皆、いわゆるRuby Gotchasに遭遇します。
    description4: 以下は開発者が知っておくべき人気のあるRubyの落とし穴と珍品のリストです。それぞれの場合で、紛らわしいコードやエラーを起こしやすいコードの例があります。
    description5: それらはあなたが単純な（しかし見つけるのは難しい）間違いをすることを防ぎ、あなた（そしてあなたのコード管理者）の人生を単純化することを妨げる良い習慣と一緒に来る。
    surprising:
      title: Rubyは驚くべきものです
      description: "「プログラマーの幸福を最大にするように設計されている」とはいえ、「驚きの原則」を使っても、Rubyにはまだ問題がある。このプレゼンテーションは、初心者向けの些細なことから、より高度で分かりにくいものまで、続けていきます。"
    quotes:
      title: これについて私を引用しないでください、しかし...
      description: 文字列補間（ <span class="code-inline">\ n</span>の ような特殊文字を含む）は<span class="code-inline">'重'</span>引用符で失敗します
        - それは<span class="code-inline">"重"</span>引用符を必要とします。ほとんどの言語と同様に、文字列補間があります。それを避けるために、実用的な場合はいつでも倍精度を使用します。
    twue:
      title: それは12です！それは12です！
      description: 2つのことだけが偽です： <span class="code-inline">false</span>と<span class="code-inline">nil</span>
        。 <span class="code-inline">0</span> （Cではfalse）、 <span class="code-inline">&quot;&quot;</span>
        （JSではfalse）、 <span class="code-inline">[]</span>などでさえ、それ以外のすべては真実です。これらのうちのいくつかが偽であるところで、C、JSなどから人々をつまずきます。
    symbols_and_strings:
      title: 象徴的に、彼を効率的に吊るしたり、弦を張ったりする
      description: <span class="code-inline">Symbol!=String</span>印刷した場合でも同じです。引数に使うものを覚えておいてください。理想的には、どちらかを取り、メソッドが期待するものを使用してください。ポステルの法則
    string_or_nothing:
      title: 文字列...または何もない！
    constants:
      title: 定数はありません
      description: Rubyでは、最初の大文字は定数を意味します。定数を変更してみてください。おお、あなたは警告を受ける！ BFD凍結してもFixnumsにはうまくいきません。それは配列（のようなもの）と他のほとんどのオブジェクトのために働きます...彼は先を見越して言いました。
    equals:
      title: あるものは他のものより平等です
      description: <span class="code-inline">==</span>はいつもと同じ値<span class="code-inline">.eql?</span>値とクラス（1がFixnum、1.0がFloat）
        、<span class="code-inline">.equal?</span>です。 同じオブジェクトです。それは実際にはずっと毛深いです。
    operations:
      title: "&gt; ===！= ==！"
      description: case文のように、 <span class="code-inline">===</span>は &quot;case equality&quot;です。より良い名前は<span
        class="code-inline">.describes?</span>かもしれません<span class="code-inline">.includes?</span>
        、または過負荷。繰り返しますが、実際にはずっと毛深いです。クラスObjectのドキュメントを参照してください。
        <span class="code-inline">===</span>がオブジェクトアイデンティティまたは同じ値とクラスのいずれかである言語から人々を取得します。
    priority:
      title: and！= &amp;&amp;、または！= ||
      description: <span class="code-inline">&&</span>は<span class="code-inline">=</span>よりも優先順位が高いため、
        <span class="code-inline">x = true && false</span> は <span class="code-inline">x
        =（true && false）</span>を意味し、優先順位は低く、 <span class="code-inline">x = true and false</span> は <span
        class="code-inline">(x = true）and false</span>を 意味 します。 Rubyスタイルガイド：
        <span class="code-inline">&&、||</span>を 使うブール式、<span
        class="code-inline">and, or</span>制御フロー用。
    sensitive:
      title: そんなに敏感にならないで！
      description: 空白は鈍感ですか？常にではない！パーサーはそれが式であると考えていますが、 <span class="code-inline">(1、2)</span>は有効なRuby式ではありません。
        （すべて1引数で問題なく動作します）。
      usage: 複数の引数がある場合： <br/> - いいえ親、問題ありません。 <br/> - スペースのない両親、OK。 <br/> - 親と空間、いや！
      methods: <span class="code-inline">method / num</span>は、丸められていない正規表現または文字列です。
        Rubyはあなたがメソッドに引数を与えていると考えています。一般原則：BALANCED空白文字を使う両側かどちらでもない。
      arguments: <span class="code-inline">one -2</span>を指定 すると、Rubyは、メソッドoneに引数<span
        class="code-inline">-2</span>を渡していると 見なし ます。
        <span class="code-inline">+2と</span>同じでも<span class="code-inline">* 2</span>でも同じです。繰り返しになりますが、BALANCED空白を使用してください。
      stubby: "&quot;Stabby&quot; lambdas（1.9+）親なしで引数の後の前にオプションのスペースを括弧でくくって、OK。両親の後のスペース、わかりました。繰り返しますが、両親の前のスペース、NO！更新：2.0で修正されました！"
    onto:
      title: "@へ！"
      description: '裸の値は一時的なローカル変数になります！解決策： <span class="code-inline">@!</span>を 覚えておいて ください。(または &quot;self&quot;
      または<span class="code-inline">attr_writer、attr_accessor</span>を 使用します。）Pythonではなく、Java
        / C ++から ユーザーを 取得します（これには &quot;self&quot;も必要です）。&quot;あなたはその変数を使い続けます。それがあなたがそれが意味すると思うことを意味するとは思いません。&quot;いにごモントーヤじゃない。'
    variables:
      title: 見て、それは@@です！
      description: 何が空白を埋めるのか？確認前に、親の<span class="code-inline">@@の値を</span>変更したり、子の 値を 変更したりしませんでした。それとも私たちですか？ <span class="code-inline">@@変数</span>
        はサブクラスと共有されてい ます - それらが存在するということだけではなく、変数自体もです！ Childの<span class="code-inline">@@の値を</span>宣言するとParentのものが変更され、Parentの変更されたChild&#39;s.utも含めて@@です。
    initialize:
      title: init（ialize）ありまたはなし
      description: 親の初期化は、子供がいない場合にのみ自動的に実行されます。そうでなければ、親は走るために呼ばれなければなりません。
    superman:
      title: スーパーマン対インビジブルマン
      description: 引数なしのリストと<span class="code-inline">super</span>、明示的な引数で<span class="code-inline">super</span>得たものを、発信者に送信NO引数を送信しないように、これらの引数を送信し、空の括弧を使用します。<span class="code-inline">super()</span>
    regexp:
      title: いつ終わるの？ （または始めますか？）
      description: 標準の正規表現では、 <span class="code-inlne">^</span>は文字列全体の先頭で<span class="code-inline">$</span>は末尾です。
        Rubyの正規表現は複数行にデフォルト設定されているので、 <span class="code-inline">^</span>は開始で<span class="code-inline">$</span>は任意の行の終わりです。
        <span class="code-inline">\ A</span>は文字列全体の先頭、 <span class="code-inline">\ Z</span>は末尾です。
        （または改行を含めるには\ zを入力してください。これは別の方法です。）
    any:
      title: ".any？"
      description: <span class="code-inline">.any?</span> 「任意の要素」という意味ではありません。ブロックで：
        &quot;ブロックを真実にするものはありますか？&quot;なしで：「どんな本当ですか？」暗黙的ブロックがあります： <span class="code-inline">{ |element| element }</span> 。
    undef:
      title: "（Un）Def Leppard"
      description: イテレータに渡されるブロック内で宣言された変数（たとえばtimesやeach）は、各反復の先頭で未定義です。反復子はブロックを繰り返し呼び出すので、呼び出しのたびにvarsは再び範囲外になります。組み込みのループ構造（例えば、whileやfor）は問題ありません。
        （または、ブロックの前にvarを宣言します。）
    freeze:
      title: フリーズ（Ar）光線
      description: 配列（またはハッシュ）をフリーズすると、配列に含まれる項目ではなく配列がフリーズします。文字列はその場で変更できます。このようにして、凍結した文字列の配列内の特定のスロットを変更できます。
    one_is_one:
      title: 1は1です…そしてそれ以上になるでしょう！
      description: Fixnumを新しい値に変更すると、新しいオブジェクトになります。それらはその場で変更することはできません。そのため、固定されたFixnumの配列を変更することはできません。
        （FixnumsとIntegersには、試してみるのに絶対的な方法はありません）。ところで：Fixnumの<span class="code-inline">object_id</span>は<span
        class="code-inline">value * 2 + 1</span>です。
    bang:
      title: "（to！||！to！）==？"
      description: Bangはその方法を危険だと指摘している。どうして？多くの場合、改造されていない非bangバージョンに対して、受信機を変更することがあります。同じ値をバン以外のバージョンとして返すことを信頼しないでください。変更が不要な場合、多くはnilを返します。
    array:
      title: 新しいゴッチャの配列
      description: objectとして与えられたデフォルト値は各スロットに対して同じオブジェクトです！ 1を変更すると、デフォルトのallが変更されます。
        blockとして与えられた初期値は各スロットに対して別々に評価されます。これを使用して、それぞれに新しい変数を作成します。
    hash:
      title: それをハッシュする
      description: 配列とほとんど同じ問題（および解決策）。より多くのゴスカス：空のスロットへのアクセスで新しいオブジェクトを作成します！過剰な数の新しいオブジェクトが作成される可能性があります。
        「本物の」コンテンツや数のチェックを台無しにする（nil-checking、.sizeなど）。
    rescue:
      title: 私を救出しなさい、ラインを投げなさい、私はそれを捕まえようとするだろう！
      description: Rubyでは、throwとcatchは例外ではありません。それらは、深いネスティングを終了するための高度なフロー制御です。 Rubyは例外にraiseとrescueを使います。
    to_str:
      title: to_s VS to_str
      description: <span class="code-inline">to_s</span>はすべてのオブジェクトに対して定義されており、常に何かを返します。
        <span class="code-inline">to_str</span>は、文字列のようなオブジェクトに対してのみ定義されます。たとえば、
        <span class="code-inline">Symbol</span>に は<span class="code-inline">to_str</span>があり ます が、
        <span class="code-inline">Array</span>に はありません。したがって、作業中のクラスが
        <span class="code-inline">String</span>の サブクラスであるかどうかを気にせずにダックタイピングを利用したい場合は、 
        <span class="code-inline">obj.is_a?(String)</span>などの代わりに
        <span class="code-inline">obj.respond_to?(:to_str)</span>を 使用できます。そうではありません。
    missing:
      title: method_missingとrespond_to_missingを調整する必要がありますか。
      description: <span class="code-inline">method_missing</span>を オーバーライドするときは、
        <span class="code-inline">respond_to_missing</span>をオーバーライドすることを忘れないで ください。同様に。
        method_missingを使用してオブジェクトがメソッド呼び出しで何かを返すようにする場合は、必ずrespond_to_missing？も再定義してください。そうしなければ、一見しても何も壊れませんが、結局問題に遭遇します。このクラスを考えます：
      respond_to: たくさんのコード（gemかあなた自身のもの）はrespond_toに頼っている？ （正当な理由で） respond_to_missingにパッチを適用する必要がありますか？同様に：
    exception:
      title: 例外ではなく、StandardErrorからの救済
      description: Exceptionを救済しない、StandardErrorの前に明示的にExceptionを救済すると、SyntaxError、LoadError、Interruptなどの通常は回復不可能なエラーも救済されます。
        Exception型修飾子を省略すると、RubyはStandardErrorのみをキャッチします。これは、おそらくあなたが望むものです：
    private:
      title: プライベートデータは本当ではなく、そしてw / classメソッドではまったくありません
      description: Rubyでクラスメソッドをプライベートにする方法があります、あなたはただいくつかのフープを飛び越えなければなりません。ええ、私は<span
        class="code-inline">class << self</span>構文を使用することを意味します。この奇妙さは、インスタンスシングルトンをクラスにプッシュしてクラスメソッドを効果的に作成します。
    braces:
      title: ブレースとdo-end
      description: 一般的な慣例では、複数行のブロックには<span class="code-inline">do .. end</span>を、単一行のブロックには中括弧を使用
        します が、2つの例には違いがあります。これは、 <span class="code-inline">{}</span>が
        <span class="code-inline">do .. end</span>よりも優先順位が高いことを意味 します。したがって、使用するものを決定するときには、この点に留意してください。
    module:
      title: 'モジュールFooの外部で定義されたクラスFoo :: Barは、Fooの内部を認識しません。'
      description: あなたは、 <span class="code-inline">module Something</span>、 <span class="code-inline">class Something</span>、または<span
        class="code-inline">def something</span>の各出現を新しいスコープへの「ゲートウェイ」として考えることができます。
        Rubyが参照されている名前の定義を探しているとき、それは最初に現在のスコープ（メソッド、クラス、またはモジュール）を調べ、それが含まれているそれぞれを通って戻る場所が見つからない場合そこに範囲。
    credits: コードと記事はリソースから取得されました。
  meta_programming:
    title: メタプログラミング
    description: メタプログラミングとは、他のプログラム（またはそれ自体）をデータとして作成または操作する、あるいはコンパイル時に作業の一部を実行する（そうでなければ実行時に行われる）コンピュータープログラムの作成です。多くの場合、これによりプログラマはすべてのコードを手動で書くのと同じ時間でより多くの作業をこなすことができます。あるいは、プログラムを再コンパイルすることなく新しい状況を効率的に処理するための柔軟性を高めます。メタプログラミングは、あなたの生活を楽にするためにランタイム中にコードを書くコードを書いています。
    dynamic_dispatch:
      title: 動的ディスパッチ
      description: <span class="code-inline">subject.public_send（message、* arguments）メッセージ</span>を送信することを許可します。
    dynamic_method:
      title: 動的メソッド
      description: メソッド<span class="code-inline">define_method：method_name {メソッド本体となるブロック}</span>を動的に作成することを可能にします<span
        class="code-inline">。</span>
    ghost_methods:
      title: ゴーストメソッド
      description: 「ゴーストメソッド」をキャッチし、それらを別のメソッドに転送する一方で、おそらく呼び出しの周りにロジックを追加します。 <span
        class="code-inline">method_missingを利用します</span>
    dynamic_proxies:
      title: 動的プロキシ
      description: <span class="code-inline">data_typeが</span>ある<span class="code-inline"><span
        class="code-inline">：</span>名前</span>または<span class="code-inline">：年齢</span>
        <span class="code-inline">ここ</span>で、たとえば、あなたは、着信メッセージを解析する<span class="code-inline">method_missingを</span>利用して仮想的な方法を提供することができます（例えば<span
        class="code-inline"><span class="code-inline">get_name、get_age）</span></span>と、このような<span
        class="code-inline">取得</span>などの別の方法をオフに委譲する<span class="code-inline">（DATA_TYPE）。</span>
      more: （分析後に） <span class="code-inline">method_missing</span>を使用してパフォーマンスの問題を発見した場合、メッセージが最初に
        `method_missing`によって受信された後に&quot;動的メソッド &quot;技術を利用して実際のメソッドを作成することができます。
  solid_principles:
    good: 良い！
    bad: 悪い！
    title: しっかりした原則
    description: コンピュータプログラミングでは、SOLID（単一責任、オープンクローズ、Liskov置換、インターフェース分離、および依存関係の逆転）は、Robert
      C. Martinによって2000年代初頭に名付けられた &quot;First Five Principles&quot;としてMichael Feathersによって導入された略語オブジェクト指向プログラミングおよび設計の5つの基本原則について。その意図は、これらの原則を一緒に適用すると、プログラマーが保守しやすく長期にわたって拡張できるシステムを作成する可能性が高くなることです。
      SOLIDの原則は、読みやすく拡張可能になるまでソフトウェアのソースコードをプログラマにリファクタリングさせることによって、コードの匂いを除去するためのソフトウェアの作業中に適用できるガイドラインです。それは機敏で適応的なソフトウェア開発の全体的な戦略の一部です。
    single:
      title: 単一責任原則
      description: 単一の責任の原則は束の最も抽象的です。それはクラスとメソッドを小さくそして維持しやすくするのを助けます。クラスを小さく集中させ続けることに加えて、理解しやすくなります。この例としては、取引を処理した後に特定の人のコミッションの概要を電子メールで送信するためのサポートを追加することがあります。私たちが変更する複数の理由を特定できるという事実は、単一責任原則の違反を示します。
    open_close:
      title: オープン/クローズ原則
      description: Open / Closed Principleでは、クラスやメソッドは拡張のためにオープンにし、修正のためにクローズするべきであると述べています。これは、クラス自体に変更を加えることなくシステムの動作を変更することを可能にするモジュール設計のために努力すべきであることを私たちに伝えます。これは通常、戦略パターンなどのパターンを使用することによって実現されます。
      after: このリファクタリングにより、コードを変更せずに新しいパーサーを追加できるようになりました。追加の動作には、新しいハンドラを追加するだけで済みます。これにより、FileParserが再利用可能になり、多くの場合、私たちがより焦点を絞った小さなクラスを作成するように奨励することで、単一責任原則を順守するようになります。
    liskov:
      title: リスコフの代用原則
      description: Liskovの原理は最も理解するのが難しい傾向があります。原則は、予期しない動作や不正な動作を引き起こすことなく、親クラスのインスタンスをその子のインスタンスに置き換えることができるはずであることを示しています。
    segregation:
      title: 依存関係の逆転原理
      description: 原則は、クライアントがそれが使用しない方法に依存することを強制されるべきではないと述べています。この例では、Computer、Programmer、およびTechnicianのクラスがあります。プログラマーとテクニシャンはどちらもコンピューターの使用方法が異なります。プログラマーは入力にコンピュータを使用しますが、技術者はコンピュータのハードドライブを変更する方法を知っています。
        Interface Segregation Principle（ISP）が実施しているのは、1つのクラスが使用していないメソッドに依存してはいけないということです。私たちの場合、Programmerはそれを使用しないのでComputer＃change_hard_driveメソッドと不必要に結合されていますが、このメソッドが強制する状態変更はProgrammerに影響を与えます。
        LSPに従うようにコードをリファクタリングしましょう。
      after: このリファクタリング後、技術者はコンピュータの状態から分離されているComputerInternals型とは異なるオブジェクトを使用します。
        Computerオブジェクトの状態はProgrammerによって影響を受ける可能性がありますが、変更は技術者にはまったく影響しません。
    di:
      title: 依存関係の逆転原理
      description: Dependency Inversion Principleは、低レベル（thinkデータベースクエリおよびIO）の実装の詳細に依存しない高レベル（thinkビジネスロジック）オブジェクトに関係しています。これは、アヒルの型付けと依存性逆転原理によって達成できます。多くの場合、このパターンは、上で説明したオープン/クローズド原則を達成するために使用されます。実際、この同じ例をこの原則のデモンストレーションとして再利用することさえできます。現在はフォーマッタクラスがありますが、Reportクラスにハードコードしたので、ReportからJSONFormatterへの依存関係が作成されます。
        ReportはJSONFormatterよりも抽象的（上位レベル）の概念であるため、DIPは事実上破られています。
      after: このように、ReportはJSONFormatterに依存せず、formatと呼ばれるメソッドを持つあらゆるタイプのフォーマッタを使用できます（これはダックタイピングとして知られています）。もう1つ注目すべきことは、問題を解決するためにもう一度依存性注入を使用したことです。このテクニックは、私たちの目的がオブジェクトを切り離すことであるとき非常に強力なものです、そしてそれが依存性逆転原理（vs依存性注入パターン）と同じイニシャルを持っていても、それらは全く異なる概念です。
  threads:
    example: 例
    title: スレッド
    description: 並列性と並行性についての注意：プロセスとスレッドの使用の主な違いは、メモリの処理方法です。高レベルでは、プロセスはコピーメモリを使用し、スレッドはメモリを共有します。これにより、プロセスの生成はスレッドの生成よりも遅くなり、実行中のプロセスはより多くのリソースを消費します。全体として、スレッドはプロセスよりもオーバーヘッドが少なくて済みます。このThread
      APIはRuby APIです。私は、Rubyの実装が違えば、基本となるスレッド動作も異なることをほのめかしました。
    green:
      title: グリーンスレッド
      description: Ruby 1.9は、グリーンスレッドをネイティブスレッドに置き換えました。しかし、GILはまだ並列処理を妨げています。そうは言っても、並行性はより良いスケジューリングによって改善されました。新しいスケジュールでは、本質的にそれらをタイマースレッドと呼ばれる別のネイティブスレッドに移動することで、コンテキスト切り替えの決定をより効率的にします。
    gil:
      title: GIL  - グローバルインタプリタロック
      description: MRIはグローバルインタプリタロック（GIL）を持っています。これはRubyコードの実行に関する問題です。つまり、マルチスレッドのコンテキストでは、一度に1つのスレッドしかRubyコードを実行できません。8コアのマシンで8つのスレッドが混雑している場合は、1つのスレッドと1つのコアだけが常にビジーになります。
        。 GILは、データを破壊する可能性がある競合状態からRubyの内部を保護するために存在します。警告と最適化がありますが、これがその要旨です。
      example: この単純な事実は、スレッドを非常に強力にするものであり、またスレッドを使用するのを困難にするものです。なぜスレッドが優れているのかというアイデアを私はあなたにすでに与えました。これが彼らの難しさを説明する簡単なプログラムです。ここでは、配列に<span
        class="code-inline">10 * 10000個の</span>要素があることがわかります。異なるルビは異なる結果を示すことがあることに注意してください。
        GILはMRIルビーにのみ存在します。
    mutex:
      title: ミューテックス - 相互実行
      description: ミューテックスは、複数のスレッドがコードの重要な部分へのアクセスを同期するためのメカニズムを提供します。言い換えれば、それらはマルチスレッドカオスの世界にいくらかの秩序といくらかの保証をもたらすのを助けます。コードの一部をミューテックスで囲むと、2つのスレッドが同時にそのセクションに入ることができなくなります。ミューテックスは、複数のスレッドがコードの重要な部分へのアクセスを同期するためのメカニズムを提供します。それはマルチスレッドカオスの世界にいくらかの秩序といくらかの保証をもたらすのを助けます。
      example: このプログラムでは、どのスレッドもミューテックスを配列にプッシュする前にロックする必要があるため、2つのスレッドが同時にこの操作を実行することはありません。つまり、この操作が完了する前に中断されることはもうありません。
        1つのスレッドが配列にプッシュし始めると、最初のスレッドが終了するまで他のスレッドはそのコード部分に入ることができません。この操作はスレッドセーフになりました。ここでは、配列に<span
        class="code-inline">10 * 10000個の</span>要素があることがわかります。ミューテックスのため、今はすべて同じです。ミューテックスはスレッドに同じ境界を設定します。このコードを最初にヒットしたスレッドがミューテックスをロックします。それがそのミューテックスの所有者になります。所有スレッドがミューテックスのロックを解除するまで、他のスレッドはそれをロックできません。
    fibers:
      title: 繊維
      description: ファイバーは、Rubyで軽量の協調並行処理を実装するためのプリミティブです。基本的に、それらはスレッドのように、一時停止して再開できるコードブロックを作成する手段です。主な違いはそれらが横取りされることは決してなく、スケジューリングはVMではなくプログラマーによって行われる必要があるということです。他のスタックレスの軽量同時実行性モデルとは対照的に、各ファイバには小さな4KBスタックが付属しています。これにより、ファイバーブロック内で深くネストされた関数呼び出しからファイバーを一時停止することができます。
    rails:
      title: スレッドセーフ
      description: これに関する問題は、アプリ全体がスレッドセーフであるかどうかを絶対的な確信を持って言う簡単な方法がないことです。
      global_variables: グローバル変数はグローバルです。つまり、それらはスレッド間で共有されます。今までにグローバル変数を使用しないことに納得がいかなかった場合は、ここで触れないようにするもう1つの理由があります。あなたが本当にアプリ全体で何かをグローバルに共有したいのであれば、とにかく、あなたはたぶん定数によって奉仕されるほうがよいでしょう（しかし下記参照）。
      class_variables: クラス変数スレッドについての議論の目的のために、クラス変数はグローバル変数と大差ありません。それらは、同じ方法でスレッド間で共有されます。問題は、クラス変数を使用することではなく、それらを変更することです。また、クラス変数を変更しないのであれば、多くの場合、定数がより良い選択です。
      instance_variables: クラスインスタンス変数しかし、Rubyではクラス変数の代わりに常にクラスインスタンス変数を使うべきだということを読んだ人もいるかもしれません。多分あなたはそうするべきですが、それらはクラス変数と同じくらいスレッド化されたプログラムにとって問題が多いです。
      memoization: メモそれ自体はスレッドの安全性の問題ではありません。多くの場合、クラス変数またはクラスインスタンス変数にデータを格納するために使用されます（前のポイントを参照）。
        <span class="code-inline">|| =</span>演算子は、実際には2つの操作であるため、その途中でコンテキストの切り替えが発生し、スレッド間で競合状態が発生する可能性があります。したがって、インスタンス変数のみを使用していたとしても、メモ化による競合状態になる可能性があります。クラス変数やクラスインスタンス変数に記憶しないでください。クラスレベルで何かを記憶する必要がある場合は、代わりにスレッドローカル変数
        (<span class="code-inline">Thread.current[:baz]</span>）を使用してください。ただし、それはまだグローバル変数の一種であることに注意してください。
    config:
      title: スレッドセーフを設定する
      description: このメソッドを呼び出すと、アプリ構成に4つのオプションが設定されます。それぞれの選択肢を見ていきましょう。
      frameworks: フレームワークのプリロード：最初のオプション@preload_frameworksは、それが言っていることのほとんどを実行します。Railsフレームワークを起動時に積極的にロードするよう強制します。このオプションが有効になっていない場合、フレームワーククラスは自動ロードによって遅延ロードされます。マルチスレッド環境では、オートロードに関するスレッドの安全性の問題から、スレッドを作成する前にフレームワークを積極的にロードする必要があります。フレームワークをロードすることはスレッドセーフではないことを私たちは知っているので、戦略はスレッドがリクエストを処理する準備ができる前にそれをすべてロードすることです。
      cache: クラスのキャッシング：@cache_classesオプションは、クラスが再ロードされるかどうかを制御します。アプリケーションで「TDD」を実行しているときのことを覚えていますか？あなたはコントローラを変更し、それからそれを「テストする」ためにページをリロードして、物事が変わったのを見ますか？そう、それがこのオプションのコントロールです。開発時など、このオプションがfalseの場合、クラスは変更時にリロードされます。このオプションがなければ、「F5DD」を実行することはできません（はい、それはF5ドリブン開発です）。本番環境では、クラスがその場で変更されることはないことがわかっているので、クラスをリロードするかどうかを判断する作業はリソースを無駄にするだけなので、クラス定義をリロードしないことは理にかなっています。
      di: 依存関係のロード：このオプションの@dependency_loadingは、欠けている定数が見つかったときにコードのロードを制御します。たとえば、コントローラはUserモデルを参照していますが、User定数は定義されていません。その場合、@dependency_loadingがtrueであれば、RailsはUser定数を含むファイルを見つけてそのファイルをロードします。コードのロードがスレッドセーフではないことについてはすでに説明したので、ここでの考え方は、フレームワークをロードし、次にすべてのユーザーコードをロードしてから依存関係のロードを無効にすることです。依存関係の読み込みが無効になったら、フレームワークコードとアプリコードを読み込む必要があります。足りない定数があると、コードの読み込みを試みるのではなく、単に例外が発生します。コードの読み込みはスレッドセーフではないため、本番環境でこのオプションを無効にすることを正当化します。スレッドがリクエストを処理する前に、すべてのコードを読み込むようにします。
      concurrency: '並行性の許可：@allow_concurrencyオプションは、スタックでRack :: Lockミドルウェアを使用するかどうかを制御します。
        Rack :: Lockはあなたの要求をミューテックスで囲みます。スレッドセーフではないコードがある場合、このミューテックスは同時に複数のスレッドがあなたのコントローラコードを実行するのを防ぎます。スレッドセーフ時！が設定されている場合、このミドルウェアは削除され、コントローラーコードは並行して実行できます。'
    credits: コードと記事はリソースから取得されました。
  ruby_meister:
    title: Ruby Meisterになる
    description: この講演では、Rubyの初心者から真のRubyの習得までの長い道のりを調べ、いくつかの重要な洞察を共有することでそれを少し短縮しようとします。マスターRubyistは、優れた理論的基礎を持ち、広範なツールボックスに頼り、Rubyのコアバリューと原則を深く理解し、常に彼らのスキルを磨いています。たぶん、あなたは「うわー、これはかなり漠然としている！」と言っているかもしれませんが、あなたがこのセッションに参加するなら、私はあなたが啓発され、楽しまれ、そしてあなたがそれを楽しむことを約束します！いいですね？素晴らしい本は、スキルをレベルアップするために私が人々に提案するリソースの一部になるでしょう。
    video: Bozhidar Batsov著ルビーマスタリーへの長い旅。
    computer_science_fundamentals:
      title: コンピュータサイエンスの基礎
      articles:
        - name: inside_machine
          title: 機械の内部：マイクロプロセッサとコンピュータアーキテクチャの紹介
          description: コンピュータは、ビジネスに不可欠なものからレクリエーションに至るまで無数のタスクを実行しますが、外観や動作の違いにかかわらず、基本的な機能はすべて驚くほど似ています。マイクロプロセッサ、または中央処理装置（CPU）がどのように機能するかを理解すれば、現代のすべてのコンピューティングの中心にある基本概念をしっかりと把握することができます。
        - name: code
          title: コード：コンピュータハードウェアとソフトウェアの隠された言語
          description: 懐中電灯、イギリスの侵略、黒い猫、そしてシーソーはコンピュータとどう関係がありますか？ CODEでは、彼らは私たちが言語を操作し、互いにコミュニケーションをとるための新しい方法を考案した独創的な方法を私たちに示しています。そしてCODEを通して、私たちはこの創意工夫と私たちのコミュニケーションに対する強い要求が過去2世紀の技術革新をどのように推進したかを見ています。
        - name: concrete_math
          title: 具象数学：コンピュータ科学の基礎
          description: この本は、高度なコンピュータプログラミングとアルゴリズムの分析をサポートする数学を紹介します。著名な作家の主な目的は、複雑で問題を解決し、恐ろしい合計を評価し、データ内の微妙なパターンを発見するために必要なスキルである、数学的スキルの強固で適切な基盤を提供することです。それは、コンピュータ科学者だけにとどまらず欠くことのできないテキストであり、参考文献です
            - 著者自身がそれに大きく依存しています！ - しかし、ほとんどすべての分野の数学の真面目なユーザーのために。
        - name: sicp
          title: コンピュータプログラムの構造と解釈
          description: コンピュータプログラムの構造と解釈は、過去10年間でコンピュータサイエンスのカリキュラムに劇的な影響を与えました。この待望の改訂には、本文全体にわたる変更が含まれています。この本には、インタプリタやコンパイラを含む、主要なプログラミングシステムの大部分の新しい実装があります。著者は、初版発行以来、MITでコースを教えた経験を反映した多くの小さな変更を取り入れました。計算モデルで時間を処理するためのさまざまなアプローチ、つまり状態を持つオブジェクト、並行プログラミング、関数型プログラミング、および遅延評価、および非決定的プログラミングで中心的な役割を果たすことを強調する新しいテーマが導入されました。
        - name: design_programms
          title: プログラムを設計する方法：プログラミングとコンピューティングの紹介
          description: このプログラミング入門は、コンピュータサイエンスをリベラルアーツ教育の中核に置いています。他の入門書とは異なり、プログラム設計プロセスに焦点を当てています。このアプローチは、将来のコンピュータープログラマーだけでなく、すべての人にとって重要な、批判的な読書、分析的思考、創造的な合成、そして細部へのこだわりといったさまざまなスキルを育みます。本は読者を2つの基本的に新しい考えにさらします。まず、読者に問題ステートメントの分析方法を示すプログラム設計ガイドラインを提示します。簡潔な目標を立てる方法例の作り方分析に基づいて、ソリューションの概要をどのように作成するか。プログラムの終了方法そしてテストする方法。
        - name: algorithm_manual
          title: アルゴリズム設計マニュアル
          description: ベストセラーの古典のこの新しく拡大されて更新された第2版は、アルゴリズムを設計して、それらの有効性と効率を分析することから「謎」を取り除き続けます。初版を拡張して、この本は現在、プログラマ、研究者、および学生のためのアルゴリズムへの第一の実用的な参照ガイドとしての地位を維持しながら、アルゴリズム設計コースのための選択の主要な教科書として役立ちます。
        - name: cormen
          title: アルゴリズム入門、第3版（The MIT Press）
          description: アルゴリズムに関するいくつかの本は厳密ですが不完全です。他のものは物質の塊をカバーしているが厳密さに欠けている。アルゴリズム入門は厳密さと包括性を独自に組み合わせたものです。この本は広範囲のアルゴリズムを詳細に網羅していますが、それらの設計と分析はあらゆるレベルの読者が利用できるようになっています。各章は比較的自己完結型であり、学習単位として使用できます。アルゴリズムは英語で、少しプログラミングをしたことのある人が読めるように設計された擬似コードで記述されています。説明は、網羅の深さや数学的な厳密さを犠牲にすることなく基本的なものにしてあります。
        - name: compilers
          title: コンパイラ：原理、テクニック、そしてツール（第2版）
          description: コンパイラ： &quot;ドラゴンブック&quot;として世界中の教授、学生、そして開発者に知られている原則、テクニック、そしてツールは、新しい版で利用可能です。最後の版が発行された1986年以降に起こったソフトウェア工学、プログラミング言語、およびコンピュータアーキテクチャの発展を反映するために、すべての章は完全に改訂されました。著者は、これまでコンパイラを構築することを続ける読者はほとんどいないことを認識し、ソフトウェア設計およびソフトウェア開発において直面するより広範な一連の問題に焦点を当てている。
        - name: c_lang
          title: Cプログラミング言語、第2版
          description: 著者はANSI標準C言語プログラミングの完全なガイドを提示します。 Cの開発者によって書かれたこの新しいバージョンは、Cの豊富な演算子のセット、表現の経済性、制御フローの改善、およびデータ構造の活用方法を示しながら、読者がC用の完成したANSI規格についていくのに役立ちます。
            2 / Eは、難しい言語構成要素の実装を明確にするために、追加の例と問題セットで完全に書き直されました。何年もの間、CプログラマーはK&amp;Rに彼らをよく体系化された効率的なプログラムを構築するように導いてもらいました。さて、これと同じヘルプがANSIコンパイラを使っている人たちにも利用可能です。構文表記法、宣言、ANSIの変更、有効範囲の規則など、一目でわかるC言語の詳細な解説と公式のC言語リファレンスマニュアルが含まれています。
    oop:
      title: オブジェクト指向プログラミング
      articles:
        - name: growing
          title: テストに導かれて成長するオブジェクト指向ソフトウェア
          description: テスト駆動開発（TDD）は、より良いソフトウェアをより早く提供するための確立された手法です。 TDDは単純な考えに基づいています。コードを書く前にコードのテストを書いてください。しかし、この「単純な」考えは上手くいくためにはスキルと判断を要します。基本的な概念を超えてあなたを連れて行くTDDへの実用的なガイドが今あります。実世界のシステムを構築する10年の経験に基づいて、2人のTDDのパイオニアはテストがあなたの開発を導き、一貫性があり、信頼でき、そして保守可能なソフトウェアを「成長」させる方法を示します。
        - name: domain_driven
          title: ドメイン駆動設計：ソフトウェアの心臓部における複雑さへの取り組み
          description: これは、ソフトウェア設計におけるドメインモデリングについての本です。ソフトウェア開発社会はある波から別の波へと生きています。
            OOP、パターン、XP、TDD、CI / CD、BigData、DevOps  - これはほんの数例です。この本はOOPの黄金時代から生まれました。作者は、オブジェクト指向パラダイムが唯一利用可能なものではないが、OOP
            / OODへの偏りが明白である（そして正当化できる）ことを認めています。この本では、コアソフトウェアコンポーネントのモデリングを「正しい方法」で行う方法について説明しています。
    ruby:
      title: あなたの言語を知っている
      articles:
        - name: well_grounded
          title: 根拠のあるルビニスト
          description: 根拠のあるRubyist、第2版は、Rubyの初心者と、言語の理解を深めることを望んでいるRubyプログラマーの両方を扱います。この美しく書かれ、そして全面的に改訂された第2版には、Ruby
            2.1で新しく追加された機能のカバレッジと、変更された言語の側面の拡張され更新されたカバレッジが含まれます。
        - name: programming_ruby
          title: Programming Ruby：実用的プログラマーズガイド第2版
          description: Rubyはますます普及してきた、完全にオブジェクト指向の動的プログラミング言語であり、今日利用可能な最も優れた最も有用な言語として多くの実務家から高く評価されています。
            Rubyが西洋の世界で最初に登場したときには、Pragmatic Programmersは決定的なリファレンスマニュアルであるProgramming
            Ruby：The Pragmatic Programmer&#39;s Guideを持っていました。
        - name: ruby_programming
          title: Rubyプログラミング言語：あなたが知る必要があるすべて
          description: この本は、言語のクイックスタートチュートリアルから始めて、語彙や構文の構造からデータ型、式や文、そしてメソッド、ブロック、ラムダ、クロージャ、クラス、そしてクラスへと至るまで、言語をボトムアップから詳細に説明します。モジュールこの本には、Rubyプラットフォームの豊富なAPIについての長くて徹底的な紹介も含まれており、コメントの多いサンプルコードで、テキスト処理、数値操作、コレクション、入出力、ネットワーキング、そして並行処理のためのRubyの機能を示している。章全体は、Rubyのメタプログラミング機能に専念しています。
  interview_questions:
    title: 面接の質問
    description: このセクションは読書とインタビューの準備のためのリソースリンクを保持しています
    list:
      - name: Toptal：すばらしいRuby開発者を雇う方法
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: Toptal：Rubyのインタビューに関する21の質問
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: フープ：35+ Ruby and Railsが質問と回答をインタビュー
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: Educba：15の最も重要なRubyインタビューの質問と回答
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: Ruby Garage：Ruby on Rails開発者にインタビューする方法
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: RyanSobol：Rubyインタビューの間に尋ねるべき15の質問
        link: "https://gist.github.com/ryansobol/5252653"
      - name: Toptal：9つの必須Ruby on Railsインタビューの質問
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: より良いドキュメントとは
    description: このウェブサイトは、たくさんの星を集めて中国語に翻訳されたウェブ適応Githubリポジトリ<a href="https://github.com/khusnetdinov/ruby.fundamental">Ruby.Fundamental</a>です。優れたドキュメントを使用すると、1つのリポジトリに集められた多くのベストプラクティスをすばやく見つけることができます。あなただけがこのリポジトリを参照またはインタビューの準備リソースとして気に入っています。
    oss:
      title: オープンソースのおかげで
      description: Better Docsは、Rubyで書かれたWeb開発アプリケーションのためのオープンソースエンジニアリングである、Rubyに関するベストプラクティスと知識について学びながら、作成されました。
      thanks: Better Docsが何らかの形であなたを助けてくれたのなら、 <a href="https://github.com/howtohireme/ruby.fundamental">Githubで</a>
        Starを手に<a href="https://github.com/howtohireme/ruby.fundamental">入れよう</a> （より多くの開発者に手を差し伸べるのに役立ちます）または私たちのプロジェクトに貢献することを考えてください。
