head:
  title: BetterDocs
  metatags:
    description: রুবি উদাহরণ এবং রেফারেন্স সঙ্গে মৌলিক প্রোগ্রামিং। এটি থ্রেড, সোলিড
      নীতি, নকশা নিদর্শন, তথ্য কাঠামো, অ্যালগরিদম জুড়ে।
    keywords: ভাল ডক্স, রুবি, মূলধারার, রুবি প্রোগ্রামিং মৌলিক। রুবি গোটচাস, কার্যকরী
      প্রোগ্রামিং, মেটাপ্রোগ্রামিং, থ্রেড, রুবি দৃঢ় নীতির উদাহরণ, উদাহরণস্বরূপ রুবি
      নকশা নিদর্শন, উদাহরণস্বরূপ রুবি অ্যালগরিদম, উদাহরণস্বরূপ রুবি তথ্য কাঠামো।

content:
  menu:
    open: খুলুন মেনু
    close: মেনু বন্ধ করুন

sidebar:
  - title: আলগোরিদিম
    url: algorithms
    submenus:
      - key: sorting
        submenus:
          - bubble_sort
          - insertion_sort
          - selection_sort
          - shell_sort
          - heap_sort
          - merge_sort
          - quick_sort
      - key: searching
        submenus:
          - binary_search
          - knuth_moriss_pratt_search
  - title: উপাত্ত কাঠামো
    url: data_structures
    submenus:
      - key: axioms
        submenus:
          - fetch_store
          - elementary_operations
          - call_method
          - calculating
          - object
          - example
      - key: implementations
        submenus:
          - stack
          - queue
          - deque
          - singly_linked_list
          - doubly_linked_list
          - ordered_list
          - hash_table
          - binary_tree
          - binary_search_tree
          - b_tree
          - binary_heap

  - title: নকশা নিদর্শন
    url: design_patterns
    submenus:
      - key: creational
        submenus:
          - abstract_factory
          - builder
          - factory
          - prototype
          - singleton
      - key: structural
        submenus:
          - adapter
          - composite
          - decorator
          - facade
          - flyweight
          - proxy
      - key: behavioral
        submenus:
          - chain_of_responsobility
          - command
          - interpreter
          - iterator
          - mediator
          - observer
          - state
          - strategy
          - template
          - visitor
  - title: কার্যকরী প্রোগ্রামিং
    url: functional_programming
    submenus:
      - pure_functions
      - closures
      - applying
  - title: Gotchas
    url: gotchas
    submenus:
      - surprising
      - quotes
      - twue
      - symbols_and_strings
      - string_or_nothing
      - constants
      - equals
      - operations
      - priority
      - sensitive
      - onto
      - variables
      - initialize
      - superman
      - regexp
      - any
      - undef
      - freeze
      - one_is_one
      - bang
      - array
      - hash
      - rescue
      - to_str
      - missing
      - exception
      - private
      - braces
      - module
  - title: সাক্ষাৎকার প্রশ্ন
    url: interview_questions
  - title: মেটা প্রোগ্রামিং
    url: meta_programming
    submenus:
      - dynamic_dispatch
      - dynamic_method
      - dynamic_proxies
  - title: SOLID মূলনীতি
    url: solid_principles
    submenus:
      - single
      - open_close
      - liskov
      - segregation 
      - di
  - title: রুবি মিস্টার হত্তয়া
    url: ruby_meister
  - title: টপিক
    url: threads
    submenus:
      - green
      - gil
      - mutex
      - fibers
      - rails
      - config

pages:
  wiki: উইকি পড়ুন
  credits: ক্রেডিট
  page404:
    title: পৃষ্ঠা খুঁজে পাওয়া যায়নি :(
    description: অনুরোধ করা পৃষ্ঠা খুঁজে পাওয়া যাবে না।
  page500:
    title: "Something was going wrong :("
  algorithms:
    title: আলগোরিদিম
    complexity:
      best: সেরা
      average: গড়
      worst: খারাপ
    sorting:
      title: শ্রেণীবিভাজন
      description: একটি সাজানোর অ্যালগরিদম একটি অ্যালগরিদম যা একটি নির্দিষ্ট আদেশ একটি
        তালিকা উপাদান রাখে। সর্বাধিক ব্যবহৃত আদেশ সংখ্যাসূচক আদেশ এবং lexicographical
        আদেশ। দক্ষ শর্টিং অন্যান্য অ্যালগরিদমগুলির ব্যবহারের অপ্টিমাইজ করার জন্য গুরুত্বপূর্ণ
        (যেমন অনুসন্ধান এবং একত্রিত অ্যালগরিদম) যাতে সাজানো তালিকাগুলিতে ইনপুট ডেটা
        প্রয়োজন হয়; এটি ডেটা ক্যানোনিকালাইজ করার জন্য এবং মানব-পাঠযোগ্য আউটপুট উৎপাদন
        করার জন্য প্রায়ই উপকারী।
      bubble_sort:
        title: বুদ্বুদ সাজানোর
        description: বাবল সাজানোর সন্নিবেশ সাজানোর হিসাবে একই বৈশিষ্ট্য অনেক আছে, কিন্তু
          সামান্য উচ্চতর ওভারহেড আছে। প্রায় সাজানো তথ্য ক্ষেত্রে, বুদ্বুদ সাজানোরটি
          <span class="code-inline time">O(n)</span> নেয় তবে ডেটাটির মাধ্যমে কমপক্ষে
          2 পাসের প্রয়োজন হয় (সন্নিবেশ সাজানোর জন্য 1 পাসের মত আরো কিছু প্রয়োজন)।
      insertion_sort:
        title: সন্নিবেশ সাজানোর
        description: যদিও এটি <span class="code-inline">O(n<sup>2</sup>)</span> সবচেয়ে
          খারাপ-কেসের সময়ের সাথে প্রাথমিক শর্টিং অ্যালগরিদমগুলির মধ্যে একটি, তবে সন্নিবেশ
          সাজানটি পছন্দসই অ্যালগরিদম হয় যখন তথ্যটি প্রায় সাজানো হয় (কারণ এটি অভিযোজিত)
          বা সমস্যাটির আকার ছোট (কারণ এটি কম ওভারহেড আছে)। এই কারণগুলির জন্য এবং এটি
          স্থিতিশীল কারণ, উচ্চতর ওভারহেড ডিভাইড-এবং-বিজয় সাজানোর অ্যালগরিদমগুলির জন্য
          সন্নিবেশ বা দ্রুত সাজানোর মতো, সন্নিবেশ সাজানোর প্রায়শই পুনরাবৃত্তিমূলক বেস
          কেস (যখন সমস্যার আকার ছোট হয়) হিসাবে ব্যবহৃত হয়।
      selection_sort:
        title: নির্বাচন সাজানোর
        description: এখানে উপস্থাপন তুলনা থেকে, এক সিদ্ধান্ত নিতে পারে যে নির্বাচন সাজানোর
          ব্যবহার করা উচিত না। এটি কোনও উপায়ে ডেটা মেনে চলে না (লক্ষ্য করুন যে লকস্টেপের
          উপরে চালানো চারটি অ্যানিমেশান), তাই এটির রানটাইম সর্বদা চতুর্ভুজ। যাইহোক,
          নির্বাচন সাজানোর swaps সংখ্যা কমানোর সম্পত্তি আছে। অ্যাপ্লিকেশনগুলিতে যেখানে
          সোয়াপিং আইটেমগুলির দাম বেশি হয়, নির্বাচন সাজানোর খুব ভালভাবে পছন্দসই অ্যালগরিদম
          হতে পারে।
      shell_sort:
        title: শেল সাজানোর
        description: শেল ধরণের সবচেয়ে খারাপ-কেস সময় জটিলতা বৃদ্ধি ক্রম উপর নির্ভর
          করে। বাড়তি 1 4 13 40 121 ..., যা এখানে কি ব্যবহার করা হয় জন্য সময় জটিলতা <span class="code-inline">O(n<sup><sup>3</sup>&frasl;<sub>2</sub></sup>)</span>
          হয়। অন্যান্য বাড়তি জন্য, সময় জটিলতা <span class="code-inline">O(n<sup><sup>4</sup>&frasl;<sub>3</sub></sup>)</span>
          এবং এমনকি হিসেবে পরিচিত <span class="code-inline">O(n·lg<sub>2</sub>(n))</span>
           সময় জটিলতার উপর টাইট উপরের সীমা বা ভাল বৃদ্ধি
          ক্রম পরিচিত হয় না। শেল সাজানোর সন্নিবেশ সাজানোর উপর ভিত্তি করে কারণ, শেল
          সাজানোর সন্নিবেশ সাজানোর এর অভিযোজিত বৈশিষ্ট্য উত্তরাধিকার। অভিযোজনটি নাটকীয়
          নয় কারণ শেল সাজানোর প্রতিটি প্রবৃদ্ধির জন্য ডেটা দিয়ে একটি পাস করতে হবে
          তবে এটি উল্লেখযোগ্য। উপরে দেখানো বৃদ্ধি ক্রম জন্য, <span class="code-inline">log<sub>3</sub>(n)</span> বৃদ্ধি আছে, তাই প্রায় সাজানো তথ্য জন্য সময় জটিলতা
          <span class="code-inline">O(n·log<sub>3</sub>(n))</span> । তার নিম্ন
          ওভারহেডের কারণে, অপেক্ষাকৃত সহজ বাস্তবায়ন, অভিযোজিত বৈশিষ্ট্য এবং উপ-চতুর্থাংশ
          সময় জটিলতার কারণে শেল <span class="code-inline">O(n·lg(n))</span> 
          একটি কার্যকর বিকল্প হতে পারে যখন কিছু ধরণের অ্যাপ্লিকেশনের জন্য সাজানো ডাটাটি
          সাজানো হয় খুব বড় না।
      heap_sort:
        title: হিপ সাজানোর
        description: হিপসোর্টটি বাস্তবায়ন সহজ, একটি <span class="code-inline">O(n·lg(n))</span> সঞ্চালন করে সাজানো, তবে স্থিতিশীল নয়। প্রথম লুপ, <span class="code-inline">Θ(n)</span>"heapify" ফেজ, অ্যারে হিপ অর্ডার মধ্যে রাখে। দ্বিতীয়
          লুপ, <span class="code-inline">O(n·lg(n))</span> "সাজান" ফেজ,
          বার বার সর্বাধিক নিষ্কাশন করে এবং হিপ অর্ডার পুনরুদ্ধার করে। সিঙ্ক ফাংশন স্বচ্ছতার
          জন্য recursively লেখা হয়। সুতরাং, দেখানো হিসাবে, কোড recursive কল স্ট্যাক
          জন্য <span class="code-inline">Θ(lg(n))</span> স্থান প্রয়োজন। যাইহোক, বেসিনে
          () মধ্যে লেজ পুনরাবৃত্তি সহজেই পুনরূদ্ধার রূপান্তর করা হয়, যা <span class="code-inline">O(1)</span>
          স্পেস আবদ্ধ। উভয় পর্যায় সামান্য অভিযোজিত, যদিও কোন বিশেষভাবে
          দরকারী পদ্ধতিতে। প্রায় সাজানো ক্ষেত্রে, heapify ফেজ মূল আদেশ ধ্বংস করে। বিপরীত
          ক্ষেত্রে, অ্যারেপ হ্যাপ হিপ অর্ডারে শুরু হওয়ার পরে যত তাড়াতাড়ি সম্ভব হেপাইফাইজ
          পর্বটি হয় তবে তারপরে স্রোত ডাউন ফেজটি সাধারণত। কয়েকটি অনন্য কী ক্ষেত্রে,
          কিছু গতিবেগ রয়েছে তবে শেল সাজানোর বা 3-উপায় দ্রুতগতির মতো নয়।
      merge_sort:
        title: সাজানোর মার্জ করুন
        description: 'সাজানোর মার্জ খুব প্রত্যাশিত। এটা তোলে <span class="code-inline">0.5lg
          (n)</span> এবং <span class="code-inline">lg(n)</span> উপাদান প্রতি তুলনা
          মধ্যে তোলে, এবং এলজি মধ্যে <span class="code-inline">lg(n)</span>
          এবং <span class="code-inline">1.5lg(n)</span> উপাদান প্রতি বিনিময়সমূহ। Minima
          ইতিমধ্যে সাজানো তথ্য জন্য অর্জন করা হয়; maxima এলোমেলো তথ্য জন্য, গড়, অর্জন
          করা হয়। যদি <span class="code-inline">Θ(n)</span> অতিরিক্ত স্থানটি কোনও
          উদ্বেগের বিষয় না থাকে, তবে সাজানোর বিয়োগটি একটি চমৎকার পছন্দ: এটি কার্যকর
          করা সহজ, এবং এটি শুধুমাত্র স্থিতিশীল <span class="code-inline">O(n · lg
          (n))</span> আলগোরিদিম সাজানোর জন্য। উল্লেখ্য যে লিঙ্কযুক্ত তালিকা বাছাই করার
          সময়, একত্রিত হওয়া সের জন্য শুধুমাত্র <span
          class="code-inline">Θ(lg(n)</span> অতিরিক্ত স্থান (পুনরাবৃত্তির জন্য) প্রয়োজন।
          সাজানোর মার্জ বিভিন্ন পরিস্থিতিতে জন্য পছন্দসই অ্যালগরিদম: যখন স্থিতিশীলতা
          প্রয়োজন হয়, লিঙ্ক তালিকা সাজানোর সময় এবং যখন র্যান্ডম অ্যাক্সেসটি ক্রমিক
          অ্যাক্সেসের চেয়ে অনেক বেশি ব্যয়বহুল (উদাহরণস্বরূপ, টেপের বাহ্যিক বাছাই)।
          অ্যালগরিদমের শেষ ধাপের জন্য স্থান-স্থান মার্জ অ্যালগরিদম বিদ্যমান থাকে তবে
          এটি উভয় ব্যয়বহুল এবং জটিল। জটিলতার জন্য অ্যাপ্লিকেশনগুলির জন্য উপযুক্ত যেমন
          বাইরের বাছাই যখন <span class="code-inline">Θ(n)</span> অতিরিক্ত স্থান পাওয়া
          যায় না।'
      quick_sort:
        title: Quick sort
        description: সাবধানে প্রয়োগ করা হলে, quicksort শক্তসমর্থ এবং কম ওভারহেড আছে।
          যখন একটি স্থিতিশীল বাছাই প্রয়োজন হয় না, quicksort একটি সাধারণ সাধারণ উদ্দেশ্য
          সাজানোর - যদিও 3-উপায় বিভাজন সংস্করণ পরিবর্তে সর্বদা ব্যবহার করা উচিত। উপরে
          দেখানো 2-উপায় বিভাজন কোড স্বচ্ছ কর্মক্ষমতা তুলনায় স্বচ্ছতার জন্য লেখা হয়;
          এটা দরিদ্র এলাকা প্রদর্শন করে, এবং সমালোচকদের, কয়েকটি অনন্য কী আছে যখন <span
          class="code-inline">O (n <sup>2</sup> )</span> সময় প্রদর্শন করে। কুইসোর্টে
          আরও দক্ষ এবং শক্তসমর্থ 2-উপায় বিভাজন পদ্ধতি দেওয়া হয় রবার্ট সেডগিউইক এবং
          জন বেন্টলি। শক্তসমর্থ বিভাজন ভারসাম্য সমান অনেকগুলি মূল্যের সমতুল্য পুনরাবৃত্তি
          তৈরি করে, যা সমস্ত ইনপুটগুলির জন্য <span class="code-inline">O(n·lg(n))</span>
          সময় এবং <span class="code-inline">O(lg(n))</span> সম্ভাব্য গ্যারান্টীগুলি
          সরবরাহ করে। উভয় সাব-সোর্সগুলি পুনরাবৃত্তভাবে সঞ্চালিত হলে দ্রুত পুনরাবৃত্তিটি
          সামঞ্জস্যপূর্ণ না হলে ক্ষতিকারক স্ট্যাকের জন্য পুনরাবৃত্তি স্ট্যাকের জন্য
          অতিরিক্ত <span class="code-inline">(O)</span> অতিরিক্ত স্থান প্রয়োজন। এটি
          ঘটতে খুব অসম্ভাব্য, তবে এটি ছোট সাব-অ্যারেকে প্রথমবারের মতো সাজানোর মাধ্যমে
          এড়িয়ে চলতে পারে; দ্বিতীয় সাব-অ্যারে সাজানোর একটি লেজ পুনর্মিলনী কল, পরিবর্তে
          পুনরাবৃত্তি সঙ্গে এটি করা যেতে পারে। এই অপ্টিমাইজেশনের সাথে, অ্যালগরিদমটি
          সবচেয়ে খারাপ ক্ষেত্রে অতিরিক্ত স্থান <span class="code-inline">(O(lg(n))</span>
          ব্যবহার করে।
      other: অন্যান্য সাজানোর আলগোরিদিম
      additional: অতিরিক্ত পড়া
    searching:
      title: খোঁজ
      binary_search:
        title: বাইনারি অনুসন্ধান
        description: কম্পিউটার বিজ্ঞানে, বাইনারি অনুসন্ধান, অর্ধ-অন্তর্বর্তী অনুসন্ধান
          বা লগারিদমিক অনুসন্ধান হিসাবেও পরিচিত, এটি একটি অনুসন্ধান অ্যালগরিদম যা একটি
          সাজানো অ্যারের মধ্যে একটি টার্গেট মানের অবস্থান খুঁজে পায়। এটি অ্যারের মাঝারি
          উপাদানতে লক্ষ্য মান তুলনা করে; যদি তারা অসম হয়, যার অর্ধেক লক্ষ্য মিথ্যা
          বলা যায় না সেটি বাদ দেওয়া হয় এবং এটি সফল না হওয়া পর্যন্ত বাকি অর্ধেক অনুসন্ধান
          চলতে থাকে।
      knuth_moriss_pratt_search:
        title: নুথ-মরিস-প্র্যাট অনুসন্ধান
        description: কম্পিউটার বিজ্ঞানে, নুথ-মরিস-প্র্যাট স্ট্রিং অনুসন্ধান অ্যালগরিদম
          (অথবা কেএমপি অ্যালগরিদম) একটি &quot;শব্দ স্ট্রিং&quot; এসের একটি &quot;শব্দ
          স্ট্রিং&quot; এস এর আবির্ভাবের জন্য অনুসন্ধান করে এটি পর্যবেক্ষণ করে যে যখন
          একটি দ্বিধা ঘটে তখন শব্দটি নিজেই যথেষ্ট পরবর্তী ম্যাচটি কোথায় শুরু হতে পারে
          তা নির্ধারণের জন্য তথ্য, এইভাবে পূর্বে মিলযুক্ত অক্ষরগুলির পুনরায় পরীক্ষা
          পরীক্ষা করে।
      other:
        title: অন্যান্য অনুসন্ধান আলগোরিদিম
        dijkstra: ডিজকট্রা এর অ্যালগরিদম
        kruskal: Kruskal এর অ্যালগরিদম
        longest: দীর্ঘতম বৃদ্ধি পরবর্তী
        telephone_number: শব্দের টেলিফোন নম্বর
    credits: 'কোড এবং নিবন্ধ সম্পদ থেকে নেওয়া হয়েছে:'
  data_structures:
    title: উপাত্ত কাঠামো
    description: কম্পিউটার বিজ্ঞানে, বড় O নোটেশনটি অ্যালগরিদমগুলিকে শ্রেণীবদ্ধ করতে
      ব্যবহৃত হয় কিভাবে তারা ইনপুট আকারে পরিবর্তনগুলির প্রতিক্রিয়া জানায়, যেমন কোনও
      অ্যালগরিদমের প্রক্রিয়াকরণ সময়টি আকারের আকারের আকারে পরিবর্তিত হয়। বিশ্লেষণাত্মক
      সংখ্যা তত্ত্বের মধ্যে এটি &quot;ভুল সংঘটিত&quot; অনুমান করার জন্য ব্যবহৃত হয়
      যখন একটি গাণিতিক ফাংশনের অ্যাসিপ্টটিক ফাংশনটিকে একটি বড় সীমাবদ্ধ যুক্তিতে গ্রহণ
      করা মান দ্বারা প্রতিস্থাপিত করে। একটি বিখ্যাত উদাহরণটি প্রধান সংখ্যা তত্ত্বের
      বাকি শব্দটির অনুমান করার সমস্যা।
    axioms:
      title: তথ্য কাঠামোর বেসিক axioms
      description: সাধারণ ভাষা রানটাইম চলমান সময় কর্মক্ষমতা axioms একটি সেট দ্বারা
        দেওয়া হয়, যা আমরা এখন পোস্ট করা হবে।
      fetch_store:
        title: আনুন এবং সময় সংরক্ষণ করুন
        description1: মেমরি থেকে একটি বস্তুর একটি রেফারেন্স আনতে প্রয়োজনীয় সময়টি
          একটি ধ্রুবক, <span class="code-inline">T_fetch</span> , এবং স্মৃতিতে একটি
          বস্তুর একটি রেফারেন্স সংরক্ষণ করার জন্য প্রয়োজনীয় সময়টি
          একটি ধ্রুবক, <span class="code-inline">T_store</span>
        description2: অ্যাক্সিওমের মতে, অ্যাসাইনমেন্ট বিবৃতিটি <span class="code-inline">T_fetch
          + T_store</span> সময় চলছে। অর্থাৎ, ভেরিয়েবল এক্স থেকে বস্তুর রেফারেন্স আনতে
          সময়টি <span class="code-inline">T_fetch</span> এবং পরিবর্তনশীল Y তে বস্তুর
          রেফারেন্সটি সংরক্ষণ করতে সময় নেওয়া <span class="code-inline">T_store</span> হয়
          ।
        description3: এছাড়াও চলমান সময় <span class="code-inline">T_fetch + T_store</span>
          আছে । কেন এই ক্ষেত্রে হওয়া উচিত তা বিবেচনা করুন, ধ্রুবক <span class="code-inline">1</span>
          মূল্যের সাথে একটি ফিক্সন বস্তু নাম করে। অতএব, আমরা আশা করতে পারি যে 1 নামক
          বস্তুর রেফারেন্স ফিরিয়ে দেওয়ার খরচটি অন্য কোনও বস্তুর একটি রেফারেন্স আনতে
          একই রকম।
      elementary_operations:
        title: প্রাথমিক গাণিতিক অপারেশন সময়
        description1: প্রাথমিক গাণিতিক ক্রিয়াকলাপগুলি, যেমন সংযোজন, বিয়োগ, গুণ, বিভাগ
          এবং তুলনা করার জন্য প্রয়োজনীয় সময় সকল স্থিরতা। এই সময়গুলি যথাক্রমে <span
          class="code-inline">T_ +, T_-, T_ /, T_ *, T_ &lt;</span> দ্বারা চিহ্নিত করা
          হয়।
        description2: আমরা একটি বিবৃতি সময় নির্ধারণ করতে পারেন যেমন <span class="code-inline">2
          * T_fetch + T_ + + T_store</span> । কারণ আমরা ভেরিয়েবল y এবং 1 থেকে দুটি
          বস্তুর রেফারেন্স আনতে হবে; যোগফল সঞ্চালন একটি নতুন বস্তু যার মূল্য সমষ্টি
          প্রদান করা; এবং, পরিবর্তনশীল y তে নতুন বস্তুর একটি রেফারেন্স সংরক্ষণ করুন।
        description3: আমরা আসল বক্তব্য হিসাবে বিকল্পটি ঠিক একই চলমান সময় প্রয়োজন অনুমান
          করা হবে।
      call_method:
        title: কলিং পদ্ধতি সময়
        description1: একটি পদ্ধতি কল করার সময় প্রয়োজন একটি ধ্রুবক, <span class="code-inline">T_call</span>
          , এবং একটি পদ্ধতি থেকে ফিরে যাওয়ার প্রয়োজন সময় একটি ধ্রুবক, <span class="code-inline">T_return</span>
          বস্তু রেফারেন্স সংরক্ষণ সময় হিসাবে একই পাস পরামিতি সঙ্গে যুক্ত ওভারহেড তৈরীর
          জন্য যুক্তি হল যে একটি যুক্তি পাস করা পদ্ধতির আনুষ্ঠানিক প্যারামিটারে প্রকৃত
          পরামিতি মানটির অ্যাসাইনমেন্ট হিসাবে ধারণাগত।
        description2: অ্যাক্সিমমের মতে, বিবৃতির চলমান সময়টি <span class="code-inline">T_fetch + 2 * T_store + T_call + T_f(x)</span>,
          যেখানে <span class="code-inline">T_f(x)</span> ইনপুট x এর জন্য পদ্ধতি f এর চলমান সময়। দুটি স্টোরের মধ্যে প্রথমটি
          প্যারামিটার x পরিমাপের পদ্ধতিতে f হয়; দ্বিতীয় পরিবর্তনশীল Y থেকে বরাদ্দ
          থেকে উদ্ভূত হয়।
      calculating:
        title: গণনা সময়
        description1: অ্যারে সাবস্ক্রিপশন ক্রিয়াকলাপ দ্বারা প্রদত্ত ঠিকানা গণনার জন্য
          প্রয়োজনীয় সময়, উদাহরণস্বরূপ, একটি <span class="code-inline">a[i]</span>
          , একটি ধ্রুবক, <span class="code-inline">T_[]</span> । এই সময় সাবস্ক্রিপ্ট
          অভিব্যক্তি গণনা করার সময় অন্তর্ভুক্ত করে না, এবং এটি অ্যারের উপাদান অ্যাক্সেস
          করার জন্য সময় অন্তর্ভুক্ত করে না।
        description2: 'এই <span class="code-inline">3 * T_fetch</span> হয় । তিনটি অপারেড
          fetches প্রয়োজন: অ্যারে বস্তুর একটি রেফারেন্স আনতে প্রথম একটি; সূচক বস্তু
          আমি একটি রেফারেন্স আনতে দ্বিতীয়; এবং, তৃতীয়টি অ্যারে উপাদানের একটি
          রেফারেন্স আনতে একটি<span class="code-inline">a[i]</span> ।'
      object:
        title: অবজেক্ট সৃষ্টি সময়
        description1: একটি ক্লাসের একটি নতুন বস্তু উদাহরণ তৈরি করার জন্য সময় একটি ধ্রুবক,
          <span class="code-inline">T_new</span> । এই সময় বস্তু আরম্ভ করতে যে কোন সময়
          অন্তর্ভুক্ত করা হয় না। Axioms প্রয়োগ করে আমরা বিবৃতি চলমান সময় নির্ধারণ
          করতে পারেন।
        description2: <span class="code-inline">T_new + T_fetch + 2 * T_store + T_call
          + T_fixnum_init</span> , যেখানে <span class="code-inline">T_fixnum_init</span>
          ক্লাস ফিক্সামের প্রাথমিক পদ্ধতির চলমান সময়।
      example:
        title: উদাহরণ
        description: এই বিভাগে আমরা Axioms প্রয়োগ করি, নিম্নোক্ত সহজ গাণিতিক সিরিজ
          সংক্ষেপটি গণনা করার জন্য একটি প্রোগ্রামের চলমান সময় বিশ্লেষণ।
    implementations:
      title: বাস্তবায়ন
      stack:
        title: গাদা
        description: স্ট্যাক কিউ এর ভাইবোন হয়। এটি একটি বাস্তব-জীবন স্ট্যাকের নমুনা
          (যেমন কাগজ)। এটি FILO (প্রথম-আউট-শেষ-আউট), যাতে স্ট্যাক থেকে আইটেমগুলি পুনরুদ্ধার
          করা হয়, যাতে তারা যে ক্রমের যোগ করা হয়েছে তার বিপরীতে তারা ফিরে আসে। আবার,
          রুবি Arrays একটি নিখুঁত ধারক প্রদান। সারি হিসাবে, এটি একটি লিঙ্ক তালিকা ব্যবহার
          করে প্রয়োগ করা যেতে পারে।
        as_array: অ্যারের হিসাবে স্ট্যাক
        as_linked_list: লিঙ্ক তালিকা হিসাবে স্ট্যাক
      queue:
        title: কিউ
        description: একটি সারি একটি সাধারণ ধারক-ভিত্তিক কাঠামো যা একটি বাস্তব-লাইফ সারি
          অনুকরণ করে (যেমন ব্যাংকের লাইনের অপেক্ষা)। এটি ফিফো (প্রথম-আউট-আউট-আউট), অর্থাত
          যে আপনি যখন সারি থেকে আইটেমগুলি পুনরুদ্ধার করেন, তখন তারা যে ক্রমে প্রবেশ
          করে সেগুলিতে ফিরে আসে। রুবি অ্যারেগুলি এমন পদ্ধতিগুলি সরবরাহ করে যা কুইয়ের
          বাস্তবায়নকে তীব্রভাবে সহজ করে তোলে তবে তাদের উপযুক্তভাবে নামকরণ করা এবং সুবিধাযুক্ত
          শ্রেণিতে অন্তর্ভুক্ত করা এটিকে কার্যকর করার জন্য মূল্যবান এবং অন্য কাঠামোগুলি
          এই থেকে উত্তরাধিকারী হবে। একটি বিকল্প বাস্তবায়ন একটি লিঙ্ক তালিকা ব্যবহার
          করে সম্পন্ন করা যেতে পারে।
        as_array: অ্যারের হিসাবে সারি
        as_linked_list: লিঙ্ক তালিকা হিসাবে সারি
      deque:
        title: এবং
        description: একটি deque একটি সারি যা উভয় প্রান্তে আইটেম যোগ এবং অপসারণ করতে
          পারবেন।
        as_array: একটি বিন্যাসের যেমন
        as_linked_list: লিঙ্ক তালিকা হিসাবে Deque
      singly_linked_list:
        title: একক লিঙ্ক তালিকা
        description: একক লিঙ্ক তালিকাগুলিতে নোড রয়েছে যার একটি ডাটা ক্ষেত্র পাশাপাশি
          একটি &#39;পরবর্তী&#39; ক্ষেত্র রয়েছে যা নোডের লাইনের পরবর্তী নোডের দিকে নির্দেশ
          করে। একক লিঙ্ক তালিকাতে সঞ্চালিত অপারেশন সন্নিবেশ, মুছে ফেলা এবং ট্রান্সভারাল
          অন্তর্ভুক্ত করা যেতে পারে।
      doubly_linked_list:
        title: ডাবল লিঙ্ক তালিকা
        description: দ্বিগুণ-লিঙ্ক তালিকাতে, প্রতিটি তালিকা উপাদানটিতে দুটি উল্লেখ রয়েছে
          - এটির উত্তরাধিকারী এবং তার পূর্বসূরির একটি।
      ordered_list:
        title: আদেশের তালিকা
        description: একটি আদেশ দেওয়া তালিকা একটি তালিকা যা আইটেম উল্লেখযোগ্য। যাইহোক,
          একটি আদেশ তালিকা আইটেম অগত্যা বাছাই করা হয় না। ফলস্বরূপ, আইটেমগুলির ক্রম
          পরিবর্তন করা সম্ভব এবং এখনও একটি বৈধ অর্ডার তালিকা আছে।
        as_array: অ্যারের হিসাবে আদেশ আদেশ
      hash_table:
        title: হ্যাশ টেবিল
        description: একটি হ্যাশ টেবিল একটি অনুসন্ধানযোগ্য ধারক। যেমন, এটি একটি বস্তু
          ধারক মধ্যে নির্বাণ, ধারক মধ্যে একটি বস্তু, এবং ধারক থেকে একটি বস্তু অপসারণ
          করার পদ্ধতি উপলব্ধ করা হয়।
      binary_tree:
        title: বাইনারি গাছ
        description: একটি বাইনারি গাছ একটি গাছ যা প্রতিটি নোড সর্বোচ্চ দুই সন্তান থাকতে
          পারে। শিশুদের বাম এবং ডান মনোনীত করা হয়।
      binary_search_tree:
        title: বাইনারি অনুসন্ধান গাছ &lt;
        description: 'কম্পিউটার বিজ্ঞানে, বাইনারি অনুসন্ধান গাছগুলি (বিএসটি), কখনও কখনও
          অর্ডার বা সাজানো বাইনারি গাছগুলি বলা হয়, একটি বিশেষ ধরণের পাত্রে: মেমরির
          মধ্যে &quot;আইটেম&quot; (যেমন নম্বর, নাম ইত্যাদি) সংরক্ষণ করে এমন তথ্য কাঠামো।
          তারা দ্রুত অনুসন্ধান, আইটেমগুলি যোগ এবং অপসারণের অনুমতি দেয় এবং আইটেমগুলির
          গতিশীল সেটগুলি, বা সন্ধানের টেবিলগুলি প্রয়োগ করতে ব্যবহার করতে পারে যা তার
          কী দ্বারা আইটেমটি খুঁজে পেতে অনুমতি দেয় (যেমন, নাম অনুসারে একজন ব্যক্তির
          ফোন নম্বর সন্ধান করা)'
      b_tree:
        title: বি-গাছ
        description: কম্পিউটার বিজ্ঞানে, একটি বি-ট্রি একটি স্ব-ভারসাম্যপূর্ণ গাছের তথ্য
          গঠন যা তথ্যকে সাজিয়ে রাখে এবং অনুসন্ধান, ক্রমিক অ্যাক্সেস, সন্নিবেশ এবং লগারিদমিক
          সময় মুছে ফেলার অনুমতি দেয়। বি-ট্রি একটি বাইনারি অনুসন্ধান গাছের সাধারণীকরণ
          যা একটি নোডের মধ্যে দুই বাচ্চা থাকতে পারে (স্ব-ভারসাম্য বাইনারি অনুসন্ধান
          গাছের মত, বি-ট্রিটি সিস্টেমগুলির জন্য অপ্টিমাইজ করা হয় যা বড় ব্লক ডেটা পড়তে
          এবং লিখতে পারে। B- গাছ বহিরাগত মেমরির জন্য একটি তথ্য কাঠামোর একটি ভাল উদাহরণ।
          এটি সাধারণত ডেটাবেস এবং ফাইল সিস্টেমে ব্যবহৃত হয়।
      binary_heap:
        title: বাইনারি হিপ
        description: একটি বাইনারি হিপ একটি হিপ-অর্ডার সম্পূর্ণ বাইনারি ট্রি যা একটি
          অ্যারে ব্যবহার করে প্রয়োগ করা হয়। একটি হিপের মধ্যে ক্ষুদ্রতম কীটি রুটে পাওয়া
          যায় এবং রুট সর্বদা অ্যারের প্রথম অবস্থানে পাওয়া যায়, কারণ ক্ষুদ্রতম কীটি
          বাইনারি হিপের মধ্যে একটি তুচ্ছ অপারেশন।
      credits: 'কোড এবং নিবন্ধ সম্পদ থেকে নেওয়া হয়েছে:'
      source: এই পৃষ্ঠায় ব্রুনো আর প্রিসের &quot;রুবিতে অবজেক্ট-ওরিয়েন্টেড ডিজাইন
        প্যাটার্নস সহ ডেটা স্ট্রাকচারস এবং অ্যালগরিদম&quot; বইয়ের রুবি কোড রয়েছে।
        কপিরাইট (গ) 2004 ব্রুনো আর। প্রিস, পি। এনএন। সর্বস্বত্ব সংরক্ষিত.
  design_patterns:
    title: নকশা নিদর্শন
    creational:
      title: ক্রিয়েশন নিদর্শন
      description: সফ্টওয়্যার প্রকৌশলতে, ক্রিশ্চিয়াল নকশা নিদর্শন নকশা নকশার যা বস্তুর
        সৃষ্টি প্রক্রিয়াগুলির সাথে মোকাবিলা করে, পরিস্থিতি অনুসারে উপযুক্তভাবে বস্তু
        তৈরি করার চেষ্টা করে। অবজেক্ট তৈরির মৌলিক রূপটি ডিজাইনের সমস্যা বা ডিজাইনের
        সাথে যুক্ত জটিলতার ফলে হতে পারে। ক্রিয়েশিয়াল নকশা নিদর্শন কোনভাবে এই বস্তু
        সৃষ্টি নিয়ন্ত্রণ দ্বারা এই সমস্যা সমাধান। ক্রিয়েশনাল নকশা নিদর্শন দুটি প্রভাবশালী
        ধারনা গঠিত হয়। এক সিস্টেমের ব্যবহার কংক্রিট ক্লাস সম্পর্কে জ্ঞান encapsulating
        হয়। অন্য কংক্রিট ক্লাসের উদাহরণগুলি কীভাবে তৈরি এবং মিলিত হয় তা গোপন করছে।
      abstract_factory:
        title: সারাংশ কারখানা প্যাটার্ন
        description: বিমূর্ত কারখানা প্যাটার্ন তাদের কংক্রিট ক্লাস নির্দিষ্ট না করে
          একটি সাধারণ থিম আছে একটি পৃথক কারখানা একটি গ্রুপ encapsulate করার একটি উপায়
          প্রদান করে। স্বাভাবিক ব্যবহারের ক্ষেত্রে, ক্লায়েন্ট সফ্টওয়্যার বিমূর্ত কারখানাটির
          একটি কংক্রিট বাস্তবায়ন তৈরি করে এবং তারপর থিমের অংশগুলির কংক্রিট বস্তুগুলি
          তৈরি করতে ফ্যাক্টরির জেনেরিক ইন্টারফেস ব্যবহার করে। ক্লায়েন্ট জানেন না (অথবা
          যত্ন) কোন অভ্যন্তরীণ কারখানাগুলির প্রতিটি থেকে এটি কংক্রিট বস্তুগুলি পায়,
          কারণ এটি কেবল তাদের পণ্যগুলির জেনেরিক ইন্টারফেসগুলি ব্যবহার করে। এই প্যাটার্নটি
          তাদের সাধারণ ব্যবহার থেকে বস্তুর একটি সেট বাস্তবায়ন সম্পর্কিত বিবরণ আলাদা
          করে এবং বস্তুর গঠনকে নির্ভর করে, কারন বস্তুর সৃষ্টি কারখানার ইন্টারফেসে উদ্ভূত
          পদ্ধতিগুলিতে বাস্তবায়িত হয়।
      builder:
        title: বিল্ডার প্যাটার্ন
        description: বিল্ডার প্যাটার্ন একটি বস্তু সৃষ্টি সফটওয়্যার নকশা প্যাটার্ন হয়।
          বিমূর্ত কারখানা প্যাটার্ন এবং ফ্যাক্টরি পদ্ধতির প্যাটার্নের মত যার উদ্দেশ্য
          হল পলিমারফিজম সক্ষম করা, বিল্ডার প্যাটার্নের উদ্দেশ্য হল টেলিস্কোপিং কনস্ট্রাক্টর
          বিরোধী-প্যাটার্নের সমাধান [উদ্ধৃতি প্রয়োজন]। টেলিস্কোপিং কন্সট্রাকটর অ্যান্টি-প্যাটার্ন
          ঘটে যখন বস্তুর গঠনকারী প্যারামিটার সংমিশ্রণ বৃদ্ধি কন্সট্রকটারগুলির একটি সূচকীয়
          তালিকার দিকে পরিচালিত করে। অসংখ্য কন্সট্রাক্টর ব্যবহার করার পরিবর্তে, বিল্ডার
          প্যাটার্ন অন্য বস্তুর ব্যবহার করে, একটি নির্মাতা, যা ধাপে প্রতিটি প্রারম্ভিক
          প্যারামিটার ধাপ পায় এবং তারপরে একবার তৈরি হওয়া বস্তুটিকে একবারে ফেরত দেয়।
      factory:
        title: কারখানা প্যাটার্ন
        description: ক্লাস ভিত্তিক প্রোগ্রামিংতে, ফ্যাক্টরি পদ্ধতির প্যাটার্ন একটি ক্রিয়েশনাল
          প্যাটার্ন যা বস্তু তৈরির সমস্যাটির সমাধান করার জন্য কারখানার পদ্ধতিগুলি ব্যবহার
          করে এমন বস্তুর সঠিক শ্রেণী নির্দিষ্ট করে না। এটি একটি কারখানা পদ্ধতিতে কল
          করে বস্তুগুলি তৈরি করে তৈরি করা হয়-যা একটি ইন্টারফেসে উল্লেখ করা হয় এবং
          শিশু শ্রেণীর দ্বারা প্রয়োগ করা হয়, বা বেস ক্লাসে প্রয়োগ করা হয় এবং কন্সট্রাকটরকে
          কল করার পরিবর্তে বিকল্পভাবে বর্ধিত শ্রেণীর দ্বারা বর্ধিত করা হয়।
      prototype:
        title: প্রোটোটাইপ প্যাটার্ন
        description: প্রোটোটাইপ প্যাটার্ন কারখানার লাইন বরাবর একটি ক্রিয়েশনাল প্যাটার্ন।
          প্রোটোটাইপের সাহায্যে আপনি একটি মাস্টার অবজেক্ট অনুলিপি করে নতুন বস্তু তৈরি
          করেন। যে মাস্টার অবজেক্টটি এবং আপনি যে সমস্ত পরবর্তী বস্তু তৈরি করেছেন তা
          পরিবর্তনটির একটি অনুলিপি দিয়ে জীবনের মধ্যে চলে যাবে।
      singleton:
        title: এককোন প্যাটার্ন
        description: একটি বর্গ নিশ্চিত করুন শুধুমাত্র একটি উদাহরণ আছে, এবং এটি অ্যাক্সেস
          একটি বিশ্বব্যাপী পয়েন্ট প্রদান। সিস্টেমটি জুড়ে ক্রিয়াগুলির সমন্বয় করতে
          একেবারে একটি বস্তুর প্রয়োজন হলে এটি কার্যকর। ধারণাটি কখনও কখনও এমন সিস্টেমে
          সাধারণীকরণ করা হয় যা কেবলমাত্র একটি বস্তুর উপস্থিতিতে আরও দক্ষতার সাথে কাজ
          করে, বা তা নির্দিষ্ট কিছু বস্তুর তাত্ক্ষণিকভাবে সীমাবদ্ধ করে।
      not_covered:
        title: 'ঢেকে নিদর্শন না:'
        lazy: অলস সূচনা
        multiton: multiton
        pool: বস্তু পুল
        resource: রিসোর্স অধিগ্রহণ শুরু হয়
    structural:
      title: কাঠামোগত নিদর্শন
      description: সফ্টওয়্যার প্রকৌশল, কাঠামোগত নকশা নিদর্শন নকশা নিদর্শন যে সত্তা
        মধ্যে সম্পর্ক বুঝতে একটি সহজ উপায় সনাক্ত করে নকশা সহজ করে নকশা নিদর্শন।
      adapter:
        title: অ্যাডাপ্টারের প্যাটার্ন
        description: সফ্টওয়্যার প্রকৌশলতে, অ্যাডাপ্টার প্যাটার্ন একটি সফটওয়্যার নকশা
          প্যাটার্ন যা একটি বিদ্যমান ক্লাসের ইন্টারফেসকে অন্য ইন্টারফেস হিসাবে ব্যবহার
          করার অনুমতি দেয়। এটি বিদ্যমান উত্সগুলি তাদের সোর্স কোড সংশোধন না করে অন্যদের
          সাথে কাজ করার জন্য প্রায়ই ব্যবহৃত হয়।
      composite:
        title: যৌগিক প্যাটার্ন
        description: যৌগিক নকশা প্যাটার্ন একটি স্ট্রাকচারাল প্যাটার্ন যা হায়ারার্কিকাল
          ট্রি স্ট্রাকচার রয়েছে এমন বস্তুগুলি উপস্থাপন করতে ব্যবহৃত হয়। এটা পৃথক পাতা
          নোড এবং অনেক নোড গঠিত শাখার অভিন্ন চিকিত্সা জন্য অনুমতি দেয়।
      decorator:
        title: সজ্জা প্যাটার্ন
        description: অবজেক্ট-ভিত্তিক প্রোগ্রামিংতে, সজ্জাকারী প্যাটার্ন (অ্যাডাপ্টার
          প্যাটার্নের সাথে ভাগ করা বিকল্প নামকরণের রেপার হিসাবেও পরিচিত, সজ্জাকারী প্যাটার্ন)
          একটি নকশা প্যাটার্ন যা আচরণকে অন্য কোনও বস্তুকে প্রভাবিত না করে স্ট্যাটিক্যালি
          বা গতিশীলভাবে পৃথক বস্তুতে যুক্ত করতে দেয়। একই ক্লাস থেকে বস্তু। শোভাকর প্যাটার্ন
          প্রায়ই একক দায়িত্বশীল নীতি অনুসরণ করার জন্য দরকারী হয়, কারণ এটি কার্যকারিতার
          অনন্য এলাকার সাথে ক্লাসগুলির মধ্যে কার্যকারিতা ভাগ করার অনুমতি দেয়।
      facade:
        title: Facade প্যাটার্ন
        description: ফ্যাকেড নকশা নকশাটি প্রায়ই ব্যবহৃত হয় যখন সিস্টেমটি খুব জটিল
          বা বুঝতে অসুবিধা হয় কারণ সিস্টেমে প্রচুর সংখ্যক পরস্পরবিরোধী ক্লাস বা তার
          সোর্স কোড অনুপলব্ধ থাকে। এই প্যাটার্নটি বৃহত্তর সিস্টেমের জটিলতাগুলিকে গোপন
          করে এবং ক্লায়েন্টকে সহজ ইন্টারফেস সরবরাহ করে। এটি সাধারণত একটি একক আবর্জনা
          ক্লাস জড়িত যা ক্লায়েন্ট দ্বারা প্রয়োজন সদস্যদের একটি সেট রয়েছে। এই সদস্যরা
          ফ্যাসেড ক্লায়েন্টের পক্ষে সিস্টেমটি অ্যাক্সেস করে এবং বাস্তবায়ন বিবরণ গোপন
          করে।
      flyweight:
        title: ফ্লাইওয়েট প্যাটার্ন
        description: কম্পিউটার প্রোগ্রামিং, ফ্লাইওয়েট একটি সফ্টওয়্যার নকশা প্যাটার্ন।
          একটি ফ্লাইওয়েট এমন বস্তু যা মেমরির ব্যবহারকে অন্যান্য অনুরূপ বস্তুর সাথে
          যতটা সম্ভব ডেটা ভাগ করে কমিয়ে দেয়; এটি একটি সহজ পুনরাবৃত্তি উপস্থাপনা একটি
          অগ্রহণযোগ্য পরিমাণ মেমরি ব্যবহার করবে যখন বড় সংখ্যা বস্তু ব্যবহার করার একটি
          উপায়। প্রায়শই অবজেক্ট স্টেটের কিছু অংশ ভাগ করা যেতে পারে এবং বহিরাগত ডেটা
          স্ট্রাকচারগুলিতে রাখা এবং তাদের ব্যবহার করার সময় এটি সাময়িকভাবে ফ্লাইওয়েট
          বস্তুগুলিতে পাস করার অভ্যাস।
      proxy:
        title: প্রক্সি প্যাটার্ন
        description: 'একটি প্রক্সি, তার সর্বাধিক সাধারণ ফর্ম, অন্য কোনও ইন্টারফেস হিসাবে
          কাজ করছে এমন একটি শ্রেণী। প্রক্সি কিছুতেই ইন্টারফেস করতে পারে: একটি নেটওয়ার্ক
          সংযোগ, মেমরিতে একটি বড় বস্তু, একটি ফাইল, বা অন্য কোনও সংস্থান যা ব্যয়বহুল
          বা অসম্পূর্ণ হওয়া অসম্ভব। সংক্ষেপে, একটি প্রক্সি একটি মোড়ক বা এজেন্ট অবজেক্ট
          যা ক্লায়েন্ট দ্বারা দৃশ্যের পিছনে আসল ভজনা বস্তু অ্যাক্সেস করতে বলা হয়।
          প্রক্সি ব্যবহার কেবল আসল বস্তুর দিকে অগ্রসর হতে পারে, বা অতিরিক্ত যুক্তি সরবরাহ
          করতে পারে। প্রক্সিতে অতিরিক্ত কার্যকারিতা সরবরাহ করা যেতে পারে, উদাহরণস্বরূপ
          ক্যাশিং যখন প্রকৃত বস্তুর ক্রিয়াকলাপগুলি সংস্থান নিবিড় হয়, বা প্রকৃত বস্তুর
          ক্রিয়াকলাপগুলির পূর্বে পূর্বশর্তগুলি পরীক্ষা করা হয়। ক্লায়েন্টের জন্য,
          প্রক্সি অবজেক্টের ব্যবহারটি প্রকৃত বস্তুটি ব্যবহার করা অনুরূপ, কারণ উভয় একই
          ইন্টারফেস বাস্তবায়ন করে।'
      protection_proxy:
        title: সুরক্ষা প্রক্সি
        description: সুরক্ষা প্রক্সি। আপনি একটি এমএনসি কাজ করছেন? যদি তাই হয়, তাহলে
          আমরা প্রক্সি সার্ভার সম্পর্কে সচেতন হতে পারি যা আমাদেরকে ইন্টারনেট ই-মেইল,
          সোশ্যাল নেটওয়ার্কিং, ডেটা স্টোরেজ ইত্যাদির মতো কিছু ধরণের ওয়েবসাইটগুলিতে
          অ্যাক্সেস সীমিত করে প্রদান করে। ম্যানেজমেন্ট মনে করে যে, কিছু সামগ্রী ব্লক
          করা ভাল। শুধুমাত্র কাজ সম্পর্কিত ওয়েব পেজ প্রদান। প্রক্সি সার্ভার যে কাজ
          করে। এই প্রক্সি নকশা প্যাটার্ন একটি প্রকার
      virtual_proxy:
        title: ভার্চুয়াল প্রক্সি
        description: ভার্চুয়াল প্রক্সি। একটি জটিল বা ভারী বস্তুর জায়গায়, একটি কঙ্কাল
          উপস্থাপনা ব্যবহার করুন। যখন একটি অন্তর্নিহিত চিত্র আকারে বিশাল হয়, তখন এটি
          একটি ভার্চুয়াল প্রক্সি বস্তু ব্যবহার করে প্রতিনিধিত্ব করে এবং অন-চাহিদা প্রকৃত
          বস্তুটি লোড করে। আপনি জানেন যে প্রকৃত বস্তু তাত্ক্ষণিকভাবে ব্যয়বহুল এবং তাই
          বাস্তব প্রয়োজন ছাড়া আমরা প্রকৃত বস্তুটি ব্যবহার করতে যাচ্ছি না। প্রয়োজন
          দেখা দিলে আমরা ভার্চুয়াল প্রক্সি ব্যবহার করব।
      remote_proxy:
        title: রিমোট প্রক্সি
        description: রিমোট প্রক্সি। বিতরিত বস্তুর যোগাযোগে, একটি স্থানীয় বস্তু একটি
          দূরবর্তী বস্তুর প্রতিনিধিত্ব করে (যেটি একটি পৃথক ঠিকানা স্পেসের সাথে সম্পর্কিত)।
          স্থানীয় বস্তু দূরবর্তী বস্তুর জন্য একটি প্রক্সি এবং স্থানীয় বস্তুর পদ্ধতি
          আহরণ দূরবর্তী বস্তুর দূরবর্তী পদ্ধতির আহরণের ফলাফলের ফলাফল। একটি এটিএম বাস্তবায়ন
          মনে করুন, এটি দূরবর্তী সার্ভারে বিদ্যমান ব্যাংক তথ্যের জন্য প্রক্সি বস্তুগুলি
          ধরে রাখবে।
      not_covered:
        title: 'ঢেকে নিদর্শন না:'
        callback: Annotated কলব্যাক
        bridge: সেতু
        data_bus: তথ্য বাস
        role: ভূমিকা অবজেক্ট
    behavioral:
      title: আচরণগত নিদর্শন
      description: সফ্টওয়্যার প্রকৌশলতে, আচরণগত নকশার নকশার নকশা নিদর্শনগুলি যা বস্তুর
        মধ্যে সাধারণ যোগাযোগের নিদর্শন সনাক্ত করে এবং এই নিদর্শনগুলি বুঝতে পারে। তাই
        করে, এই নিদর্শন এই যোগাযোগ বহন নমনীয়তা বৃদ্ধি।
      chain_of_responsobility:
        title: দায়িত্ব প্যাটার্ন চেইন
        description: অবজেক্ট-ভিত্তিক নকশাতে, চেইন-এর-দায়িত্ব প্যাটার্ন একটি নকশা প্যাটার্ন
          যা কমান্ড অবজেক্টগুলির একটি উৎস এবং প্রক্রিয়াকরণ বস্তুর একটি সিরিজ ধারণ করে।
          প্রতিটি প্রসেসিং অবজেক্টটিতে লজিক রয়েছে যা কমান্ড অবজেক্টের ধরণের সংজ্ঞায়িত
          করে যা এটি পরিচালনা করতে পারে; বাকি চেইন মধ্যে পরবর্তী প্রক্রিয়াকরণ বস্তুর
          পাস করা হয়। এই চেইন শেষে নতুন প্রক্রিয়াজাতকরণ বস্তু যোগ করার জন্য একটি প্রক্রিয়া
          বিদ্যমান।
      command:
        title: কমান্ড প্যাটার্ন
        description: কমান্ড প্যাটার্ন একটি আচরণ নকশা প্যাটার্ন যা ভবিষ্যতে সময়ে কল
          করার জন্য প্রয়োজনীয় তথ্য সংরক্ষণ করতে ব্যবহৃত হয়। কমান্ড শুধুমাত্র একটি
          বস্তুর মধ্যে আবৃত কর্ম একটি সেট। Ruby দিয়ে, আমরা একটি পৃথক বস্তু তৈরি করার
          প্রয়োজন ছাড়া একই জিনিস করতে প্রসেস ব্যবহার করতে পারেন। কর্মটি যখন সহজ এবং
          এটি সরকারী তথ্য সংরক্ষণের প্রয়োজন হয় না তখন এটি একটি ভাল বিকল্প, অন্যথা,
          কমান্ড ক্লাসটি একটি ভাল বিকল্প।
      interpreter:
        title: ইন্টারপ্রেটার প্যাটার্ন
        description: কম্পিউটার প্রোগ্রামিংয়ে, ইন্টারপ্রেটার প্যাটার্ন একটি নকশা প্যাটার্ন
          যা একটি ভাষাতে বাক্যের মূল্যায়ন কিভাবে নির্দিষ্ট করে। মৌলিক ধারণা একটি বিশেষ
          কম্পিউটার ভাষা প্রতিটি প্রতীক (টার্মিনাল বা nonterminal) জন্য একটি ক্লাস আছে।
          ভাষাতে বাক্যটির সিনট্যাক্স ট্রি কম্পোজিট প্যাটার্নের উদাহরণ এবং ক্লায়েন্টের
          জন্য বাক্যটির মূল্যায়ন (ব্যাখ্যা) করতে ব্যবহৃত হয়।
      iterator:
        title: Iterator প্যাটার্ন
        description: ইটারারেটর ডিজাইন প্যাটার্ন কীভাবে কন্টেইনারটি আসলে উপাদানের প্রতিনিধিত্ব
          করে তা উদ্ঘাটন ছাড়াই একটি ধারকের মধ্যে উপাদানগুলির ক্রমিক অ্যাক্সেস সরবরাহ
          করে। ইটারেটারটি একটি চলমান পয়েন্টার হিসাবে বিবেচিত হতে পারে যা একটি ধারক
          মধ্যে encapsulated উপাদানগুলিতে অ্যাক্সেসের অনুমতি দেয়।
      external_iterator:
        title: বাহ্যিক ইটারেটার প্যাটার্ন
        description: 'বাহ্যিক ইটারারেটর: পুনরাবৃত্তি যুক্তি পৃথক শ্রেণীতে রয়েছে। যতক্ষণ
          না তারা ইন্ডেক্সিংয়ের অনুমতি দেয় ততক্ষণ একাধিক বস্তুর ধরন হ্যান্ডেল করতে
          পুনরাবৃত্তি ক্লাসটি সাধারণকরণ করা যেতে পারে। এটি প্রকৃত পুনরাবৃত্তি করার জন্য
          অতিরিক্ত শ্রেণির প্রয়োজন, তবে তারা আরও বেশি নমনীয়তার জন্য অনুমতি দেয় কারণ
          আপনি পুনরাবৃত্তি নিয়ন্ত্রণ করতে পারেন, কোন উপাদানগুলি পুনরাবৃত্তি করা হয়
          এবং কোন ক্রমে।'
      internal_iterator:
        title: অভ্যন্তরীণ ইয়ারেটর প্যাটার্ন
        description: 'অভ্যন্তরীণ ইটারেটার: সমস্ত পুনরাবৃত্তি যুক্তি সামগ্রিক বস্তুর
          ভিতরে ঘটে। সংখ্যার মধ্যে আপনার যুক্তি পাস করার জন্য একটি কোড ব্লক ব্যবহার
          করুন যা তার প্রতিটি উপাদানগুলির জন্য ব্লকটিকে কল করে।'
      mediator:
        title: মধ্যস্থতা প্যাটার্ন
        description: সাধারণত একটি প্রোগ্রাম ক্লাস বৃহৎ সংখ্যা গঠিত হয়। সুতরাং যুক্তি
          এবং গণনা এই ক্লাসের মধ্যে বিতরণ করা হয়। তবে, বিশেষ করে রক্ষণাবেক্ষণ এবং /
          অথবা পুনর্বিবেচনার সময় কোনও প্রোগ্রামে আরও ক্লাসগুলি বিকশিত হয়, তবে এই ক্লাসগুলির
          মধ্যে যোগাযোগের সমস্যা আরও জটিল হতে পারে। এই প্রোগ্রাম পড়তে এবং বজায় রাখা
          কঠিন করে তোলে। উপরন্তু, প্রোগ্রামটি পরিবর্তন করা কঠিন হতে পারে, যেহেতু কোনও
          পরিবর্তন অন্যান্য ক্লাসগুলিতে কোডকে প্রভাবিত করতে পারে। মধ্যস্থতা প্যাটার্ন
          সঙ্গে, বস্তুর মধ্যে যোগাযোগ একটি মধ্যস্থ বস্তুর সঙ্গে encapsulated হয়। বস্তু
          আর একে অপরের সাথে সরাসরি যোগাযোগ, কিন্তু পরিবর্তে মধ্যস্থতাকারী মাধ্যমে যোগাযোগ।
          এটি যোগাযোগকারী বস্তুর মধ্যে নির্ভরতা হ্রাস করে, যার ফলে কুপলিং কমায়।
      momento:
        title: প্যাটার্ন মুহূর্ত
        description: 'মুহূর্তের প্যাটার্ন তিনটি বস্তুর সাথে প্রয়োগ করা হয়: উত্সাহী,
          একটি তত্ত্বাবধায়ক এবং একটি মুহূর্ত। উত্পাদক একটি বস্তু যে একটি অভ্যন্তরীণ
          রাষ্ট্র আছে। তত্ত্বাবধায়ক প্রবর্তককে কিছু করতে যাচ্ছে, তবে পরিবর্তনটি পূর্বাবস্থায়
          ফিরিয়ে আনতে সক্ষম হতে চায়। তত্ত্বাবধায়ক প্রথমে একটি ক্ষুদ্র বস্তুর জন্য
          উত্সাহককে জিজ্ঞাসা করে। তারপর এটা যে কোন অপারেশন (বা অপারেশন ক্রম) করতে যাচ্ছে।
          অপারেশন করার আগে রাষ্ট্র ফিরে আসার জন্য, এটি উত্সাহী মুহূর্তে বস্তু প্রদান
          করে। মুহূর্তের বস্তুটি নিজেই একটি অপ্রকাশিত বস্তু (যা একজন তত্ত্বাবধায়ক,
          পরিবর্তন বা পরিবর্তন করতে পারে না)। এই প্যাটার্ন ব্যবহার করার সময়, উদ্ভাবক
          অন্য বস্তু বা সংস্থানগুলি পরিবর্তন করতে পারে যদি যত্ন নেওয়া উচিত - মুহূর্তের
          প্যাটার্ন একক বস্তুর উপর পরিচালনা করে।'
      observer:
        title: পর্যবেক্ষক প্যাটার্ন
        description: পর্যবেক্ষক প্যাটার্ন একটি সফ্টওয়্যার নকশা প্যাটার্ন যা কোনও বস্তুটিকে
          বিষয় বলে অভিহিত করে, তার উপর নির্ভরশীলদের একটি তালিকা বজায় রাখে, পর্যবেক্ষক
          বলে অভিহিত করে এবং তাদের স্বয়ংক্রিয়ভাবে কোনও পদ্ধতিতে কল করে কোনও রাষ্ট্র
          পরিবর্তনগুলির সূচনা করে। এটি প্রধানত বিতরণ ইভেন্ট হ্যান্ডলিং সিস্টেম বাস্তবায়নের
          জন্য ব্যবহৃত হয়। অবজেক্টর প্যাটার্ন এছাড়াও পরিচিত মডেল-ভিউ-কন্ট্রোলার (এমভিসি)
          স্থাপত্য প্যাটার্ন একটি মূল অংশ। পর্যবেক্ষক প্যাটার্নটি প্রায় সমস্ত GUI টুলকিট
          সহ প্রোগ্রামিং প্রোগ্রামিং এবং সিস্টেমগুলিতে প্রয়োগ করা হয়।
      state:
        title: রাষ্ট্র প্যাটার্ন
        description: রাষ্ট্র প্যাটার্ন একটি আচরণগত সফ্টওয়্যার নকশা প্যাটার্ন যা একটি
          বস্তু ভিত্তিক ভাবে একটি রাষ্ট্র মেশিন প্রয়োগ করে। রাষ্ট্রের প্যাটার্নের সাথে,
          প্রতিটি রাষ্ট্রকে রাষ্ট্রীয় প্যাটার্ন ইন্টারফেসের একটি প্রাপ্ত শ্রেণি হিসাবে
          রূপান্তরিত করে, এবং প্যাটার্নের সুপারক্লাস দ্বারা সংজ্ঞায়িত পদ্ধতিগুলি প্রয়োগ
          করে রাষ্ট্র পরিবর্তনগুলি বাস্তবায়নের মাধ্যমে একটি রাষ্ট্র মেশিন বাস্তবায়িত
          হয়।
      strategy:
        title: কৌশল প্যাটার্ন
        description: কৌশল আলগোরিদিম এটি ব্যবহার করে ক্লায়েন্টদের থেকে স্বাধীনভাবে পরিবর্তিত
          হতে দেয়। কৌশল গামা এট আল দ্বারা প্রভাবশালী বই নকশা প্যাটার্নস অন্তর্ভুক্ত
          নিদর্শন এক। যে সফটওয়্যার নকশা বর্ণনা নিদর্শন ব্যবহার করে ধারণা জনপ্রিয়।
          উদাহরণস্বরূপ, কোনও শ্রেণী যা ইনকামিং ডেটাতে বৈধতা সম্পাদন করে সেটি ডেটার ধরন,
          ডেটা উৎস, ব্যবহারকারী পছন্দ বা অন্যান্য বৈষম্যমূলক বিষয়গুলির উপর ভিত্তি করে
          একটি বৈধতা অ্যালগরিদম নির্বাচন করতে একটি কৌশল প্যাটার্ন ব্যবহার করতে পারে।
          এই কারণগুলি রান-টাইম পর্যন্ত প্রতিটি ক্ষেত্রে পরিচিত হয় না এবং সঞ্চালিত হওয়ার
          জন্য মূলত বিভিন্ন বৈধতা প্রয়োজন হতে পারে। বৈধকরণ বস্তুর থেকে আলাদাভাবে যাচাই
          করা বৈধতা কৌশল, কোড অনুলিপি ছাড়াই সিস্টেমের বিভিন্ন এলাকায় (বা এমনকি বিভিন্ন
          সিস্টেম) অন্যান্য বৈধকরণ বস্তু দ্বারা ব্যবহার করা যেতে পারে।
      template:
        title: টেম্পলেট পদ্ধতি প্যাটার্ন
        description: অবজেক্ট-ভিত্তিক প্রোগ্রামিংতে প্রথম শ্রেণীটি তৈরি করা হয় যা একটি
          অ্যালগরিদম নকশাটির প্রাথমিক পদক্ষেপ সরবরাহ করে। এই পদক্ষেপ বিমূর্ত পদ্ধতি
          ব্যবহার করে প্রয়োগ করা হয়। পরে, উপশ্রেণীগুলি বাস্তব কর্ম বাস্তবায়নের জন্য
          বিমূর্ত পদ্ধতিগুলি পরিবর্তন করে। সুতরাং সাধারণ অ্যালগরিদম এক জায়গায় সংরক্ষিত
          হয় তবে উপকণ্ঠগুলি দ্বারা কংক্রিট পদক্ষেপগুলি পরিবর্তিত হতে পারে।
      visitor:
        title: ভিজিটর প্যাটার্ন
        description: অবজেক্ট-ভিত্তিক প্রোগ্রামিং এবং সফটওয়্যার ইঞ্জিনিয়ারিংতে, দর্শকের
          নকশা প্যাটার্নটি কোনও বস্তুর গঠন থেকে আলগোরিদিম আলাদা করার একটি উপায় যা এটি
          পরিচালনা করে। এই বিচ্ছেদ একটি বাস্তব ফলাফল সেই কাঠামো পরিবর্তন ছাড়া বিদ্যমান
          বস্তুর কাঠামো নতুন অপারেশন যোগ করার ক্ষমতা। এটি খোলা / বন্ধ নীতি অনুসরণ করার
          এক উপায়। পরিপ্রেক্ষিতে, পরিদর্শক শ্রেণীকে সংশোধন না করে ক্লাসের একটি পরিবারের
          নতুন ভার্চুয়াল ফাংশন যোগ করতে পারবেন; পরিবর্তে, একজন ভিজিটর ক্লাস তৈরি করে
          যা ভার্চুয়াল ফাংশনের যথাযথ দক্ষতাগুলি প্রয়োগ করে। দর্শক ইনপুট হিসাবে ইনপুট
          রেফারেন্স লাগে, এবং ডবল প্রেরণ মাধ্যমে লক্ষ্য প্রয়োগ।
      not_covered:
        title: 'ঢেকে নিদর্শন না:'
        hierarchical: অনুক্রমিক পরিদর্শক
      credits: 'কোড এবং নিবন্ধ সম্পদ থেকে নেওয়া হয়েছে:'
  functional_programming:
    title: কার্যকরী প্রোগ্রামিং
    description: 'একটি কার্যকরী শৈলীতে একটি ভাষা ব্যবহার করে বোঝায় যে আপনার নীচে তালিকাভুক্ত
      কয়েকটি কী বৈশিষ্ট্য অ্যাক্সেস আছে:'
    axioms:
      immutable: 'অপরিবর্তনীয় মান: একবার একটি &quot;পরিবর্তনশীল&quot; সেট করা হয়,
        এটি পরিবর্তন করা যাবে না। রুবিতে, এর অর্থ হল আপনি কার্যকরভাবে স্ট্রাকচারগুলির
        মতো ভেরিয়েবলগুলি চিকিত্সা করতে হবে।'
      side_effects: 'কোন পার্শ্ব প্রতিক্রিয়া: যখন প্রদত্ত মান পাস করে, একটি ফাংশন সবসময়
        একই ফলাফল ফিরে করতে হবে। এই হস্তান্তরযোগ্য মান থাকার হাতে হাতে যায়; একটি ফাংশন
        কোনও মূল্য গ্রহণ করতে পারে না এবং এটি পরিবর্তন করতে পারে না, এটি একটি পার্শ্ব
        প্রতিক্রিয়া সৃষ্টি করবে যা ফলাফলটি ফেরত দেওয়ার জন্য টেনশিয়াল।'
      pure_functions: 'উচ্চ-ক্রম ফাংশন: এটি এমন ফাংশন যা আর্গুমেন্ট হিসাবে ফাংশনগুলিকে
        অনুমতি দেয় বা ফিরতি মান হিসাবে ফাংশনগুলি ব্যবহার করে। এই, যুক্তিযুক্ত, কোনো
        কার্যকরী ভাষা সবচেয়ে গুরুত্বপূর্ণ বৈশিষ্ট্য এক।'
      applying: 'Currying: উচ্চ-ক্রম ফাংশন দ্বারা সক্ষম, কারিরিং একটি ফাংশন রূপান্তরিত
        করছে যা একটি ফাংশনটিতে একাধিক আর্গুমেন্ট নেয় যা এক আর্গুমেন্ট নেয়। এটি আংশিক
        ফাংশন অ্যাপ্লিকেশনের সাথে হাতে যায় যা একটি বহু-যুক্তি ফাংশনকে এমন ফাংশনে রূপান্তরিত
        করে যা কম আর্গুমেন্টগুলি নেয় তবে এটি মূলত।'
      recursion: 'পুনরাবৃত্তি: নিজেই থেকে একটি ফাংশন কলিং দ্বারা looping। যখন আপনি পরিবর্তনযোগ্য
        ডেটাতে অ্যাক্সেস না পান, তখন পুনর্নির্মাণটি তৈরি এবং চেইন ডেটা নির্মাণের জন্য
        ব্যবহার করা হয়। লুপিং একটি কার্যকরী ধারণা নয় কারণ এটি একটি নির্দিষ্ট সময়ে
        লুপের অবস্থা সংরক্ষণের জন্য ভেরিয়েবলগুলিকে পাস করতে হবে।'
      lazy: 'অলস-মূল্যায়ন, বা বিলম্বিত মূল্যায়ন: প্রকৃতপক্ষে এটি প্রয়োজন হয় মুহূর্ত
        পর্যন্ত প্রক্রিয়া প্রক্রিয়াকরণ বিলম্বিত। উদাহরণস্বরূপ, যদি আপনার কিছু কোড
        থাকে যা অলস-মূল্যায়ন সক্ষম করে Fibonacci সংখ্যার জেনারেটেড তালিকা তৈরি করে
        তবে প্রকৃতপক্ষে এটি প্রক্রিয়া এবং গণনা করা হবে না যতক্ষন না ফলাফলের মানগুলির
        মধ্যে অন্যতম কোনও ফাংশন যেমন, রাখে।'
    pure_functions:
      title: বিশুদ্ধ ফাংশন
      description: আপনি দেখতে পারেন যে এই ফাংশন শুধুমাত্র তার আর্গুমেন্ট ব্যবহার করে
        ফলাফল গণনা করে।
    closures:
      title: বন্ধ
      description: Lambda এছাড়াও একটি বন্ধ প্রযোজ্য এবং তাই বস্তু জুড়ে তাদের প্রসঙ্গ
        রাখতে সক্ষম।
    applying:
      title: আংশিক আবেদন এবং বহন
      description: আসুন প্রথমে বুঝি ফাংশনগুলির এই দুটি বিভিন্ন অ্যাপ্লিকেশন কী। আংশিক
        ফাংশন অ্যাপ্লিকেশন একটি ফাংশন পেতে কিছু আর্গুমেন্ট সহ একটি ফাংশন কল করছে যে
        অনেক কম আর্গুমেন্ট নিতে হবে। Currying একটি ফাংশন গ্রহণ করা হয় যে এন আর্গুমেন্ট
        লাগে, এবং এটি একটি ফাংশন যে এন ফাংশন মধ্যে বিভক্ত।
      proc: এই দুইটি জিনিস প্রতিটি একটি ফাংশন করবে কি একটি পরিষ্কার ধারণা দিতে, একটি
        উদাহরণ প্র্যাক গ্রহণ করা যাক।
      partial: এই ফাংশনের আংশিক আবেদনটি যদি আমরা প্রথম দুটি আর্গুমেন্টে পাস করি, তবে
        নিম্নলিখিত নীচের প্রক্রিয়াগুলি অনুসরণ করা হবে।
      curry: <span class="code-inline">.curry</span> একটি curried proc ফিরে। যদি ঐচ্ছিক
        arity যুক্তি দেওয়া হয়, এটি আর্গুমেন্ট সংখ্যা নির্ধারণ করে। একটি curried প্রসেস
        কিছু আর্গুমেন্ট পায়। যদি যথেষ্ট সংখ্যক আর্গুমেন্ট সরবরাহ করা হয় তবে এটি সরবরাহকৃত
        আর্গুমেন্টগুলি মূল প্রসেসে প্রেরণ করে এবং ফলাফলটি প্রদান করে। অন্যথায়, অন্য
        আর্কাইভ proc ফিরে দেয় যে বাকি আর্গুমেন্ট লাগে।
  gotchas:
    title: Gotchas
    description1: Rails অন অধিকাংশ রুবি ফ্রেমওয়ার্ক দ্বারা উত্তেজিত পেতে এবং ভাষা কোন
      জ্ঞান ছাড়া অ্যাপ্লিকেশন কাস্টমাইজ শুরু। এবং যে RoR এর জাদু।
    description2: কিছু সময়ে জিনিষ গুরুতর পেতে শুরু। কিছু রুবি অন রুবি এর নোংরা গোপন
      বিষয়গুলি অনুসন্ধানের জন্য সময় ও প্রচেষ্টার সময় নেয়, অন্যরা চিত্কার করে এবং
      ভাষা সম্পর্কে প্রায় শূন্য জ্ঞান সহ সিনিয়র ডেভেলপার হয়ে ওঠে।
    description3: যাইহোক, যত তাড়াতাড়ি বা পরে, শুরু বা অভিজ্ঞ প্রোগ্রামাররা, আমরা সবাই
      তথাকথিত রুবি গোটচাসে চালিত - যারা ক্ষুদ্র ভাষা subtleties যা আমাদের সাইট থেকে
      কয়েক ঘন্টা হার্ড ডিবাগিংয়ের জন্য লুকিয়ে থাকে।
    description4: এখানে জনপ্রিয় রুবি গোথাস এবং কৌতূহলগুলির একটি তালিকা যা ডেভেলপারদের
      সচেতন হওয়া উচিত। প্রতিটি ক্ষেত্রে, বিভ্রান্তিকর এবং / অথবা ত্রুটি-প্রবণ কোডের
      একটি উদাহরণ রয়েছে।
    description5: তারা ভাল অভ্যাসগুলির সাথে একত্রে আসে, যা আপনাকে সহজ (কিন্তু খুঁজে
      পাওয়া কঠিন) করতে এবং আপনার (এবং আপনার কোড রক্ষণাবেক্ষণকারী) জীবনকে সরল করে তুলতে
      বাধা দেয়।
    surprising:
      title: রুবি বিস্ময়কর হতে পারে
      description: যদিও &quot;কমপক্ষে অবাক হওয়ার নীতি&quot; দিয়ে &quot;প্রোগ্রামার
        সুখকে সর্বোচ্চ করার জন্য প্রকৌশলী&quot;, রুবি এখনও আছে। এই উপস্থাপনাটি আরও উন্নত
        এবং বিভ্রান্তিকর গোচাসে, নবাগত তুচ্ছ গোচচ থেকে এগিয়ে যাবে।
    quotes:
      title: এই সম্পর্কে উদ্ধৃত করবেন না, কিন্তু ...
      description: স্ট্রিং ইন্টারপোলেশন (<span class="code-inline">\ n</span> মত বিশেষ
        অক্ষর সহ) <span class="code-inline">&#39;একক&#39;</span> উদ্ধৃতি দিয়ে ব্যর্থ
        হয় - এটি <span class="code-inline">&quot;দ্বিগুণ&quot;</span> উদ্ধৃতির প্রয়োজন।
        শুধু স্ট্রিং interpolation সঙ্গে অধিকাংশ ভাষায় মত। এটি ব্যবহারিক দ্বিগুণ ব্যবহার
        এড়ানোর জন্য।
    twue:
      title: এটা দুবার! এটা দুবার!
      description: 'শুধুমাত্র দুটি জিনিস মিথ্যা: <span class="code-inline">false</span>
        এবং <span class="code-inline">nil</span> । অন্য সব সত্যই, এমনকি <span class="code-inline">0</span>
        (সি-তে মিথ্যা), <span class="code-inline">&quot;&quot;</span> (জেসে মিথ্যা),
        <span class="code-inline">[]</span> ইত্যাদি ইত্যাদি সি, জেএস, ইত্যাদি থেকে মানুষকে
        ঘিরে যেখানে এইগুলির মধ্যে কিছু মিথ্যা।'
    symbols_and_strings:
      title: তাকে বাজেয়াপ্ত করা বা তাকে স্ট্রিং করা, প্রতীকীভাবে।
      description: '<span class="code-inline">Symbol != String</span> । এমনকি মুদ্রিত
        যখন একই। Args জন্য ব্যবহার করতে যা মনে রাখবেন। আদর্শভাবে, গ্রহণ করুন এবং কোন
        পদ্ধতিটি ব্যবহার করে তা প্রত্যাশা করুন: &quot;আপনি যা গ্রহণ করেন তাতে উদার হও
        এবং আপনি যা পাঠান তাতে রক্ষণশীল হন।&quot; পোস্টেল এর আইন।'
    string_or_nothing:
      title: স্ট্রিং ... বা কিছুই না!
    constants:
      title: Constants হয় না
      description: প্রাথমিক বড় হাতের অক্ষর রুবি মধ্যে, ধ্রুবক মানে। একটি ধ্রুবক পরিবর্তন
        করার চেষ্টা করুন। ওহ, আপনি একটি সতর্কতা পেতে! BFD। এমনকি হিমায়ন Fixnums জন্য
        কাজ করে না। এটা অ্যারে (সাজানোর) এবং অন্যান্য অন্যান্য বস্তুর জন্য কাজ করে ...
        তিনি foreshadowing বলেন।
    equals:
      title: কিছু অন্যদের তুলনায় আরো সমান
      description: <span class="code-inline">==</span> স্বাভাবিক একই মান, <span class="code-inline">.eql?</span>
        মান এবং বর্গ (1 ফিক্সনাম, 1.0 ভাসমান), <span class="code-inline">.equal?</span>
        একই বস্তু। এটা আসলে অনেক hairier।
    operations:
      title: "&gt; ===! = ==!"
      description: <span class="code-inline">===</span> &quot;কেস সমতা&quot;, যেমন ক্ষেত্রে
        বিবৃতি। একটি ভাল নাম হতে পারে <span class="code-inline">.describes?</span>, অথবা overload।
        <span class="code-inline">.includes?</span> । আবার, এটা আসলে অনেক hairier
        হয়; ক্লাস অবজেক্ট উপর ডক্স দেখুন। ভাষা থেকে মানুষকে যেখানে <span class="code-inline">===</span>
        হয় বস্তু সনাক্তকরণ বা একই মান এবং বর্গ হয়।
    priority:
      title: and != &&, or != ||
      description: '<span class="code-inline">&amp;&amp;</span> 
        এর চেয়ে উচ্চতর অগ্রাধিকার আছে <span class="code-inline">=</span>, সুতরাং <span class="code-inline">x =
        true && false</span> অর্থ <span class="code-inline">x = (true && false)</span> এবং নিম্নতর অগ্রাধিকার রয়েছে, তাই <span
        class="code-inline">x = true and false</span> অর্থ <span class="code-inline">(x
        = true) and false</span> । রুবি স্টাইল গাইড: ব্যবহার করুন <span class="code-inline">&amp;&amp;,
        ||</span> বুলিয়ান এক্সপ্রেশন, <span class="code-inline">and, or</span> নিয়ন্ত্রণ
        প্রবাহ জন্য।'
    sensitive:
      title: তাই সংবেদনশীল হতে হবে না!
      description: হোয়াইটস্পেস সংবেদনশীল? সবসময় না! পার্সার মনে করেন এটি একটি অভিব্যক্তি,
        যেমন একটি যুক্তি, কিন্তু <span class="code-inline">(1, 2)</span> বৈধ রুবি অভিব্যক্তি
        নয়! (সব যুক্তি জরিমানা 1)।
      usage: 'একাধিক যুক্তি দিয়ে: <br/> - কোন বাবা, কোন সমস্যা নেই। <br/> - বাবা /
        ও জায়গা, ঠিক আছে। <br/> - বাবা-মা এবং স্থান, না!'
      methods: '<span class="code-inline">method / num</span> একটি আনুমানিক regex বা
        স্ট্রিং! Ruby আপনি পদ্ধতিতে একটি যুক্তি প্রদান করা হয় মনে হয়। সাধারণ নীতি:
        ব্যালান্সড হোয়াইটস্পেস ব্যবহার করুন; উভয় পক্ষই বা না।'
      arguments: '<span class="code-inline">one -2</span> রুবি মনে করে যে আপনি একটি যুক্তি
        <span class="code-inline">2</span> প্রদান করছেন। <span class="code-inline">+2</span>
        বা এমনকি <span class="code-inline">* 2</span> জন্য একই। আবার: উভয় পক্ষ বা উভয়
        ব্যালান্সড হোয়াইটস্পেস ব্যবহার করুন।'
      stubby: "&quot;Stabby&quot; lambdas (1.9+) পিতামাতা ছাড়া যুক্তি ছাড়া পরে ঐচ্ছিক
        স্পেস parenthes, ঠিক আছে। বাবা পরে স্থান, ঠিক আছে। আবার, বাবা আগে স্থান, না!
        আপডেট: 2.0 মধ্যে স্থির!"
    onto:
      title: ইয়ার @ সম্মুখে!
      description: 'নগ্ন মান একটি অস্থায়ী স্থানীয় পরিবর্তনশীল হয়ে! সমাধান: মনে রাখবেন
        <span class="code-inline">@!</span> (অথবা &quot;স্ব।&quot; অথবা <span class="code-inline">attr_writer,
        attr_accessor</span> ব্যবহার করুন।) জাভা / সি ++ থেকে লোকেদের পেতে দেয়, তাই
        না পাইথন (যা &quot;স্ব।&quot; দরকার)। &quot;আপনি যে পরিবর্তনশীল ব্যবহার চালিয়ে
        যান। আমি মনে করি আপনি এটা মনে করেন মানে মানে না।&quot;। ইনিগো মন্টোয়ায় নেই।'
    variables:
      title: দেখো, এটা @@!
      description: খালি ভর্তি কি দেখি? আমরা এটি যাচাই করার আগে পিতামাতার <span class="code-inline">@@মান</span>
       পরিবর্তন না, বা শিশু এর সব সময়ে! নাকি আমরা? <span class="code-inline">@@ভেরিয়েবলগুলি</span> উপ-শ্রেণীগুলির সাথে ভাগ করা হয় - কেবলমাত্র তারা বিদ্যমান
        নয়, তবে ভেরিয়েবলগুলি নিজেই! সন্তানের <span class="code-inline">@@মানটি প্রকাশ
        করা</span> পিতামাতার পরিবর্তিত হয়েছে, এবং পিতামাতার পরিবর্তিত শিশু সহ। এটি
        একটি @@!
    initialize:
      title: Init (ialize) সঙ্গে বা এটি ছাড়া
      description: বাচ্চাদের কেউ থাকে না শুধুমাত্র পিতামাতার প্রাথমিকভাবে স্বয়ংক্রিয়ভাবে
        চালানো হয়। অন্যথায়, পিতা বা মাতা এর চালানোর জন্য বলা হবে।
    superman:
      title: সুপারম্যান বনাম অদৃশ্য মানুষ
      description: নো-ARG তালিকা সঙ্গে <span class="code-inline">super</span> পাঠায়
        তা আহ্বানকারী স্পষ্ট args সঙ্গে <span class="code-inline">super</span> পেয়েছিলাম
        সেই args পাঠায় কোন args পাঠাতে ব্যবহার খালি ডান বন্ধনী <span class="code-inline">super
        ()</span>
    regexp:
      title: এটা কখন শেষ হবে? (অথবা শুরু?)
      description: 'স্ট্যান্ডার্ড regexps: <span class="code-inlne">^</span> শুরু হয়
        এবং <span class="code-inline">$</span> পুরো স্ট্রিং শেষ হয়। রুবি এর রেজেক্স
        ডিফল্ট multiline, তাই: <span class="code-inline">^</span> শুরু হয় এবং <span
        class="code-inline">$</span> কোন লাইন শেষ হয়! <span class="code-inline">\ A</span>
        শুরু এবং <span class="code-inline">\ Z</span> সমগ্র স্ট্রিংয়ের শেষ। (অথবা \
        z কোন নতুন লাইন অন্তর্ভুক্ত করতে ... যা অন্য গোচা!)'
    any:
      title: অনেক।
      description: '<span class="code-inline">.any?</span> মানে &quot;কোন উপাদান?&quot;
        ব্লক দিয়ে: &quot;যে কেউ ব্লক সত্য না?&quot;। ছাড়া: &quot;কোন সত্য?&quot; অন্তর্নির্মিত
        ব্লক আছে: <span class="code-inline">{ |উপাদান | উপাদান }</span> ।'
    undef:
      title: "(ইউ) ডিফ লেপার্ড"
      description: Iterators (যেমন, বার বা প্রতিটি) পাস ব্লক ঘোষণা ভেরিয়েবল প্রতিটি
        পুনরাবৃত্তির শীর্ষে অনির্দিষ্ট হয়! Iterators বারবার বার কল, তাই প্রতিটি কল
        পরে আবার সুযোগ vars আউট হয়। বিল্ট ইন লুপিং গঠন (যেমন, যখন বা জন্য) ঠিক আছে।
        (অথবা ব্লকের আগে ওয়ার ঘোষণা করুন।)
    freeze:
      title: ফ্রিজ (আর) রে
      description: একটি অ্যারে (বা একটি হ্যাশ) হিমায়িত করা, এটি ধারণকারী আইটেম না।
        স্ট্রিং স্থান পরিবর্তন করা যেতে পারে। এই ভাবে, আপনি স্ট্রিংগুলির একটি হিমায়িত
        অ্যারে একটি প্রদত্ত স্লট সংশোধন করতে পারেন।
    one_is_one:
      title: 1 1 ... এবং তাই আরো হতে হবে!
      description: 'নতুন মান থেকে ফিক্সন পরিবর্তন করা একটি নতুন বস্তু। তারা স্থান পরিবর্তন
        করা যাবে না! সুতরাং, Fixnums একটি হিমায়িত অ্যারে সংশোধন করতে পারবেন না। (ফিক্সনাম
        এবং ইন্টিজারগুলির সাথে ডেমো করার জন্য কোন ব্যাং-পদ্ধতি নেই)। বিটিডব্লিউ: একটি
        ফিক্সন এর <span class="code-inline">object_id/span> <span class="code-inline">value
        * 2 + 1</span>'
    bang:
      title: "(থেকে! ||! থেকে!) ==?"
      description: Bang হিসাবে বিপজ্জনক পদ্ধতি চিহ্নিত করে। কেন? প্রায়শই, রিসিভার পরিবর্তন
        করতে পারে, অ-মোডিং অ-ব্যাং সংস্করণ বনাম। Non-Bang সংস্করণ হিসাবে একই মূল্য ফেরত
        তাদের উপর নির্ভর করবেন না! অনেক পরিবর্তন প্রয়োজন যদি কোন পরিবর্তন প্রয়োজন!
    array:
      title: নিউ গোটচ এর একটি অ্যারে
      description: অবজেক্ট হিসাবে দেওয়া ডিফল্ট মান প্রতিটি স্লট জন্য একই বস্তু! সব
        জন্য একটি mutates ডিফল্ট mutating। ব্লক হিসাবে দেওয়া প্রাথমিক মান প্রতিটি স্লট
        জন্য আলাদাভাবে মূল্যায়ন করা হয়। প্রতিটি জন্য নতুন ওয়ার তৈরি করতে এই ব্যবহার
        করুন।
    hash:
      title: এটি একটি হ্যাশ করা
      description: 'অ্যারে হিসাবে প্রায় একই সমস্যা (এবং সমাধান)। আরো গোচাস: ফাঁকা স্লটে
        যেকোন অ্যাক্সেসে একটি নতুন বস্তু তৈরি করে! নতুন বস্তুর একটি অতিরিক্ত সংখ্যা
        তৈরি করতে পারে; ধ্বংসাবশেষ পরীক্ষা &quot;বাস্তব&quot; বিষয়বস্তু বা গণনা (nil-checking,
        .size, ইত্যাদি)।'
    rescue:
      title: আমাকে উদ্ধার করুন, একটি লাইন নিক্ষেপ করুন, আমি এটি ধরতে চেষ্টা করব!
      description: Ruby ইন, নিক্ষেপ এবং ধরা ব্যতিক্রম জন্য নয়! তারা গভীর নিস্তেজ প্রস্থান
        করতে, উন্নত প্রবাহ নিয়ন্ত্রণ হয়। রুবি ব্যতিক্রম জন্য বাড়াতে এবং উদ্ধার।
    to_str:
      title: to_s VS to_str
      description: '<span class="code-inline">to_s</span> প্রতি বস্তুর উপর সংজ্ঞায়িত
        করা হয় এবং সবসময় কিছু ফেরত হবে। <span class="code-inline">to_str</span> শুধুমাত্র
        স্ট্রিং-মত বস্তুর উপর সংজ্ঞায়িত করা হয়। উদাহরণস্বরূপ, <span class="code-inline"Symbol</span>
        আছে <span class="code-inline">to_str</span> কিন্তু <span class="code-inline">Array</span>
        আছে না। সুতরাং, <span class="code-inline">obj.respond_to?(:to_str)</span> এর
        পরিবর্তে <span class="code-inline">obj.is_a? (String) ব্যবহার</span> করতে পারেন,
        যদি আপনি ডাক টাইপিংয়ের সুবিধা নিতে চান তবে আপনি যে শ্রেণীটি দিয়ে কাজ করছেন
        সেটি নিয়ে <span class="code-inline">String</span> একটি উপসাগর অথবা না.'
    missing:
      title: Method_missing এবং respond_to_missing সমন্বয় প্রয়োজন?
      description: '<span class="code-inline">Method_missing</span> overriding যখন,
        <span class="code-inline">respond_to_missing</span> override মনে রাখবেন <span
        class="code-inline">?</span> যেমন. যখন আপনি কোনও বস্তুটি কোনও পদ্ধতিতে কোনও
        বস্তু ফেরত দেওয়ার পদ্ধতি method_missing ব্যবহার করেন, তখন সর্বদা নিশ্চিত হন
        যে আপনি প্রতিক্রিয়াটি answer_to_missing পুনরায় সংজ্ঞায়িত করবেন? যদি আপনি
        এটি না করেন তবে কিছুই নজরে পড়বে না, তবে অবশেষে আপনি কষ্টের মধ্যে দৌড়ে যাবেন।
        এই ক্লাস বিবেচনা করুন:'
      respond_to: 'কোড প্রচুর (রত্ন বা আপনার নিজের) respond_to উপর নির্ভর করে? (একটি
        ভাল কারণে)। আপনি প্রতিক্রিয়া _to_missing প্যাচ প্রয়োজন? যেমন:'
    exception:
      title: একটি StandardError থেকে উদ্ধার, একটি ব্যতিক্রম নয়
      description: 'ব্যতিক্রম রোধ করবেন না, স্পষ্টভাবে উদ্ধার করা ছাড়ার আগে স্ট্যান্ডার্ড
        ইরাকের ব্যতিক্রম ব্যতিক্রমটি সাধারণভাবে পুনরুদ্ধারযোগ্য ত্রুটিগুলি যেমন সিনট্যাক্স
        ইরেকর, লোড ইরেকর, এবং ইন্টারাপ্টও উদ্ধার করবে। আপনি ব্যতিক্রম ব্যতিক্রম টাইপ
        কোলাইফায়ারটি বাদ দিলে, রুবি শুধুমাত্র স্ট্যান্ডার্ড ইরাক ধরবে, যা সম্ভবত আপনি
        চান:'
    private:
      title: ব্যক্তিগত তথ্য সত্যিই নয়, এবং সব W / ক্লাস পদ্ধতিতে নয়
      description: রুবিতে ক্লাস পদ্ধতিগুলি ব্যক্তিগত করার উপায় আছে, আপনি কেবল কিছু
        হুপ্সের মাধ্যমে লাফিয়ে উঠতে পারবেন। Err, আমি <span class="code-inline">class << self</span>
        সিনট্যাক্স ব্যবহার মানে। এই অদ্ভুততা ক্লাসে কার্যকরভাবে
        ক্লাস পদ্ধতি তৈরির ক্ষেত্রে একটি ইনস্ট্যান্স সিঙ্গলনকে ধাক্কা দেয়।
    braces:
      title: ব্রেস বনাম ডুন্ড
      description: সাধারণ কনভেনশন ব্যবহার করা <span class="code-inline">do .. end</span>
        মাল্টি-লাইন ব্লক এবং একক লাইন ব্লকের জন্য কোঁকড়া ধনুর্বন্ধনীগুলির জন্য <span
        শেষ, কিন্তু চিত্রিত করা যায় এমন দুটিতেও একটি পার্থক্য
        রয়েছে। এর অর্থ হল <span class="code-inline">{}</span> এর চেয়ে বেশি উচ্চতর
        অগ্রাধিকার রয়েছে <span class="code-inline">do .. end</span>, তাই আপনি কী ব্যবহার
        করতে চান তা নির্ধারণ করার সময় মনে রাখবেন।
    module:
      title: 'ক্লাস Foo :: বার, মডিউল ফু এর বাইরে সংজ্ঞায়িত, Foo এর ভিতরে দেখতে হবে
        না'
      description: আপনি মডিউল প্রতিটি চেহারা মনে করতে
        পারেন <span class="code-inline">module Something</span>, <span class="code-inline">class Something</span>
        একটি নতুন সুযোগ মধ্যে একটি &quot;গেটওয়ে&quot; হিসাবে কিছু
        বা <span class="code-inline">def something</span> । রুবি যখন কোন নামটির নাম উল্লেখ
        করে অনুসন্ধান করছে তখন এটি প্রথম সুযোগটি (পদ্ধতি, শ্রেণী বা মডিউল) দেখায় এবং
        যদি এটি পাওয়া যায় না তবে এটি &quot;গেটওয়ে&quot; ধারণকারী প্রতিটি অনুসন্ধানের
        মাধ্যমে কোথায় যাবে সুযোগ আছে।
    credits: 'কোড এবং নিবন্ধ সম্পদ থেকে নেওয়া হয়েছে:'
  meta_programming:
    title: Metaprogramming
    description: মেটাগ্রোগ্রামিং এমন কম্পিউটার প্রোগ্রামগুলির লিখন যা অন্য প্রোগ্রামগুলি
      (অথবা নিজেদের) তাদের তথ্য হিসাবে লিখতে বা ম্যানিপুলেট করে, বা যেটি কম্পাইল সময়তে
      কাজ করে সেগুলি রানটাইম এ অন্যথায় করা হয়। বেশিরভাগ ক্ষেত্রে এটি প্রোগ্রামারগুলিকে
      একই পরিমাণে আরও বেশি কাজ করতে দেয় কারণ তারা সমস্ত কোড নিজে নিজে লিখতে চায়, অথবা
      এটি প্রোগ্রামগুলিকে পুনঃসংযোগ ছাড়াই নতুন পরিস্থিতিতে দক্ষতার সাথে পরিচালনা করার
      জন্য আরও বেশি নমনীয়তা দেয়। Metaprogramming কোড লেখা হয় যে আপনার জীবন সহজ করতে
      রানটাইম সময় কোড লিখতে।
    dynamic_dispatch:
      title: গতিশীল ডিসপ্যাচ
      description: Allows us to send messages <span class=\"code-inline\">subject.public_send(message, *arguments)</span>
    dynamic_method:
      title: গতিশীল পদ্ধতি
      description: 'আমাদের গতিশীলভাবে পদ্ধতি তৈরি করার অনুমতি দেয় <span class="code-inline">define_method:
        method_name {block যা পদ্ধতির শরীর}</span>'
    ghost_methods:
      title: ঘোস্ট পদ্ধতি
      description: '&quot;ঘোস্ট মেথডস&quot; ধরা এবং অন্য পদ্ধতিতে ফরোয়ার্ড করার সময়
        সম্ভবত কলটির চারপাশে যুক্তি যোগ করা। <span class=\"code-inline\">method_missing</span>'
    dynamic_proxies:
      title: গতিশীল প্রক্সি
      description: For example, You can provide imaginary methods by utilising <span class="code-inline">method_missing</span> to parse the incoming message (e.g. <span class="code-inline">get_name</span>, <span class="code-inline">get_age</span>) and to delegate off to another method such as <span class="code-inline">get(:data_type)</span> where <span class="code-inline">:data_type</span> is <span class="code-inline">:name</span> or <span class="code-inline">:age</span>.
      more: যদি (বিশ্লেষণের পরে) আপনি <span class="code-inline">method_missing</span>
        ব্যবহার করে একটি পারফরমেন্স সমস্যা আবিষ্কার করেন তবে প্রথমবারের মতো &#39;method_missing`
        দ্বারা বার্তাটি পাওয়ার পরে আপনি একটি বাস্তব পদ্ধতি তৈরি করতে &quot;ডায়নামিক
        পদ্ধতি&quot; কৌশলটি ব্যবহার করতে পারেন।
  solid_principles:
    good: ভাল!
    bad: খারাপ!
    title: সলিড নীতি
    description: কম্পিউটার প্রোগ্রামিং, SOLID (একক দায়বদ্ধতা, ওপেন-ক্লোড, লিস্কোভ প্রতিস্থাপন,
      ইন্টারফেস বিচ্ছিন্নকরণ এবং নির্ভরতা বিপরীত) হ&#39;ল মাইকেল ফেদারস দ্বারা শুরু
      হওয়া &quot;প্রথম পাঁচটি মূলনীতি&quot; র রবার্ট সি মার্টিনের প্রথম 2000-এর দশকে
      উপস্থাপিত একটি স্মারক আদ্যক্ষর। অবজেক্ট ভিত্তিক প্রোগ্রামিং এবং নকশা পাঁচটি মৌলিক
      নীতির জন্য। অভিপ্রায় হল যে, এই নীতিগুলি, যখন একসাথে প্রয়োগ করা হয়, তখন প্রোগ্রামার
      এমন একটি সিস্টেম তৈরি করবে যা সময়ের সাথে বজায় রাখা এবং সম্প্রসারিত করা সহজতর
      করে। SOLID এর নীতিগুলি এমন নির্দেশিকা যা প্রোগ্রামারকে সফ্টওয়্যারের সোর্স কোডটিকে
      পুনরায় প্রতিক্রিয়া না হওয়া পর্যন্ত কোড গন্ধগুলি মুছে ফেলার জন্য সফ্টওয়্যারগুলিতে
      কাজ করার সময় প্রয়োগ করা যেতে পারে। এটি চাঙ্গা এবং অ্যাডাপ্টিভ সফ্টওয়্যার ডেভেলপমেন্ট
      সামগ্রিক কৌশল অংশ।
    single:
      title: একক দায়িত্ব নীতি
      description: একা দায়বদ্ধতা নীতি গুচ্ছ সবচেয়ে বিমূর্ত। এটি ছোট এবং রক্ষণাবেক্ষণ
        ক্লাস এবং পদ্ধতি রাখতে সাহায্য করে। ক্লাসগুলিকে ছোট এবং ফোকাস করার পাশাপাশি
        এটি বোঝার জন্য তাদের আরও সহজ করে তোলে। এর একটি উদাহরণ প্রক্রিয়াধীন একটি চুক্তি
        চিহ্নিত করার পরে একটি নির্দিষ্ট ব্যক্তির কমিশনের ইমেল সারাংশ পাঠানোর জন্য সহায়তা
        যোগ করা হতে পারে। সিঙ্গলগুলি একক দায়বদ্ধতার নীতি লঙ্ঘনের পরিবর্তন করার জন্য
        আমরা একাধিক কারণ সনাক্ত করতে পারি।
    open_close:
      title: খোলা / বন্ধ নীতি
      description: খোলা / বন্ধ নীতিটি ক্লাস বা পদ্ধতিগুলি এক্সটেনশনটির জন্য খোলা থাকা
        উচিত তবে সংশোধন করার জন্য বন্ধ হওয়া উচিত। এটি আমাদের বলে যে আমাদের মডুলার ডিজাইনের
        জন্য সংগ্রাম করা উচিত যা আমাদের নিজেদের ক্লাসগুলিতে সংশোধন না করে সিস্টেমের
        আচরণ পরিবর্তন করতে পারে। এটি সাধারণত কৌশল প্যাটার্ন হিসাবে নিদর্শন ব্যবহার মাধ্যমে
        অর্জন করা হয়।
      after: এই রিফ্যাক্টর দিয়ে আমরা কোনও কোড পরিবর্তন না করেই নতুন প্যাসার্স যুক্ত
        করতে সক্ষম করেছি। কোন অতিরিক্ত আচরণ শুধুমাত্র একটি নতুন হ্যান্ডলার যোগ করার
        প্রয়োজন হবে। এটি আমাদের ফাইলপ্সার পুনঃব্যবহারযোগ্য করে তোলে এবং অনেক ক্ষেত্রে
        আমাদের একক দায়বদ্ধতা নীতির পাশাপাশি আরও বেশি মনোযোগী ক্লাস তৈরির জন্য আমাদের
        উৎসাহিত করে।
    liskov:
      title: Liskov এর প্রতিস্থাপন নীতি
      description: Liskov এর নীতি বোঝার সবচেয়ে কঠিন হতে থাকে। নীতিটি আপনাকে বলে যে
        আপনি কোনও অপ্রত্যাশিত বা ভুল আচরণ ছাড়াই পিতামাতার ক্লাসের কোনও দৃষ্টান্তকে
        তার সন্তানের দৃষ্টান্ত দ্বারা প্রতিস্থাপন করতে সক্ষম হবেন।
    segregation:
      title: নির্ভরতা বিবর্তন নীতি
      description: 'নীতিটি উল্লেখ করে যে ক্লায়েন্টকে যে পদ্ধতিগুলি ব্যবহার করে না তার
        উপর নির্ভর করতে বাধ্য করা উচিত নয়। এই উদাহরণে কম্পিউটার, প্রোগ্রামার এবং টেকনিশিয়ান
        ক্লাস রয়েছে। প্রোগ্রামার এবং প্রযুক্তিবিদ উভয়ই কম্পিউটারকে অন্যভাবে ব্যবহার
        করে। প্রোগ্রামার টাইপ করার জন্য কম্পিউটার ব্যবহার করেন, কিন্তু প্রযুক্তিবিদ
        জানেন কিভাবে কম্পিউটার হার্ড ড্রাইভ পরিবর্তন করবেন। ইন্টারফেস বিচ্ছিন্নতা নীতি
        (আইএসপি) বলছে যে এক বর্গটি যে পদ্ধতিগুলি ব্যবহার করে না তার উপর নির্ভর করে না।
        আমাদের ক্ষেত্রে, প্রোগ্রামার অপ্রয়োজনীয়ভাবে কম্পিউটার # পরিবর্তন_হার্ড_drive
        পদ্ধতির সাথে মিলিত হয় কারণ এটি এটি ব্যবহার করে না, তবে এই পদ্ধতিটি কার্যকর
        করে এমন প্রোগ্রামটি পরিবর্তন করে যা প্রোগ্রামারকে প্রভাবিত করতে পারে। আসুন এলএসপি
        মেনে চলার জন্য কোডটি রিফ্যাক্টর করি।'
      after: এই রেফেক্টরের পরে প্রযুক্তিবিদ কম্পিউটার কম্পিউটার থেকে বিচ্ছিন্ন কম্পিউটার
        ইন্টারন্যাশনালগুলির থেকে ভিন্ন বস্তু ব্যবহার করেন। কম্পিউটার অবজেক্টের অবস্থা
        প্রোগ্রামার দ্বারা প্রভাবিত হতে পারে তবে পরিবর্তনগুলি যেকোনো উপায়ে প্রযুক্তিবিদকে
        প্রভাবিত করবে না।
    di:
      title: নির্ভরতা বিবর্তন নীতি
      description: ডেভেন্ডেন্সি ইনভারসন নীতিটি নিম্ন-স্তরের (ডেটাবেস ক্যোয়ারিং এবং
        আইও) বাস্তবায়ন বিশদের উপর নির্ভর করে উচ্চ-স্তরের (মনে মনে ব্যবসায়িক যুক্তি)
        বস্তুগুলির সাথে কাজ করতে হবে। এটি হাঁস টাইপিং এবং নির্ভরতা বিবর্তন নীতির সাথে
        অর্জন করা যেতে পারে। প্রায়শই এই প্যাটার্নটি আমরা উপরে আলোচনা করা ওপেন / ক্লোজড
        নীতিটি অর্জন করতে ব্যবহার করি। আসলে, আমরা এই নীতির একটি নীতিমালা হিসাবে একই
        উদাহরণ পুনর্ব্যবহার করতে পারেন। এখন একটি ফরম্যাট শ্রেণী আছে, তবে আমি প্রতিবেদন
        ক্লাসে এটি হার্ডডাকড করেছি, এইভাবে JSONFormatter এ প্রতিবেদন থেকে নির্ভরতা তৈরি
        করছি। যেহেতু প্রতিবেদনটি JSONFormatter এর চেয়ে আরও একটি বিমূর্ত (উচ্চ-স্তরের)
        ধারণা, তাই আমরা কার্যকরভাবে ডিআইপিটি ভাঙ্গছি।
      after: এইভাবে প্রতিবেদনটি JSONFormatter এ নির্ভর করে না এবং ফর্ম্যাট নামক কোনও
        ফর্ম্যাটার ব্যবহার করতে পারে (এটি হাঁসের টাইপিং নামে পরিচিত)। নোট আরেকটি বিষয়
        হল যে আমরা, আবার, একটি সমস্যা সমাধানের জন্য নির্ভরতা ইনজেকশন ব্যবহার করেছেন।
        যখন আমাদের লক্ষ্য বস্তুকে হ্রাস করা হয় তখন এই কৌশলটি খুব শক্তিশালী এক এবং এটি
        নির্ভরতা বিবর্তন নীতি (বনাম নির্ভরতা ইনজেকশন প্যাটার্ন) হিসাবে একই প্রাথমিক
        হিসাবে হলেও, এটি সম্পূর্ণ ভিন্ন ধারণা।
  threads:
    example: উদাহরণ
    title: টপিক
    description: 'সমান্তরালতা এবং সমান্তরাল সম্পর্কে নোট: থ্রেড বনাম থ্রেড ব্যবহার করে
      প্রাথমিক মেমরি মেমরি পরিচালনা করা হয় যে উপায়। একটি উচ্চ স্তরের, প্রসেস মেমরি
      কপি, যখন থ্রেড মেমরি ভাগ। এটি থ্রেড spawning তুলনায় ধীর গতির প্রক্রিয়া করে তোলে
      এবং চলমান একবার আরো সম্পদ ভোগ প্রসেস বাড়ে। সামগ্রিকভাবে, থ্রেড প্রক্রিয়া চেয়ে
      কম ওভারহেড incur। এই থ্রেড API একটি রুবি API। আমি বিভিন্ন Ruby বাস্তবায়ন বিভিন্ন
      অন্তর্নিহিত থ্রেডিং আচরণ আছে যে ইঙ্গিত করেছি।'
    green:
      title: সবুজ থ্রেড
      description: রুবি 1.9 নেটিভ থ্রেড সঙ্গে সবুজ থ্রেড প্রতিস্থাপিত। যাইহোক, জিআইএল
        এখনও সমান্তরাল প্রতিরোধ করা হয়। যে বলেন, concurrency ভাল সময়সূচী মাধ্যমে উন্নত
        করা হয়েছে। নতুন সময়সূচী প্রেক্ষাপটে-সুইচ সিদ্ধান্তগুলি আরও কার্যকরী করে তোলে,
        মূলত তাদেরকে আলাদা স্থানীয় থ্রেডে স্থানান্তরিত করে, যা টাইমার থ্রেড নামে পরিচিত।
    gil:
      title: জিআইএল - গ্লোবাল ইন্টারপ্রেটার লক
      description: এমআরআই একটি গ্লোবাল ইন্টারপ্রেটার লক আছে (GIL)। এটা রবি কোড execution
        কাছাকাছি একটি লক। এর মানে হল যে একাধিক-থ্রেডেড প্রেক্ষাপটে, শুধুমাত্র এক থ্রেড
        রুবি কোডটি যে কোনও সময়ে কার্যকর করতে পারে। সুতরাং 8-কোর মেশিনে 8 টি থ্রেড কাজ
        করে থাকলে কেবলমাত্র একটি থ্রেড এবং একটি কোর কোনও সময়ে ব্যস্ত থাকবে। । জিআইএল
        রুবি অভ্যন্তরীণদের রেস স্ট্যাটাস থেকে রক্ষা করতে পারে যা তথ্য দূষিত করতে পারে।
        ক্যাভিটস এবং অপ্টিমাইজেশান আছে, কিন্তু এই গীতা।
      example: এই সহজ সত্য থ্রেড এত শক্তিশালী করে তোলে, এবং যা তাদের সাথে কাজ করা কঠিন
        করে তোলে। থ্রেড ভাল কেন আমি আপনাকে ইতিমধ্যে একটি ধারণা দিয়েছেন; এখানে তাদের
        অসুবিধা illustrated একটি সহজ প্রোগ্রাম। এখানে আপনি দেখতে পারেন যে আমাদের অ্যারে
        <span class="code-inline">10 * 10000</span> উপাদান রয়েছে। বিভিন্ন Ruby একটি
        ভিন্ন ফলাফল প্রদর্শন করতে পারেন যে নোট করুন। GIL শুধুমাত্র এমআরআই রুবি মধ্যে
        বিদ্যমান।
    mutex:
      title: Mutex - মিউচুয়াল এক্সিকিউশন
      description: কোডের সমালোচনামূলক অংশে অ্যাক্সেস সমলয় করার জন্য Mutexes একাধিক
        থ্রেডগুলির জন্য একটি প্রক্রিয়া সরবরাহ করে। অন্য কথায়, তারা মাল্টি-থ্রেডেড
        বিশৃঙ্খলার জগতে কিছু আদেশ এবং কিছু গ্যারান্টি আনতে সহায়তা করে। নাম &#39;মৌটক্স&#39;
        নামটি &#39;পারস্পরিক বর্জন&#39; এর জন্য শর্ট্যান্ড। যদি আপনি আপনার কোডের কিছু
        অংশকে মু्यूटক্স দিয়ে মোড়ানো করেন তবে আপনি গ্যারান্টি দেন যে একই সময়ে কোনও
        থ্রেড কোনও বিভাগে প্রবেশ করতে পারে না। কোডের সমালোচনামূলক অংশে অ্যাক্সেস সমলয়
        করার জন্য Mutexes একাধিক থ্রেডগুলির জন্য একটি প্রক্রিয়া সরবরাহ করে। এটা মাল্টি-থ্রেড
        বিশৃঙ্খলার বিশ্বের কিছু আদেশ এবং কিছু গ্যারান্টি আনতে সাহায্য করে।
      example: এই প্রোগ্রামে, যেহেতু এটিতে কোনও থ্রেডকে মু्यूटক্স লক করার আগে এটি অ্যারেতে
        ধাক্কা দেওয়ার আগে, কোন গ্যারান্টি নেই যে একই সময়ে দুটি থ্রেড এই অপারেশনটি
        সম্পাদন করবে না। অন্য কথায়, এটি সম্পন্ন হওয়ার আগে এই ক্রিয়াকলাপটি আর বাধা
        দেওয়া যাবে না। একবার এক থ্রেড অ্যারেতে ধাক্কা শুরু করলে, অন্য থ্রেড কোডটির
        সেই অংশটি প্রবেশ করতে পারবে না যতক্ষণ না প্রথম থ্রেডটি শেষ হয়। এই অপারেশন এখন
        থ্রেড নিরাপদ। এখানে আপনি দেখতে পারেন যে আমাদের অ্যারে <span class="code-inline">10
        * 10000</span> উপাদান রয়েছে। এখন সব একই, কারণ mutex। Mutex থ্রেড জন্য একই সীমানা
        সেট আপ। এই বিট কোডটি হিট করে প্রথম থ্রেডটি mutex লক করবে। তারপর যে mutex মালিক
        হয়ে ওঠে। মালিকানাধীন থ্রেডটি বন্ধ না হওয়া পর্যন্ত, অন্য কোন থ্রেড এটি লক করতে
        পারে না।
    fibers:
      title: fibers
      description: Ruby মধ্যে হালকা ওজন সমবায় সমাহার প্রয়োগ করার জন্য fibers primitives
        হয়। মূলত, তারা কোড ব্লকগুলি তৈরি করার একটি মাধ্যম যা থান্ডারগুলির মতো অনেকগুলি
        বিরাম দেওয়া এবং পুনরায় শুরু করতে পারে। প্রধান পার্থক্য হল যে তারা কখনই প্রিপেইড
        হয় না এবং সময়সূচীটি অবশ্যই প্রোগ্রামার দ্বারা করা উচিত এবং ভিএম নয়। অন্যান্য
        স্ট্যাকলেস লাইটওয়েট কনকুরেন্স মডেলগুলির বিরোধিতা করে, প্রতিটি ফাইবার একটি ছোট
        4 কেবি স্ট্যাকের সাথে আসে। এই ফাইবার ব্লক মধ্যে গভীরভাবে Nested ফাংশন কল থেকে
        বিরতি ফাইবার সক্রিয় করতে সক্ষম করে।
    rails:
      title: রেল থ্রেড-নিরাপত্তা
      description: এই সমস্যাটি সম্পূর্ণভাবে একটি থ্রেড-নিরাপদ কিনা তা নিশ্চিত করার কোন
        সহজ উপায় নেই।
      global_variables: গ্লোবাল ভেরিয়েবল গ্লোবাল। এই তারা থ্রেড মধ্যে ভাগ করা হয় মানে।
        আপনি যদি গ্লোবাল ভেরিয়েবলগুলি ব্যবহার না করে নিশ্চিত না হন তবে এখানে তাদের
        স্পর্শ করার অন্য কোনো কারণ নেই। আপনি যদি সত্যিই কোনও অ্যাপ্লিকেশানে বিশ্বব্যাপী
        কিছু ভাগ করতে চান তবে আপনি কোনও ধ্রুবক (কিন্তু নীচে দেখুন) ভাল পরিবেশিত হয়েছেন।
      class_variables: ক্লাস ভেরিয়েবল। থ্রেড সম্পর্কে আলোচনা করার উদ্দেশ্যে, ক্লাস
        ভেরিয়েবল গ্লোবাল ভেরিয়েবলগুলির থেকে অনেক ভিন্ন নয়। তারা থ্রেড জুড়ে একই ভাবে
        ভাগ করা হয়। সমস্যাটি ক্লাস ভেরিয়েবলগুলি ব্যবহার সম্পর্কে এত বেশি নয়, তবে
        তাদের পরিবর্তন করা সম্পর্কে। এবং যদি আপনি কোন শ্রেণী পরিবর্তনশীলকে পরিবর্তন
        করতে যাচ্ছেন না তবে বেশিরভাগ ক্ষেত্রেই ধ্রুবকটি আরও ভাল পছন্দ হয়।
      instance_variables: ক্লাস দৃষ্টান্ত ভেরিয়েবল। কিন্তু আপনি হয়তো পড়তে পারেন যে
        রুবিতে ক্লাসের ভেরিয়েবলগুলির পরিবর্তে আপনাকে সর্বদা ক্লাস ইনস্ট্যান্স ভেরিয়েবল
        ব্যবহার করতে হবে। আচ্ছা, সম্ভবত আপনার উচিত উচিত, তবে তারা শ্রেণিবদ্ধ প্রোগ্রামগুলির
        জন্য শ্রেণিবদ্ধ প্রোগ্রাম হিসাবে সমস্যাযুক্ত।
      memoization: 'নিজেই দ্বারা স্মরণীকরণ একটি থ্রেড নিরাপত্তা সমস্যা নয়। এটি প্রায়ই
        ক্লাস ভেরিয়েবল বা বর্গ ইনস্ট্যান্স ভেরিয়েবলগুলিতে ডেটা সংরক্ষণ করতে ব্যবহৃত
        হয় (পূর্ববর্তী পয়েন্টগুলি দেখুন)। <span class="code-inline">||=</span> অপারেটর,
        আসলে দুটি অপারেশন, তাই এটির মাঝখানে একটি সম্ভাব্য প্রসঙ্গ সুইচ ঘটছে, যা থ্রেডগুলির
        মধ্যে একটি জাতি শর্ত সৃষ্টি করে। তাই আপনি শুধুমাত্র ইনস্ট্যান্স ভেরিয়েবল ব্যবহার
        করা হবে, যদিও, আপনি memoization সঙ্গে জাতি অবস্থার সঙ্গে শেষ হতে পারে। ক্লাস
        ভেরিয়েবল বা বর্গ ইনস্ট্যান্স ভেরিয়েবলগুলিতে স্মরণ কর না। আপনি যদি শ্রেণির
        স্তরে কিছু স্মরণ করতে চান তবে তার পরিবর্তে থ্রেড স্থানীয় ভেরিয়েবলগুলি ব্যবহার
        করুন থ্রেড. (<span class="code-inline">Thread.current[:baz]</span>)। সচেতন থাকুন,
        যদিও, এটি এখনও একটি বৈশ্বিক পরিবর্তনশীল ধরনের।'
    config:
      title: থ্রেডফাইফ কনফিগার করুন !?
      description: এই পদ্ধতি কল আমাদের অ্যাপ্লিকেশন কনফিগারেশন চারটি অপশন সেট করে। এর
        প্রতিটি বিকল্পের মধ্য দিয়ে হেঁটে চলুন এবং এটি কী করে তা নিয়ে আলোচনা করুন।
      frameworks: 'পূর্বনির্ধারিত ফ্রেমওয়ার্ক: প্রথম বিকল্পটি @preload_frameworks যা
        বলে সেটি বেশ সুন্দর করে তোলে, এটি রেলর ফ্রেমওয়ার্কটিকে বুটে লোড করার জন্য বাধ্য
        করে। যখন এই অপশনটি সক্ষম না হয়, ফ্রেমওয়ার্ক ক্লাস স্বয়ংক্রিয়ভাবে লোড করে
        লোড করা হয়। মাল্টি-থ্রেডেড পরিবেশে, ফ্রেমওয়ার্কটি স্বয়ংক্রিয়ভাবে লোড হওয়া
        অবস্থায় থ্রেড নিরাপত্তা সমস্যাগুলির কারণে কোনও থ্রেড তৈরি হওয়ার আগে উত্সাহিত
        করা প্রয়োজন। আমরা জানি যে ফ্রেমওয়ার্কটি লোড করা থ্রেডফাইফ নয়, সুতরাং কৌশলগুলি
        হ্যান্ডেল করার জন্য প্রস্তুত থাকা কোন থ্রেড প্রস্তুত হওয়ার আগে এটি লোড করতে
        হয়।'
      cache: 'ক্যাশিং ক্লাসগুলি: @cache_classes বিকল্প শ্রেণীগুলি পুনরায় লোড করা হবে
        কিনা তা নিয়ন্ত্রণ করে। মনে রাখবেন আপনার অ্যাপ্লিকেশনে &quot;টিডিডি&quot; করছেন?
        আপনি একটি নিয়ামক সংশোধন করুন, তারপরে পৃষ্ঠাটিকে &quot;পরীক্ষা&quot; করতে পুনরায়
        লোড করুন এবং সেই জিনিসগুলি পরিবর্তিত হয়ে দেখুন? হ্যাঁ, এই বিকল্প নিয়ন্ত্রণ
        কি। যখন এই বিকল্পটি মিথ্যা হয়, তখন উন্নয়ন হিসাবে, যখন এটি সংশোধন করা হয় তখন
        আপনার ক্লাসগুলি পুনরায় লোড করা হবে। এই বিকল্প ছাড়া, আমরা আমাদের &quot;F5DD&quot;
        করতে সক্ষম হব না (হ্যাঁ, এটি F5 চালিত ডেভেলপমেন্ট)। উত্পাদনে, আমরা জানি যে ক্লাসগুলি
        ফ্লাইতে সংশোধন করা যাচ্ছে না, তাই শ্রেণীগুলি পুনরায় লোড করা বা না করা সম্পদগুলি
        নষ্ট করছে কিনা তা নির্ধারণ করার জন্য কাজটি করা হচ্ছে, তাই শ্রেণির সংজ্ঞাগুলিকে
        পুনরায় লোড করতে বোঝা যায় না।'
      di: 'নির্ভরতা লোড হচ্ছে: এই বিকল্পটি, @ dependency_loading অনুপস্থিত স্টোনগুলির
        সম্মুখীন হওয়ার সময় কোড লোডিং নিয়ন্ত্রণ করে। উদাহরণস্বরূপ, একটি নিয়ামক ব্যবহারকারী
        মডেল উল্লেখ করে, কিন্তু ব্যবহারকারী ধ্রুবক সংজ্ঞায়িত করা হয় না। এই ক্ষেত্রে,
        যদি @ dependency_loading সত্য হয়, তবে Rails ফাইলটি খুঁজে পাবে যা ব্যবহারকারী
        ধ্রুবক ধারণ করে এবং সেই ফাইলটি লোড করে। কোড লোডিং থ্রেড নিরাপদ নয় সে সম্পর্কে
        আমরা ইতিমধ্যেই আলোচনা করেছি, তাই এখানে ধারণাটি যে আমাদের ফ্রেমওয়ার্কটি লোড
        করা উচিত, তারপরে সমস্ত ব্যবহারকারী কোড লোড করুন এবং তারপরে নির্ভরতা লোডিং অক্ষম
        করুন। নির্ভরতা লোডিং নিষ্ক্রিয় হয়ে গেলে, ফ্রেমওয়ার্ক কোড এবং অ্যাপ্লিকেশন
        কোড লোড করা উচিত এবং কোনও অনুপস্থিত স্টোন কোড লোড করার চেষ্টা করার পরিবর্তে
        কেবল একটি ব্যতিক্রম উত্থাপন করবে। আমরা উত্পাদনে এই বিকল্পটি নিষ্ক্রিয় করার
        পক্ষে যুক্তিযুক্ত কারণ (যেমন আগে উল্লেখ করা হয়েছে) কোড লোডিং থ্রেডসফাই নয়
        এবং আমরা আশা করি যে কোনও থ্রেড অনুরোধগুলি হ্যান্ডেল করার আগে সমস্ত কোড লোড হবে।'
      concurrency: 'কনকুরেন্সের অনুমতি দেওয়া হচ্ছে: @allow_concurrency বিকল্পটি আপনার
        স্ট্যাকে র্যাক :: লক মিডলওয়্যার ব্যবহার করা হয় কিনা তা নিয়ন্ত্রণ করে। র্যাক
        :: লক আপনার অনুরোধ চারপাশে একটি mutex wraps। ধারণাটি হচ্ছে যে যদি আপনার কোডটি
        থ্রেডফেফ না থাকে তবে এই mutex একই সময়ে আপনার কন্ট্রোলার কোডটি কার্যকর করতে
        একাধিক থ্রেডকে বাধা দেবে। যখন থ্রেডসেফ! সেট করা হয়, এই মিডলওয়্যার মুছে ফেলা
        হয়, এবং নিয়ামক কোড সমান্তরাল মৃত্যুদন্ড কার্যকর করা যেতে পারে।'
    credits: 'কোড এবং নিবন্ধ সম্পদ থেকে নেওয়া হয়েছে:'
  ruby_meister:
    title: রুবি মিস্টার হত্তয়া
    description: এই আলাপে, আমরা সত্য রুবি মাস্টারি অর্জনের জন্য রুবি নবীন হতে দীর্ঘ
      যাত্রা পরীক্ষা করব এবং কিছু গুরুত্বপূর্ণ অন্তর্দৃষ্টি ভাগ করে নেওয়ার জন্য এটি
      আপনার জন্য কিছুটা ছোট করার চেষ্টা করব। একজন মাস্টার রুবিস্টের একটি মহান তাত্ত্বিক
      ভিত্তি রয়েছে, এটি একটি বিস্তৃত টুলবক্সে নির্ভর করে, রুবিয়ের মূল মূল্য এবং নীতিগুলি
      গভীরভাবে বোঝে এবং সর্বদা তাদের দক্ষতাকে সম্মান করে। সম্ভবত আপনি নিজেকে বলছেন &quot;বাহ,
      এটা বেশ অস্পষ্ট!&quot;, কিন্তু আপনি যদি এই সেশনে যোগ দেন তবে আমি আপনাকে আলোকিত,
      আনন্দিত এবং সম্পূর্ণরূপে উপভোগ করব! ভালো লাগে? মহান বইগুলি সেই সম্পদগুলির অংশ
      হবে যা আমি লোকেদের তাদের দক্ষতার স্তরের জন্য সুপারিশ করব।
    video: Bozhidar Batsov দ্বারা দ্য লং জার্নি টু রুবি মাস্টারি।
    computer_science_fundamentals:
      title: কম্পিউটার বিজ্ঞান মৌলিক
      articles:
        - name: inside_machine
          title: 'ইনসাইড মেশিন: মাইক্রোপ্রসেসর এবং কম্পিউটার আর্কিটেকচারের একটি চিত্রিত
            ভূমিকা'
          description: কম্পিউটারগুলি সমালোচনামূলক ব্যবসা থেকে বিনোদনমূলক পর্যন্ত অসংখ্য
            সংখ্যক কাজ সম্পাদন করে, তবে তারা কীভাবে ভিন্নভাবে দেখতে এবং আচরণ করতে পারে
            তা নির্বিশেষে, তারা সমস্ত মৌলিক ফাংশনগুলিতে অসাধারণভাবে একই রকম। একবার আপনি
            বুঝতে পারবেন কিভাবে মাইক্রোপ্রসেসর-বা কেন্দ্রীয় প্রক্রিয়াজাতকরণ ইউনিট
            (CPU) -works, আপনি সমস্ত আধুনিক কম্পিউটিংয়ের অন্তরে মৌলিক ধারণাগুলি দৃঢ়ভাবে
            বুঝতে পারবেন।
        - name: code
          title: 'কোড: কম্পিউটার হার্ডওয়্যার এবং সফ্টওয়্যার লুকানো ভাষা'
          description: ফ্ল্যাশলাইট, ব্রিটিশ আগ্রাসন, কালো বিড়াল, এবং দেখেছি কম্পিউটারের
            সাথে কি করতে হবে? CODE- এ, তারা আমাদের দক্ষ ভাষাগুলি কাজে লাগায় এবং একে
            অপরের সাথে যোগাযোগ করার নতুন উপায়গুলি আবিষ্কার করে। এবং CODE এর মাধ্যমে
            আমরা দেখি কিভাবে এই দক্ষতা এবং আমাদের মানবিক বাধ্যতাটি যোগাযোগের জন্য গত
            দুই শতাব্দীর প্রযুক্তিগত উদ্ভাবন চালিত হয়েছে।
        - name: concrete_math
          title: 'কংক্রিট গণিত: কম্পিউটার বিজ্ঞান জন্য একটি ফাউন্ডেশন'
          description: এই বই উন্নত কম্পিউটার প্রোগ্রামিং এবং অ্যালগরিদম বিশ্লেষণ সমর্থন
            করে যে গণিত। তার সুপরিচিত লেখকদের প্রাথমিক লক্ষ্যটি গাণিতিক দক্ষতার একটি
            কঠিন এবং প্রাসঙ্গিক ভিত্তি প্রদান করা - জটিল সমস্যা সমাধানের জন্য প্রয়োজনীয়
            দক্ষতা, ভয়ানক অর্থের মূল্যায়ন এবং ডেটাতে সূক্ষ্ম নিদর্শনগুলি আবিষ্কার
            করা। কম্পিউটার বিজ্ঞানীদের জন্য এটি একটি অপরিহার্য পাঠ্য এবং রেফারেন্স নয়
            - লেখকেরা এটির উপর ভরসা করে! - কিন্তু প্রকৃতপক্ষে প্রতিটি শৃঙ্খলে গণিত গুরুতর
            ব্যবহারকারীদের জন্য।
        - name: sicp
          title: কম্পিউটার প্রোগ্রাম গঠন এবং ব্যাখ্যা
          description: 'কম্পিউটার প্রোগ্রামের কাঠামো এবং ব্যাখ্যা এর গত দশকে কম্পিউটার
            বিজ্ঞান পাঠক্রমের ওপর নাটকীয় প্রভাব ফেলেছে। এই দীর্ঘ প্রতীক্ষিত পুনর্বিবেচনা
            টেক্সট জুড়ে পরিবর্তন রয়েছে। অনুবাদক এবং কম্পাইলারসহ বইয়ের বেশিরভাগ প্রধান
            প্রোগ্রামিং সিস্টেমের নতুন বাস্তবায়ন রয়েছে এবং লেখকরা অনেকগুলি ছোট্ট পরিবর্তনগুলি
            অন্তর্ভুক্ত করেছেন যা প্রথম সংস্করণ প্রকাশিত হওয়ার পর থেকে এমআইটিতে কোর্স
            শিখানোর অভিজ্ঞতা প্রদর্শন করে। একটি নতুন থিম চালু করা হয়েছে যা কম্পিউটেশনাল
            মডেলগুলিতে সময় মোকাবেলা করার বিভিন্ন পদ্ধতির দ্বারা পরিচালিত কেন্দ্রীয়
            ভূমিকা জোর দেয়: রাষ্ট্র, সমান্তরাল প্রোগ্রামিং, কার্যকরী প্রোগ্রামিং, এবং
            অলস মূল্যায়ন এবং নন্দনতত্ত্বমূলক প্রোগ্রামিং সহ বস্তু।'
        - name: design_programms
          title: 'কিভাবে ডিজাইন প্রোগ্রাম: প্রোগ্রামিং এবং কম্পিউটিং একটি ভূমিকা'
          description: প্রোগ্রামিংয়ের এই ভূমিকা একটি উদার শিল্প শিক্ষার মূল অংশে কম্পিউটার
            বিজ্ঞান স্থাপন করে। অন্যান্য প্রারম্ভিক বইয়ের বিপরীতে, এটি প্রোগ্রাম নকশা
            প্রক্রিয়াতে ফোকাস করে। এই পদ্ধতির বিভিন্ন দক্ষতা-সমালোচনামূলক পড়া, বিশ্লেষণাত্মক
            চিন্তাভাবনা, সৃজনশীল সংশ্লেষণ এবং বিস্তারিত মনোযোগকে উৎসাহিত করে-যা কেবলমাত্র
            ভবিষ্যতের কম্পিউটার প্রোগ্রামারদের জন্যই গুরুত্বপূর্ণ নয়। বই পাঠকদের দুটি
            মৌলিক নতুন ধারণা প্রকাশ করে। প্রথমত, এটি প্রোগ্রাম ডিজাইন নির্দেশিকাগুলি
            উপস্থাপন করে যা পাঠককে কোন সমস্যা বিবৃতি বিশ্লেষণ করতে দেখায়; সংক্ষিপ্ত
            লক্ষ্য গঠন কিভাবে; কিভাবে উদাহরণ আপ করতে হবে; বিশ্লেষণের ভিত্তিতে সমাধানটির
            রূপরেখা কিভাবে বিকাশ করবেন; কিভাবে প্রোগ্রাম শেষ করতে হবে; এবং পরীক্ষা কিভাবে।
        - name: algorithm_manual
          title: অ্যালগরিদম ডিজাইন ম্যানুয়াল
          description: সেরা বিক্রি ক্লাসিকের এই নতুন সম্প্রসারিত এবং আপডেট করা দ্বিতীয়
            সংস্করণটি &quot;রহস্য&quot; আলগোরিদিমগুলি ডিজাইন করার বাইরে নিয়ে যায় এবং
            তাদের কার্যকারিতা এবং দক্ষতা বিশ্লেষণ করে। প্রথম সংস্করণে সম্প্রসারিত, বইটি
            এখন অ্যালগরিদম নকশা কোর্সগুলির জন্য পছন্দসই প্রাথমিক পাঠ্যপুস্তক হিসাবে
            কাজ করে এবং প্রোগ্রামার, গবেষক এবং শিক্ষার্থীদের জন্য অ্যালগরিদমগুলির প্রধান
            প্রফেশনাল রেফারেন্স গাইড হিসাবে এটির অবস্থান বজায় রাখার সময় এটির স্থিতি
            বজায় রাখে।
        - name: cormen
          title: অ্যালগরিদম পরিচিতি, তৃতীয় সংস্করণ (এমআইটি প্রেস)
          description: অ্যালগরিদম কিছু বই কঠোর কিন্তু অসম্পূর্ণ; অন্যান্য উপাদান ভর
            কিন্তু আড়ম্বর অভাব আবরণ। আলগোরিদিম পরিচিতি অনন্যভাবে কঠোরতা এবং সংজ্ঞায়িত
            করে। বইটি গভীরতার মধ্যে আলগোরিদিমগুলির একটি বিস্তৃত পরিসরকে আচ্ছাদন করে,
            তবে তাদের ডিজাইন এবং বিশ্লেষক পাঠকদের সকল স্তরের অ্যাক্সেসযোগ্য করে তোলে।
            প্রতিটি অধ্যায় অপেক্ষাকৃত স্ব-অন্তর্ভুক্ত এবং গবেষণা ইউনিট হিসাবে ব্যবহার
            করা যেতে পারে। আলগোরিদিমগুলি ইংরেজীতে বর্ণনা করা হয়েছে এবং একটি ছদ্মকোডে
            যেটি কোনও ছোট প্রোগ্রামিংয়ের মাধ্যমে পাঠযোগ্য হতে পারে। ব্যাখ্যাগুলি কভারেজ
            বা গাণিতিক কঠোরতা ছাড়াই প্রাথমিক রাখা হয়েছে।
        - name: compilers
          title: 'কম্পাইলার: নীতি, কৌশল, এবং সরঞ্জাম (দ্বিতীয় সংস্করণ)'
          description: 'কম্পাইলার: বিশ্বব্যাপী অধ্যাপক, ছাত্র এবং ডেভেলপারদের কাছে &quot;ড্রাগন
            বুক&quot; হিসাবে পরিচিত মূলনীতি, কৌশল এবং সরঞ্জামগুলি একটি নতুন সংস্করণে
            উপলব্ধ। সর্বশেষ সংস্করণ প্রকাশিত হওয়ার পর 1986 সাল থেকে সফ্টওয়্যার প্রকৌশল,
            প্রোগ্রামিং ভাষা এবং কম্পিউটার আর্কিটেকচারের বিকাশগুলি প্রতিফলিত করার জন্য
            প্রতিটি অধ্যায় সম্পূর্ণরূপে সংশোধন করা হয়েছে। লেখকেরা স্বীকার করেছেন যে
            কিছু পাঠক কখনও কম্পাইলার নির্মাণ করতে যাবেন, সফ্টওয়্যার ডিজাইন এবং সফ্টওয়্যার
            ডেভেলপমেন্টের সমস্যার বিস্তৃত সেটগুলিতে তাদের ফোকাস বজায় রাখবেন।'
        - name: c_lang
          title: সি প্রোগ্রামিং ভাষা, দ্বিতীয় সংস্করণ
          description: লেখক এএনএসআই স্ট্যান্ডার্ড সি ভাষা প্রোগ্রামিং সম্পূর্ণ গাইড
            উপস্থাপন। C এর বিকাশকারীদের দ্বারা লিখিত, এই নতুন সংস্করণটি সিগুলির জন্য
            চূড়ান্ত ANSI মানকে সি-এর জন্য সমৃদ্ধ সেট, অভিব্যক্তির অর্থনীতি, নিয়ন্ত্রণ
            নিয়ন্ত্রণ প্রবাহ এবং ডেটা কাঠামোর সুবিধাগুলি কীভাবে কাজে লাগাতে হয় তা
            দেখায় সহায়তা করে। 2 / ই সম্পূর্ণরূপে কঠিন ভাষা গঠনের বাস্তবায়ন স্পষ্ট
            করার জন্য অতিরিক্ত উদাহরণ এবং সমস্যা সেটের সাথে পুনঃলিখন করা হয়েছে। বছর
            ধরে, সি প্রোগ্রামাররা কে-আর-রকে সুনির্দিষ্ট ও কার্যকরী প্রোগ্রামগুলি নির্মাণের
            জন্য তাদের নির্দেশ দিয়েছে। এখন, এই একই সাহায্য ANSI কম্পাইলারের সাথে কাজ
            করার জন্য উপলব্ধ। সি ভাষায় আরও বিস্তারিত কভারেজ সহ সরকারী সি ভাষা রেফারেন্স
            ম্যানুয়াল সিনট্যাক্স নোটেশন, ঘোষণা, এএনএসআই পরিবর্তন, সুযোগ নিয়ম, এবং
            তালিকার সাথে এক নজরে সহায়তা করে।
    oop:
      title: অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিং
      articles:
        - name: growing
          title: ক্রমবর্ধমান অবজেক্ট-ওরিয়েন্টেড সফ্টওয়্যার, টেস্ট দ্বারা নির্দেশিত
          description: 'টেস্ট-চালিত ডেভেলপমেন্ট (টিডিডি) এখন উন্নততর সফ্টওয়্যার দ্রুত
            সরবরাহের জন্য একটি প্রতিষ্ঠিত কৌশল। টিডিডি একটি সাধারণ ধারণা উপর ভিত্তি
            করে: কোড নিজেই লিখার আগে আপনার কোডের জন্য পরীক্ষা লিখুন। যাইহোক, এই &quot;সহজ&quot;
            ধারণা ভাল কাজ দক্ষতা এবং রায় নেয়। এখন টিডিডির একটি বাস্তব গাইড রয়েছে
            যা আপনাকে মৌলিক ধারণাগুলির বাইরে নিয়ে যায়। রিয়েল-ওয়ার্ল্ড সিস্টেমে বিল্ডিংয়ের
            এক দশক ধরে আঁকা, দুটি টিডিডি অগ্রদূতেরা দেখায় কিভাবে পরীক্ষাগুলি আপনার
            বিকাশকে নির্দেশ করে এবং &quot;উত্থাপিত&quot; সফ্টওয়্যার যা সুসংগত, নির্ভরযোগ্য
            এবং রক্ষণশীল।'
        - name: domain_driven
          title: 'ডোমেন চালিত ডিজাইন: সফটওয়্যারের হার্টের মধ্যে জটিলতা'
          description: এটি সফ্টওয়্যার নকশা ডোমেন মডেলিং সম্পর্কে একটি গুরুতর বই। সফটওয়্যার
            ডেভেলপমেন্ট সোসাইটি একটি হাইপ ওয়েভ থেকে অন্যের কাছে থাকে। OOP, নিদর্শন,
            এক্সপি, টিডিডি, সিআই / সিডি, বিগডাটা, ডেভপস - এটি শুধু কয়েক নামকরণ করা।
            এই বই OOP এর সুবর্ণ বয়স থেকে উদ্ভূত হয়। লেখক স্বীকার করেন যে বস্তু ভিত্তিক
            দৃষ্টান্ত একমাত্র পাওয়া যায় না তবে OOP / OOD দিকে পক্ষপাত স্পষ্ট (এবং
            ন্যায্য)। এই বইটি কীভাবে কোর সফটওয়্যার উপাদানগুলির &quot;সঠিক পথে&quot;
            মডেলিং করবেন তা সম্পর্কে জানায়।
    ruby:
      title: আপনি ল্যাং জানি
      articles:
        - name: well_grounded
          title: ভাল গ্রাউন্ডেড রুবিস্ট
          description: ভাল গ্রাউন্ডেড রুবিস্ট, দ্বিতীয় সংস্করণ রুবি এবং রুবি প্রোগ্রামার
            উভয় নতুনদেরকে সম্বোধন করে, যারা তাদের ভাষা বোঝার গভীরতা চায়। এই সুন্দর
            লিখিত এবং পুরোপুরি সংশোধিত দ্বিতীয় সংস্করণটিতে রুবি 2.1 তে নতুন বৈশিষ্ট্যগুলি
            অন্তর্ভুক্ত রয়েছে, সেইসাথে সেই ভাষাগুলির দিকগুলির বর্ধিত এবং আপডেট হওয়া
            কভারেজ পরিবর্তিত হয়েছে।
        - name: programming_ruby
          title: 'প্রোগ্রামিং রুবি: দ্য প্রাগমেটিক প্রোগ্রামার্স গাইড, দ্বিতীয় সংস্করণ'
          description: 'রুবি একটি ক্রমবর্ধমান জনপ্রিয়, পুরোপুরি বস্তু ভিত্তিক গতিশীল
            প্রোগ্রামিং ভাষা, আজকে উপলব্ধ সবচেয়ে ভাল এবং সবচেয়ে দরকারী ভাষা হিসাবে
            অনেক অনুশীলনকারীদের দ্বারা প্রশংসা। যখন রুবি প্রথম পশ্চিমা বিশ্বের দৃশ্যের
            দিকে ফেটে যায়, তখন প্রগমেটিক প্রোগ্রামারগণ নির্দিষ্ট রেফারেন্স ম্যানুয়াল
            প্রোগ্রামিং রুবি: দ্য প্রাগমেটিক প্রোগ্রামারস গাইড এর সাথে সেখানে ছিলেন।'
        - name: ruby_programming
          title: 'রুবি প্রোগ্রামিং ভাষা: আপনার যা কিছু জানা দরকার'
          description: 'এই বইটি ভাষাতে দ্রুত-শুরু টিউটোরিয়াল দিয়ে শুরু হয় এবং তারপরে
            নীচের দিক থেকে ভাষাটি বিস্তারিতভাবে ব্যাখ্যা করে: লেক্সিক্যাল এবং সিনট্যাকটিক
            কাঠামো থেকে ডেটাপৃপ থেকে এক্সপ্রেশন এবং বিবৃতিগুলিতে এবং পদ্ধতিগুলির মাধ্যমে,
            ব্লক, ল্যাম্বড, ক্লোজার, ক্লাস এবং মডিউল। বইটির রুবি প্ল্যাটফর্মের সমৃদ্ধ
            এপিআইয়ের দীর্ঘ এবং পুঙ্খানুপুঙ্খ ভূমিকা রয়েছে, যা প্রকাশ করে - ব্যাপকভাবে
            মন্তব্য করা কোড কোড - পাঠ্য প্রক্রিয়াকরণের জন্য রুবি এর সুবিধা, সংখ্যাসূচক
            ম্যানিপুলেশন, সংগ্রহ, ইনপুট / আউটপুট, নেটওয়ার্কিং এবং কনকুরেন্স। একটি সম্পূর্ণ
            অধ্যায় রুবি এর metaprogramming ক্ষমতা নিবেদিত হয়।'
  interview_questions:
    title: সাক্ষাৎকার প্রশ্ন
    description: এই বিভাগটি পড়া এবং ইন্টারভিউ প্রস্তুতির জন্য সম্পদ লিঙ্ক রাখে
    list:
      - name: 'Toptal: একটি মহান রুবি বিকাশকারী ভাড়া কিভাবে'
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: 'Toptal: 21 অপরিহার্য রুবি সাক্ষাত্কার প্রশ্ন'
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: 'Hookops: 35+ রুবি এবং রেল সাক্ষাৎকারের প্রশ্ন এবং উত্তর'
        link: "https://lab.hookops.com/ruby-interview-prep.html"
      - name: 'Educba: 15 সবচেয়ে গুরুত্বপূর্ণ রুবি সাক্ষাত্কার প্রশ্ন এবং উত্তর'
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: 'Ruby Garage: রেলের বিকাশকারীর উপর আপনার রুবি সাক্ষাত্কার কিভাবে করবেন'
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: 'RyanSobol: রুবি সাক্ষাৎকারের সময় 15 টি প্রশ্ন জিজ্ঞাসা করুন'
        link: "https://gist.github.com/ryansobol/5252653"
      - name: 'Toptal: রেল ইন্টারভিউ প্রশ্ন 9 অপরিহার্য রুবি'
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: ভাল ডক্স কি
    description: এই ওয়েবসাইটটি ওয়েব অভিযোজন <a href="https://github.com/khusnetdinov/ruby.fundamental">গীথুব</a>
      রিপোজিটরি <a href="https://github.com/khusnetdinov/ruby.fundamental">রুবি। ফুন্ডামেন্টাল</a>
      যা অনেকগুলি বড় সংগ্রহ করেছে এবং চীনা ভাষাতে অনুবাদ করেছে। ভাল ডক্স আপনাকে দ্রুত
      একটি সংগ্রহস্থলে সংগৃহীত অনেক ভাল অনুশীলন খুঁজে পেতে দেয়। শুধু আপনি রেফারেন্স
      বা ইন্টারভিউ প্রস্তুতি সম্পদ মত এই repo।
    oss:
      title: ওপেন সোর্স ধন্যবাদ
      description: রুবিতে লিখিত ওয়েব ডেভেলপমেন্ট অ্যাপ্লিকেশনগুলির জন্য একটি ওপেন সোর্স
        ইঞ্জিনিয়ারিং, রুবি সম্পর্কে সর্বোত্তম অনুশীলন এবং জ্ঞান সম্পর্কে কাজ করার সময়
        এবং সর্বোত্তম ডক্স তৈরি করা হয়েছিল।
      thanks: যদি উন্নততর ডক্স আপনাকে কোনও উপায়ে সহায়তা করে তবে আমাদেরকে <a href="https://github.com/howtohireme/ruby.fundamental">গীথুব-এ</a>
        একটি স্টার দেওয়ার বিষয়ে চিন্তা করুন (এটি আমাদের আরও ডেভেলপারগুলিতে পৌঁছাতে
        সহায়তা করে) বা আমাদের প্রকল্পগুলিতে অবদান রাখতে সহায়তা করে।
